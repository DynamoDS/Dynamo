using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;

using Autodesk.DesignScript.Interfaces;

using Dynamo.Core.Threading;
using Dynamo.Interfaces;
using Dynamo.Models;
using Dynamo.Selection;

using DynamoServices;

using Microsoft.Practices.Prism.ViewModel;
using Dynamo.DSEngine;

namespace Dynamo
{
    #region event handlers

    public delegate void RenderCompleteEventHandler(object sender, RenderCompletionEventArgs e);

    public delegate void RenderFailedEventHandler(object sender, RenderFailedEventArgs e);

    public delegate void ResultsReadyHandler(object sender, VisualizationEventArgs e);

    public delegate void VisualizerDelegate(NodeModel node, object geom, string tag, RenderDescription target, Octree.OctreeSearch.Octree octree);

    #endregion

    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject, IVisualizationManager, ICleanup
    {
        #region private members

        private string alternateContextName = "Host";
        private bool drawToAlternateContext = true;
        //private Octree.OctreeSearch.Octree octree;
        private bool updatingPaused;
        protected readonly DynamoModel dynamoModel;
        private readonly List<RenderPackage> currentTaggedPackages = new List<RenderPackage>();
        private bool alternateDrawingContextAvailable;
        private long taskId = -1;
        private List<long> taskList = new List<long>();
        
        #endregion

        #region public properties

        /// <summary>
        /// Flag allows us to pause visualization updates.
        /// </summary>
        public bool UpdatingPaused
        {
            get { return updatingPaused; }
            internal set
            {
                if (updatingPaused && value == false)
                {
                    AggregateUpstreamRenderPackages(new RenderTag(CurrentTaskId, null));
                }
                Debug.WriteLine("Updating paused = " + value.ToString());
                updatingPaused = value;
            }
        }

        /// <summary>
        /// Is another context available for drawing?
        /// This property can be queried indirectly by the view to enable or disable
        /// UI functionality based on whether an alternate drawing context is available.
        /// </summary>
        public bool AlternateDrawingContextAvailable
        {
            get { return alternateDrawingContextAvailable; }
            set
            {
                alternateDrawingContextAvailable = value;
                RaisePropertyChanged("AlternateDrawingContextAvailable");
            }
        }

        /// <summary>
        /// Should we draw to the alternate context if it is available?
        /// </summary>
        public bool DrawToAlternateContext
        {
            get { return drawToAlternateContext; }
            set
            {
                if (value == false)
                {
                    //if the present value has us drawing to the alternate
                    //context and we would like to stop doing so, we need 
                    //to trigger an event requesting alternate contexts
                    //to drop their visualizations
                    if (drawToAlternateContext)
                    {
                        drawToAlternateContext = value;
                        OnRequestAlternateContextClear(this, EventArgs.Empty);
                    }
                }
                else
                {
                    //we would like to reenable drawing to an alternate context.
                    //trigger the standard visualization complete event
                    if (!drawToAlternateContext)
                    {
                        drawToAlternateContext = value;
                        OnRenderComplete(this, new RenderCompletionEventArgs(-1));
                    }
                }
                RaisePropertyChanged("DrawToAlternateContext");
            }
        }

        /// <summary>
        /// Can be used to expose a name of the alternate context for use in the UI.
        /// </summary>
        public string AlternateContextName
        {
            get { return alternateContextName; }
            set { alternateContextName = value; }
        }

        public int MaxTesselationDivisions
        {
            get { return this.dynamoModel.MaxTesselationDivisions; }
            set { this.dynamoModel.MaxTesselationDivisions = value; }
        }

        public Object CurrentTaskIdMutex = new object();
        public long CurrentTaskId
        {
            get
            {
                lock (CurrentTaskIdMutex)
                {
                    return taskId;
                }
            }

            set
            {
                lock (CurrentTaskIdMutex)
                {
                    taskId = value;
                }
            }
        }

        public Object TaskListMutex = new object();
        //NOTE: LC: This isn't thread safe
        public List<long> TaskList
        {
            get
            {
                lock (TaskListMutex)
                {
                    return taskList;
                }
            }
            set
            {
                lock (TaskListMutex)
                {
                    taskList = value;
                }
            }
        }
        
        #endregion

        #region events

        /// <summary>
        /// An event triggered when there are results to visualize
        /// </summary>
        public event ResultsReadyHandler ResultsReadyToVisualize;

        protected virtual void OnResultsReadyToVisualize(object sender, VisualizationEventArgs e)
        {
            if (ResultsReadyToVisualize != null)
                ResultsReadyToVisualize(sender, e);
        }

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event RenderCompleteEventHandler RenderComplete;

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected virtual void OnRenderComplete(object sender, RenderCompletionEventArgs e)
        {
            if (RenderComplete != null)
                RenderComplete(sender, e);
        }

        /// <summary>
        /// An event triggered when want any alternate drawing contexts to be cleared.
        /// </summary>
        public event EventHandler RequestAlternateContextClear;

        /// <summary>
        /// Called when we would like to request the clearing of any alternate drawing contexts.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected virtual void OnRequestAlternateContextClear(object sender, EventArgs e)
        {
            if (RequestAlternateContextClear != null)
                RequestAlternateContextClear(sender, e);
        }

        #endregion

        #region constructors

        public VisualizationManager(DynamoModel model)
        {
            dynamoModel = model;

            dynamoModel.WorkspaceClearing += Pause;
            dynamoModel.WorkspaceCleared += UnPauseAndUpdate;

            dynamoModel.WorkspaceAdded += WorkspaceAdded;
            dynamoModel.WorkspaceRemoved += WorkspaceRemoved;

            dynamoModel.DeletionStarted += Pause;
            dynamoModel.DeletionComplete += UnPauseAndUpdate;

            dynamoModel.CleaningUp += Clear;

            UnPause(this, EventArgs.Empty);
        }

        #endregion

        #region public methods

        /// <summary>
        /// Pause the visualization manager.
        /// When the visualization manager is paused, no rendering
        /// will occur.
        /// </summary>
        public void Pause()
        {
            Pause(this, EventArgs.Empty);
        }

        /// <summary>
        /// Unpause the visualization manager.
        /// When the visualization manager is unpaused, the visualization
        /// manager begins rendering again.
        /// </summary>
        public void UnPause()
        {
            UnPauseAndUpdate(this, EventArgs.Empty);
        }

        /// <summary>
        /// Display a label for one or several render packages 
        /// based on the paths of those render packages.
        /// </summary>
        /// <param name="path"></param>
        public void TagRenderPackageForPath(string path)
        {
            CurrentTaskId++;
            TaskList.Add(CurrentTaskId);

            var packages = new List<RenderPackage>();

            //This also isn't thread safe
            foreach (var node in dynamoModel.CurrentWorkspace.Nodes)
            {
                lock (node.RenderPackagesMutex)
                {
                    //Note(Luke): this seems really inefficent, it's doing an O(n) search for a tag
                    //This is also a target for memory optimisation

                    packages.AddRange(
                        node.RenderPackages.Where(x => x.Tag == path || x.Tag.Contains(path + ":"))
                            .Cast<RenderPackage>());
                }
            }

            if (packages.Any())
            {
                //clear any labels that might have been drawn on this
                //package already and add the one we want
                if (currentTaggedPackages.Any())
                {
                    currentTaggedPackages.ForEach(x => x.DisplayLabels = false);
                    currentTaggedPackages.Clear();
                }

                packages.ToList().ForEach(x => x.DisplayLabels = true);
                currentTaggedPackages.AddRange(packages);

                var allPackages = new List<RenderPackage>();

                foreach (var node in dynamoModel.CurrentWorkspace.Nodes)
                {
                    lock (node.RenderPackagesMutex)
                    {
                        allPackages.AddRange(
                            node.RenderPackages.Where(x => ((RenderPackage)x).IsNotEmpty())
                                .Cast<RenderPackage>());
                    }
                }

                OnResultsReadyToVisualize(
                    this,
                    new VisualizationEventArgs(allPackages, Guid.Empty, CurrentTaskId));
            }
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node then sends
        /// a message that a visualization is ready
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public void AggregateUpstreamRenderPackages(RenderTag tag)
        {
            var packages = new List<IRenderPackage>();

            //send back just what the node needs
            var watch = new Stopwatch();
            watch.Start();

            if (tag.Node == null)
            {
                //send back everything
                IList<NodeModel> copyOfNodesList = dynamoModel.CurrentWorkspace.Nodes;
                foreach (var modelNode in copyOfNodesList)
                {
                    lock (modelNode.RenderPackagesMutex)
                    {
                        packages.AddRange(modelNode.RenderPackages);
                    }
                }

                watch.Stop();
                Debug.WriteLine(String.Format("RENDER: {0} ellapsed for aggregating geometry for background preview.", watch.Elapsed));

                if (packages.Any())
                {
                    // if there are packages, send any that aren't empty
                    OnResultsReadyToVisualize(this,
                        new VisualizationEventArgs(
                            packages.Where(x => ((RenderPackage)x).IsNotEmpty()).Cast<RenderPackage>(), Guid.Empty, tag.TaskId));
                }
                else
                {
                    // if there are no packages, still trigger an update
                    // so the view gets redrawn
                    OnResultsReadyToVisualize(this,
                        new VisualizationEventArgs(packages.Cast<RenderPackage>(), Guid.Empty, tag.TaskId));
                }

            }
            else
            {
                watch.Stop();
                Debug.WriteLine(String.Format("RENDER: {0} ellapsed for aggregating geometry for branch {1}.", watch.Elapsed, tag.Node.GUID));

                //send back renderables for the branch
                packages = GetUpstreamPackages(tag.Node.Inputs, 0).ToList();
                if (packages.Any())
                    OnResultsReadyToVisualize(this, new VisualizationEventArgs(packages.Where(x => ((RenderPackage)x).IsNotEmpty()).Cast<RenderPackage>(), tag.Node.GUID,tag.TaskId));
            }

            

            //LogVisualizationUpdateData(rd, watch.Elapsed.ToString());
        }

        /// <summary>
        /// Checks the current Render task id against the list of task ids.
        /// If a 'newer' task id is found, then another update has been fired more
        /// recently, so we should trigger a re-render.
        /// </summary>
        public void CheckIfLatestAndUpdate(long taskId)
        {
            if (!TaskList.Any(id => id > taskId)) return;

            Debug.WriteLine("RENDER : Latest render task id > {0}, re-rendering...", taskId);
            //renderManager.RequestRenderAsync(new RenderTask());
            
            //renderManager.Render(null,false);
        }

        /// <summary>
        /// Request updated visuals for a branch of the graph.
        /// </summary>
        /// <param name="node">The node whose branch you want updated visuals for, or null to return everything.</param>
        public void RequestBranchUpdate(NodeModel node)
        {
            var scheduler = dynamoModel.Scheduler;
            if (scheduler == null) // Shutdown has begun.
                return;

            // Schedule a AggregateRenderPackageAsyncTask here so that the 
            // background geometry preview gets refreshed.
            // 
            var task = new AggregateRenderPackageAsyncTask(scheduler);
            if (task.Initialize(dynamoModel.CurrentWorkspace, node))
            {
                task.Completed += OnRenderPackageAggregationCompleted;
                scheduler.ScheduleForExecution(task);
            }
        }

        #endregion

        #region private event handlers

        /// <summary>
        /// Disable visualization updates by unregistering event listeners from the model.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Pause(object sender, EventArgs e)
        {
            UpdatingPaused = true;
            UnregisterEventListeners();
        }

        /// <summary>
        /// Enable visualization updates by registering event listeners on the model.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void UnPause(object sender, EventArgs e)
        {
            UpdatingPaused = false;
            RegisterEventListeners();
        }

        /// <summary>
        /// Enable visualization updates and trigger an update of the visualizations.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void UnPauseAndUpdate(object sender, EventArgs e)
        {
            UpdatingPaused = false;
            RegisterEventListeners();
            OnRenderComplete(this, new RenderCompletionEventArgs(-1)); ;
        }

        private void WorkspaceAdded(WorkspaceModel model)
        {
            var workspace = model as HomeWorkspaceModel;
            if (workspace != null)
            {
                foreach (var node in workspace.Nodes)
                    NodeRemovedFromHomeWorkspace(node);
                workspace.NodeAdded -= NodeAddedToHomeWorkspace;
                workspace.NodeRemoved -= NodeRemovedFromHomeWorkspace;
            }
        }

        private void WorkspaceRemoved(WorkspaceModel model)
        {
            var workspace = model as HomeWorkspaceModel;
            if (workspace != null)
            {
                foreach (var node in workspace.Nodes)
                    NodeAddedToHomeWorkspace(node);
                workspace.NodeAdded += NodeAddedToHomeWorkspace;
                workspace.NodeRemoved += NodeRemovedFromHomeWorkspace;
            }
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event.
        /// </summary>
        /// <param name="node"></param>
        private void NodeRemovedFromHomeWorkspace(NodeModel node)
        {
            node.PropertyChanged -= NodePropertyChanged;

            /*if (!UpdatingPaused)
            {
                QueueRenderTask();
            }*/
        }

        /// <summary>
        /// Handler for the model's NodeAdded event.
        /// Registers for property changed events on the node.
        /// </summary>
        /// <param name="node"></param>
        private void NodeAddedToHomeWorkspace(NodeModel node)
        {
            //node.BlockingStarted += Pause;
            //node.BlockingEnded += UnPause;

            if (updatingPaused) return;

            node.PropertyChanged += NodePropertyChanged;
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void NodePropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            bool updateVisualization = false;

            switch (e.PropertyName)
            {
                case "IsVisible":
                case "IsUpstreamVisible":
                case "DisplayLabels":
                    updateVisualization = true;
                    break;
            }

            if (updateVisualization)
                RequestNodeVisualUpdateAsync(null);
        }

        private void SelectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Reset)
                return;

            if (updatingPaused)
                return;

            OnRenderComplete(this, new RenderCompletionEventArgs(-1)); ;
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event.
        /// </summary>
        /// <param name="connector"></param>
        private void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            // TODO: Ian should remove this when the CBN reconnection bug is solved.
            /*if (connector.Start.Owner.GetType() == typeof(CodeBlockNodeModel))
            {
                return;
            }

            //we are given the connector that was deleted
            //if it's end node still exists, clear the package for 
            //the node and trigger an update.
            if (connector.End != null)
                connector.End.Owner.ClearRenderPackages();

            //tell the watches that they require re-binding.
            QueueRenderTask();*/
        }

        #endregion

        #region private methods

        private void RegisterEventListeners()
        {
            dynamoModel.EvaluationCompleted += Update;
            dynamoModel.RequestsRedraw += Update;
            //dynamoModel.ConnectorDeletedFromHomeWorkspace += DynamoModel_ConnectorDeleted;
            DynamoSelection.Instance.Selection.CollectionChanged += SelectionChanged;

            foreach (var n in dynamoModel.CurrentWorkspace.Nodes)
                n.PropertyChanged += NodePropertyChanged;
        }

        private void UnregisterEventListeners()
        {
            dynamoModel.EvaluationCompleted -= Update;
            dynamoModel.RequestsRedraw -= Update;
            //dynamoModel.ConnectorDeletedFromHomeWorkspace -= DynamoModel_ConnectorDeleted;
            DynamoSelection.Instance.Selection.CollectionChanged -= SelectionChanged;

            foreach (var n in dynamoModel.CurrentWorkspace.Nodes)
                n.PropertyChanged -= NodePropertyChanged;
        }

        /// <summary>
        /// Handler for the RequestRedraw event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Update(object sender, EventArgs e)
        {
            // do nothing if it has come on EvaluationCompleted
            // and no evaluation was
            var args = e as EvaluationCompletedEventArgs;
            if (args != null && !args.EvaluationTookPlace)
                return;

            RequestNodeVisualUpdateAsync(null);
        }
        
        protected virtual void HandleRenderPackagesReadyCore()
        {
            // Default visualization manager does nothing here.
        }

        private void RequestNodeVisualUpdateAsync(NodeModel nodeModel)
        {
            if (nodeModel != null)
            {
                // Visualization update for a given node is desired.
                nodeModel.RequestVisualUpdateAsync(
                    dynamoModel.Scheduler,
                    dynamoModel.EngineController,
                    MaxTesselationDivisions);
            }
            else
            {
                // Get each node in workspace to update their visuals.
                foreach (var node in dynamoModel.CurrentWorkspace.Nodes)
                {
                    // Visualization update for a given node is desired.
                    node.RequestVisualUpdateAsync(
                        dynamoModel.Scheduler,
                        dynamoModel.EngineController,
                        MaxTesselationDivisions);
                }
            }

            // Schedule a NotifyRenderPackagesReadyAsyncTask here so that when 
            // render packages of all the NodeModel objects are generated, the 
            // VisualizationManager gets notified.
            // 
            var scheduler = dynamoModel.Scheduler;
            var notifyTask = new NotifyRenderPackagesReadyAsyncTask(scheduler);
            notifyTask.Completed += OnNodeModelRenderPackagesReady;
            scheduler.ScheduleForExecution(notifyTask);
        }

        private void OnNodeModelRenderPackagesReady(AsyncTask asyncTask)
        {
            // By design the following method is invoked on the context of 
            // ISchedulerThread, if access to any UI element is desired within
            // the method, dispatch those actions on UI dispatcher *inside* the
            // method, *do not* dispatch the following call here as derived 
            // handler may need it to remain on the ISchedulerThread's context.
            // 

            // Fire event to tell render targets to request their visuals
            OnRenderComplete(this, new RenderCompletionEventArgs(-1));

            // Call overridden method on visualization manager to
            // process whatever internal logic there is around
            // drawing a visualization.
            HandleRenderPackagesReadyCore();
        }

        private void OnRenderPackageAggregationCompleted(AsyncTask asyncTask)
        {
            var task = asyncTask as AggregateRenderPackageAsyncTask;
            var rps = new List<RenderPackage>();
            rps.AddRange(task.NormalRenderPackages.Cast<RenderPackage>());
            rps.AddRange(task.SelectedRenderPackages.Cast<RenderPackage>());

            Debug.WriteLine("Render aggregation complete for {0}", task.NodeId);

            var e = new VisualizationEventArgs(rps, task.NodeId, -1);
            OnResultsReadyToVisualize(this, e);
        }

        private void Clear(DynamoModel dynamoModel)
        {
            Pause(this, EventArgs.Empty);
            Cleanup();
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <param name="recursionLevelCount"></param>
        /// <returns>A collection of strings.</returns>
        private static IEnumerable<IRenderPackage> GetUpstreamPackages(Dictionary<int, Tuple<int, NodeModel>> inputs, 
            int recursionLevelCount)
        {
#if DEBUG
            const int maxRecursion = 200;
            Validity.Assert(recursionLevelCount < maxRecursion, "Stack Overflow protection trap");
#endif

            var packages = new List<IRenderPackage>();

            foreach (
                NodeModel node in
                    from pair in inputs
                    where pair.Value != null && (pair.Value.Item2 != null)
                    select pair.Value.Item2)
            {
                lock (node.RenderPackagesMutex)
                {
                    packages.AddRange(node.RenderPackages);
                }

                if (node.IsUpstreamVisible)
                    packages.AddRange(GetUpstreamPackages(node.Inputs, recursionLevelCount + 1));
            }

            return packages;
        }
        
        #endregion

        #region ICleanup interface

        public void Cleanup()
        {
            UnregisterEventListeners();
        }

        #endregion
    }

    public class VisualizationEventArgs : EventArgs
    {
        /// <summary>
        /// A list of render packages corresponding to 
        /// a branch or a whole graph.
        /// </summary>
        public IEnumerable<RenderPackage> Packages { get; internal set; }

        /// <summary>
        /// The id of the view for which the description belongs.
        /// </summary>
        public Guid Id { get; internal set; }

        public long TaskId { get; internal set; }

        public VisualizationEventArgs(IEnumerable<RenderPackage> description, Guid viewId, long taskId)
        {
            Packages = description;
            Id = viewId;
            TaskId = taskId;    
        }
    }

    public class RenderCompletionEventArgs : EventArgs
    {
        public long TaskId { get; set; }

        public RenderCompletionEventArgs(long taskId)
        {
            TaskId = taskId;
        }
    }

    public class RenderFailedEventArgs : EventArgs
    {
        public long TaskId { get; set; }

        public RenderFailedEventArgs(long taskId)
        {
            TaskId = taskId;
        }
    }

    public class RenderTag
    {
        public long TaskId { get; internal set; }
        public NodeModel Node { get; internal set; }

        public RenderTag(long taskId, NodeModel node)
        {
            TaskId = taskId;
            Node = node;
        }
    }
}
