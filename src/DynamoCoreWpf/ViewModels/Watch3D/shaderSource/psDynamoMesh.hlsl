
#define MESH
#include"Common.hlsl"
#include"CommonBuffers.hlsl"

//--------------------------------------------------------------------------------------
// Phong Lighting Reflection Model
//--------------------------------------------------------------------------------------
// Returns the sum of the diffuse and specular terms in the Phong reflection model
// The specular and diffuse reflection constants for the currently loaded material (k_d and k_s)
float4 calcPhongLighting(float4 LColor, float4 vMaterialTexture, float3 N, float3 L, float3 V, float3 R)
{
	float4 Id = vMaterialTexture * vMaterialDiffuse * saturate(dot(N, L));
	float4 Is = vMaterialSpecular * pow(saturate(dot(R, V)), sMaterialShininess);
	return (Id + Is) * LColor;
}

//used for texture lookup if the material has a diffuse map
//for our use case this is geometry generated by Display.BySurfaceColors()
SamplerState LinearSampler
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
	MaxAnisotropy = 16;
};

float4 main(PSInput input, bool isFrontFacing : SV_IsFrontFace) : SV_Target
{
	//TODO move to common or pass in from material or the vParams.
	float4 vSelectionColor = float4(0.0, 0.62, 1.0, 1.0);


	//flags were passed through from a common buffer per model
	//lets decode them

	int flags = int(vParams.x);
	
	//our flags are packed in this order:
  /*
	  None = 0,
	  IsFrozen = 1,
	  IsSelected = 2,
	  IsIsolated = 4,
	  IsSpecialRenderPackage = 8,
	  HasTransparency = 16, //not used
	  RequiresPerVertexColoration = 32
	  FlatShade = 64 //not used
	  */

	bool isFrozen = flags & 1;
	bool isSelected = flags & 2;
	bool isIsolated = flags & 4;
	bool isSpecialRenderPackage = flags & 8;
	bool requiresPerVertexColoration = flags & 32;


	//renormalize - does not support normal maps
	input.n = normalize(input.n);

	// get per pixel vector to eye-position
	float3 eye = normalize(vEyePos - input.wp.xyz);

	// To support two-sided surface lighting, we flip 
	// the normal of the surface if it's facing
	// away from us. There are many tessellated surfaces that have
	// normals that are not as expected.
	// SV_IsFrontFace is a system value (GPU sets this for us) you can read about here:
    //https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics
	input.n = isFrontFacing ? input.n : -input.n;

	// if this is a special render package - it should render with the material colors, ambient light
	// and not be directionally lit.
	if (isSpecialRenderPackage) {
		return vMaterialDiffuse + vMaterialEmissive + vMaterialAmbient * vLightAmbient;
	}

	//we need to support diffuse maps for nodes like Display.BySurfaceColors which use diffuse maps
	//instead of vertex colors.
	if (bHasDiffuseMap)
	{
		float4 vMaterialTexture = 1.0f;
		float4 I = vMaterialTexture = texDiffuseMap.Sample(LinearSampler, input.t);
		//TODO.... do want to lerp or just return selection color.
		if (isSelected) {
			I = lerp(vSelectionColor, I, 0.3);
		}

		//TODO this is why lighting is not applied to textured geometry - we just return here...
		//TODO use flat shade flag instead so users can choose to apply shading or not to any Display object.
		return I;
	}

	// light emissive and ambient intensity
	// this variable can be used for light accumulation
	float4 I = vMaterialEmissive + vMaterialAmbient * vLightAmbient;

	// compute lighting based on all lights in scene.
	// simple phong model with specular highlight.
	float4 vMaterialTexture = 1.0f;
	for (int i = 0; i < NumLights; ++i)
	{
		if (Lights[i].iLightType == 1) // directional
		{
			float3 lightDirection = normalize((float3) Lights[i].vLightDir); // light dir	
			//reflect is an hlsl instrinsic.
			float3 reflectedLightDir = reflect(-lightDirection, input.n);
			I += calcPhongLighting(Lights[i].vLightColor, vMaterialTexture, input.n, lightDirection, eye, reflectedLightDir);
		}
	}

	/// set diffuse alpha if selected or normal
	I.a = vMaterialDiffuse.a;

	//if frozen half alpha
	if (isFrozen) 
	{
		I.a = .5f;
	}
	//if isolated - alpha should always be low - 
	//overriding other alpha values (except if selected)
	if (isIsolated && !isSelected)
	{
		I.a = .1f;
	}


	if (requiresPerVertexColoration)
	{
		//multiply the vert color by the light
		I = I * input.c;
	}

	if (isSelected && !isIsolated)
	{
		I = lerp(vSelectionColor, I, 0.3);
	}


	return I;
}