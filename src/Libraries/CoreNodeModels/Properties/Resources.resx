<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AndDescription" xml:space="preserve">
    <value>Boolean AND: Returns true only if both of the inputs are true. If either is false, returns false.</value>
    <comment>Description for And</comment>
  </data>
  <data name="ApplyPortDataFuncArgToolTip" xml:space="preserve">
    <value>Result of application.</value>
  </data>
  <data name="ApplyPortDataFuncToolTip" xml:space="preserve">
    <value>Function to apply.</value>
  </data>
  <data name="BooleanDescription" xml:space="preserve">
    <value>Selection between a true and false.</value>
    <comment>Description for Boolean</comment>
  </data>
  <data name="BooleanSelectorSearchTags" xml:space="preserve">
    <value>true;truth;false</value>
    <comment>Search tags. When do translation, appending localized tags to the existing tags and use ';' to seperate them</comment>
  </data>
  <data name="ColorRangeDescription" xml:space="preserve">
    <value>Get a color given a color range.</value>
    <comment>Description for Color Range</comment>
  </data>
  <data name="ColorRangePortDataEndToolTip" xml:space="preserve">
    <value>The end color.</value>
  </data>
  <data name="ColorRangePortDataResultToolTip" xml:space="preserve">
    <value>The selected color.</value>
  </data>
  <data name="ColorRangePortDataStartToolTip" xml:space="preserve">
    <value>The start color.</value>
  </data>
  <data name="ColorRangePortDataValueToolTip" xml:space="preserve">
    <value>The value between 0 and 1 of the selected color.</value>
  </data>
  <data name="CombinatorPortDataCombToolTip" xml:space="preserve">
    <value>Combinator</value>
  </data>
  <data name="CombinatorPortDataResultToolTip" xml:space="preserve">
    <value>Combined lists</value>
  </data>
  <data name="ComposePortDataFunc0ToolTip" xml:space="preserve">
    <value>Function #0</value>
  </data>
  <data name="ComposePortDataFunc1ToolTip" xml:space="preserve">
    <value>Function #1</value>
  </data>
  <data name="ComposePortDataResultToolTip" xml:space="preserve">
    <value>Composed function.</value>
  </data>
  <data name="CreateListPortDataIndex0ToolTip" xml:space="preserve">
    <value>Item Index #0</value>
  </data>
  <data name="CreateListPortDataResultToolTip" xml:space="preserve">
    <value>A list</value>
  </data>
  <data name="DirectoryFromPathDescription" xml:space="preserve">
    <value>Creates a directory object from a path.</value>
    <comment>Description for Directory.FromPath</comment>
  </data>
  <data name="DirectoryNodeDescription" xml:space="preserve">
    <value>Allows you to select a directory on the system to get its path</value>
  </data>
  <data name="DirectoryObjectNodeDescription" xml:space="preserve">
    <value>Creates a directory object from a path</value>
  </data>
  <data name="DirectoryObjectPortDataPathToolTip" xml:space="preserve">
    <value>Path to the directory.</value>
  </data>
  <data name="DirectoryObjectPortDataResultToolTip" xml:space="preserve">
    <value>Directory object.</value>
  </data>
  <data name="DirectoryPathDescription" xml:space="preserve">
    <value>Allows you to select a directory on the system to get its path.</value>
    <comment>Description for Directory Path</comment>
  </data>
  <data name="DoubleInputNodeDescription" xml:space="preserve">
    <value>Creates a number.</value>
  </data>
  <data name="DoubleSliderDescription" xml:space="preserve">
    <value>A slider that produces double values.</value>
    <comment>Description for Double Slider</comment>
  </data>
  <data name="DoubleSliderNodeDescription" xml:space="preserve">
    <value>A slider that produces numeric values.</value>
  </data>
  <data name="DropDownPortDataResultToolTip" xml:space="preserve">
    <value>The selected {0}</value>
  </data>
  <data name="FileFromPathDescription" xml:space="preserve">
    <value>Creates a file object from a path.</value>
    <comment>Description for File.FromPath</comment>
  </data>
  <data name="FilenameNodeDescription" xml:space="preserve">
    <value>Allows you to select a file on the system to get its filename</value>
  </data>
  <data name="FileObjectNodeDescription" xml:space="preserve">
    <value>Creates a file object from a path.</value>
  </data>
  <data name="FileObjectPortDataPathToolTip" xml:space="preserve">
    <value>Path to the file.</value>
  </data>
  <data name="FileObjectPortDataResultToolTip" xml:space="preserve">
    <value>File object</value>
  </data>
  <data name="FilePathDescription" xml:space="preserve">
    <value>Allows you to select a file on the system to get its filename.</value>
    <comment>Description for File Path</comment>
  </data>
  <data name="FilterPortDataConditionToolTip" xml:space="preserve">
    <value>Predicate used to determine if an element is filtered in or out.</value>
  </data>
  <data name="FilterPortDataListToolTip" xml:space="preserve">
    <value>List to filter</value>
  </data>
  <data name="FilterPortDataResultInToolTip" xml:space="preserve">
    <value>List containing all elements "x" where condition(x) = True</value>
  </data>
  <data name="FilterPortDataResultOutToolTip" xml:space="preserve">
    <value>List containing all elements "x" where condition(x) = False</value>
  </data>
  <data name="FormulaDescription" xml:space="preserve">
    <value>Evaluates mathematical formulas. Uses NCalc: http://ncalc.codeplex.com/</value>
    <comment>Description for Formula</comment>
  </data>
  <data name="FormulaPortDataResultToolTip" xml:space="preserve">
    <value>Result of math computation</value>
  </data>
  <data name="FromArrayPortDataArrayToolTip" xml:space="preserve">
    <value>The array of object to be serialized</value>
  </data>
  <data name="FromArrayPortDataResultToolTip" xml:space="preserve">
    <value>String representation of the array</value>
  </data>
  <data name="FromArraySearchTags" xml:space="preserve">
    <value>string.fromarray;tostring;2string;list2string;listtostring;array2string;arraytostring</value>
    <comment>Search tags. When do translation, appending localized tags to the existing tags and use ';' to seperate them</comment>
  </data>
  <data name="FromObjectPortDataObjToolTip" xml:space="preserve">
    <value>Object to be serialized</value>
  </data>
  <data name="FromObjectPortDataResultToolTip" xml:space="preserve">
    <value>String representation of the object</value>
  </data>
  <data name="FromObjectSearchTags" xml:space="preserve">
    <value>string.fromobject;tostring;2string;number2string;numbertostring</value>
    <comment>Search tags. When do translation, appending localized tags to the existing tags and use ';' to seperate them</comment>
  </data>
  <data name="FunctionApplyDescription" xml:space="preserve">
    <value>Applies a function to arguments.</value>
    <comment>Description for Function.Apply</comment>
  </data>
  <data name="FunctionComposeDescription" xml:space="preserve">
    <value>Compose multiple functions.</value>
    <comment>Description for Function.Compose</comment>
  </data>
  <data name="IfDescription" xml:space="preserve">
    <value>Conditional statement</value>
    <comment>Description for If</comment>
  </data>
  <data name="IntegerSliderDescription" xml:space="preserve">
    <value>A slider that produces integer values.</value>
    <comment>Description for Integer Slider</comment>
  </data>
  <data name="IntegerSliderNodeDescription" xml:space="preserve">
    <value>A slider that produces integer values.</value>
  </data>
  <data name="LegacyNodeDescription" xml:space="preserve">
    <value>This is an obsolete node</value>
    <comment>Description for Legacy Node</comment>
  </data>
  <data name="ListCartesianProductDescription" xml:space="preserve">
    <value>Applies a combinator to each pair in the cartesian product of two sequences</value>
    <comment>Description for List.CartesianProduct</comment>
  </data>
  <data name="ListCombineDescription" xml:space="preserve">
    <value>Applies a combinator to each element in two sequences</value>
    <comment>Description for List.Combine</comment>
  </data>
  <data name="ListCreateDescription" xml:space="preserve">
    <value>Makes a new list out of the given inputs</value>
    <comment>Description for List.Create</comment>
  </data>
  <data name="ListFilterDescription" xml:space="preserve">
    <value>Filters a sequence by a given condition such that for an arbitrary element "x," condition(x) = True or False.</value>
    <comment>Description for List.Filter</comment>
  </data>
  <data name="ListForEachDescription" xml:space="preserve">
    <value>Performs a computation on each element of a list. Does not accumulate results.</value>
    <comment>Description for List.ForEach</comment>
  </data>
  <data name="ListLaceLongestDescription" xml:space="preserve">
    <value>Applies a combinator to each pair resulting from a longest lacing of the input lists. All lists have their last element repeated to match the length of the longest input.</value>
    <comment>Description for List.LaceLongest</comment>
  </data>
  <data name="ListLaceShortestDescription" xml:space="preserve">
    <value>Applies a combinator to each pair resulting from a shortest lacing of the input lists. All lists are truncated to the length of the shortest input.</value>
    <comment>Description for List.LaceShortest</comment>
  </data>
  <data name="ListMapDescription" xml:space="preserve">
    <value>Applies a function over all elements of a list, generating a new list from the results.</value>
    <comment>Description for List.Map</comment>
  </data>
  <data name="ListReduceDescription" xml:space="preserve">
    <value>Reduces a list into a new value by combining each element with an accumulated result.</value>
    <comment>Description for List.Reduce</comment>
  </data>
  <data name="ListScanDescription" xml:space="preserve">
    <value>Reduces a list into a new value by combining each element with an accumulated result, produces a list of successive reduced values.</value>
    <comment>Description for List.Scan</comment>
  </data>
  <data name="MapPortDataFxToolTip" xml:space="preserve">
    <value>The procedure used to map element</value>
  </data>
  <data name="MapPortDataListToolTip" xml:space="preserve">
    <value>The list to map over.</value>
  </data>
  <data name="MapPortDataResultToolTip" xml:space="preserve">
    <value>Mapped list</value>
  </data>
  <data name="NumberRangeDescription" xml:space="preserve">
    <value>Creates a sequence of numbers in the specified range.</value>
    <comment>Description for Number Range</comment>
  </data>
  <data name="NumberSequenceDescription" xml:space="preserve">
    <value>Creates a sequence of numbers.</value>
    <comment>Description for Number Sequence</comment>
  </data>
  <data name="OrDescription" xml:space="preserve">
    <value>Boolean OR: Returns true if either of the inputs are true. If neither are true, returns false.</value>
    <comment>Description for Or</comment>
  </data>
  <data name="PortDataFalseBlockToolTip" xml:space="preserve">
    <value>False block</value>
  </data>
  <data name="PortDataImageToolTip" xml:space="preserve">
    <value>image</value>
  </data>
  <data name="PortDataList1ToolTip" xml:space="preserve">
    <value>List #1</value>
  </data>
  <data name="PortDataList2ToolTip" xml:space="preserve">
    <value>List #2</value>
  </data>
  <data name="PortDataOperandToolTip" xml:space="preserve">
    <value>operand</value>
  </data>
  <data name="PortDataResultToolTip" xml:space="preserve">
    <value>result</value>
  </data>
  <data name="PortDataTestBlockToolTip" xml:space="preserve">
    <value>Test block</value>
  </data>
  <data name="PortDataTrueBlockToolTip" xml:space="preserve">
    <value>True block</value>
  </data>
  <data name="PortDataVariableToolTip" xml:space="preserve">
    <value>variable</value>
  </data>
  <data name="ReducePortDataReductorToolTip" xml:space="preserve">
    <value>Reductor Function: accepts one item from each list being reduced, and the current accumulated value, result is the new accumulated value.</value>
  </data>
  <data name="ReducePortDataResultToolTip" xml:space="preserve">
    <value>Reduced lists</value>
  </data>
  <data name="ReducePortDataSeedToolTip" xml:space="preserve">
    <value>Starting accumulated value, to be passed into the first call to the Reductor function.</value>
  </data>
  <data name="ReplaceByConditionDescription" xml:space="preserve">
    <value>Replaces an object with a given substitute if the original object satisfies a given condition.</value>
    <comment>Description for ReplaceByCondition</comment>
  </data>
  <data name="ReplacePortDataConditionToolTip" xml:space="preserve">
    <value>Predicate used to determine if it should be replaced.</value>
  </data>
  <data name="ReplacePortDataItemToolTip" xml:space="preserve">
    <value>Item to potentially be replaced</value>
  </data>
  <data name="ReplacePortDataReplaceWithToolTip" xml:space="preserve">
    <value>Object to replace with</value>
  </data>
  <data name="ReplacePortDataResultToolTip" xml:space="preserve">
    <value>If condition(item) = True, then "replaceWith" is returned. Otherwise "item" is returned unaltered.</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Resources_en_US" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources.en-US.resx;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="ScanPortDataReductorToolTip" xml:space="preserve">
    <value>Reductor Function: accepts one item from each list being reduced, and the current accumulated value, result is the new accumulated value.</value>
  </data>
  <data name="ScanPortDataResultToolTip" xml:space="preserve">
    <value>Scanned lists</value>
  </data>
  <data name="ScanPortDataSeedToolTip" xml:space="preserve">
    <value>Starting accumulated value, to be passed into the first call to the Reductor function.</value>
  </data>
  <data name="ScopeIfDescription" xml:space="preserve">
    <value>Scoped If statement</value>
    <comment>Description for Scope If</comment>
  </data>
  <data name="SelectionPortDataResultToolTip" xml:space="preserve">
    <value>The selected elements.</value>
  </data>
  <data name="StringfromArrayDescription" xml:space="preserve">
    <value>Convert an array to a string representation.</value>
    <comment>Description for String from Array</comment>
  </data>
  <data name="StringfromObjectDescription" xml:space="preserve">
    <value>Convert an object to a string representation.</value>
    <comment>Description for String from Object</comment>
  </data>
  <data name="StringInputNodeDescription" xml:space="preserve">
    <value>Creates a string.</value>
  </data>
  <data name="WatchDescription" xml:space="preserve">
    <value>Visualize the output of node.</value>
    <comment>Description for Watch</comment>
  </data>
  <data name="WatchImageDescription" xml:space="preserve">
    <value>Previews an image</value>
    <comment>Description for Watch Image</comment>
  </data>
  <data name="WatchImageSearchTags" xml:space="preserve">
    <value>image</value>
    <comment>Search tags. When do translation, appending localized tags to the existing tags and use ';' to seperate them</comment>
  </data>
  <data name="WatchNodeDescription" xml:space="preserve">
    <value>Visualize the output of node.</value>
  </data>
  <data name="WatchPortDataInputToolTip" xml:space="preserve">
    <value>Node to evaluate.</value>
  </data>
  <data name="WatchPortDataResultToolTip" xml:space="preserve">
    <value>Watch contents.</value>
  </data>
  <data name="WatchSearchTags" xml:space="preserve">
    <value>print;output;display</value>
    <comment>Search tags. When do translation, appending localized tags to the existing tags and use ';' to seperate them</comment>
  </data>
  <data name="WebRequestDescription" xml:space="preserve">
    <value>Make a web request given a url.</value>
    <comment>Description for Web Request</comment>
  </data>
  <data name="WebRequestPortDataResultToolTip" xml:space="preserve">
    <value>The result of the web request.</value>
  </data>
  <data name="WebRequestPortDataUrlToolTip" xml:space="preserve">
    <value>The url for the web request.</value>
  </data>
</root>