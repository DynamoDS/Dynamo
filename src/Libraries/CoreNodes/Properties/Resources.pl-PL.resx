<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BitmapOverflowError" xml:space="preserve">
    <value>Podane dane kolorów są zbyt duże, aby zmieściły się w granicach obrazu.</value>
  </data>
  <data name="EnumDateOfWeekFriday" xml:space="preserve">
    <value>Piątek</value>
  </data>
  <data name="EnumDateOfWeekMonday" xml:space="preserve">
    <value>Poniedziałek</value>
  </data>
  <data name="EnumDateOfWeekSaturday" xml:space="preserve">
    <value>Sobota</value>
  </data>
  <data name="EnumDateOfWeekSunday" xml:space="preserve">
    <value>Niedziela</value>
  </data>
  <data name="EnumDateOfWeekThursday" xml:space="preserve">
    <value>Czwartek</value>
  </data>
  <data name="EnumDateOfWeekTuesday" xml:space="preserve">
    <value>Wtorek</value>
  </data>
  <data name="EnumDateOfWeekWednesday" xml:space="preserve">
    <value>Środa</value>
  </data>
  <data name="Exception_Deserialize_Bad_Format" xml:space="preserve">
    <value>Obiekt json dla typu {0} nie jest poprawnie sformatowany</value>
  </data>
  <data name="Exception_Deserialize_Unsupported_Cache" xml:space="preserve">
    <value>Nie można wczytać przechowywanych danych.</value>
  </data>
  <data name="Exception_Serialize_Depth_Unsupported" xml:space="preserve">
    <value>Głębokość {0} przekracza wartość MaxDepth {1} w ścieżce „{2}”</value>
  </data>
  <data name="Exception_Serialize_DesignScript_Unsupported" xml:space="preserve">
    <value>Nie można serializować tego typu geometrii.</value>
  </data>
  <data name="Exception_Serialize_Unsupported_Type" xml:space="preserve">
    <value>Nie można zapisać danych typu {0}.</value>
  </data>
  <data name="ExportToCSVObsolete" xml:space="preserve">
    <value>Zamiast tego użyj węzła Data.ExportCSV</value>
  </data>
  <data name="FactorialNegativeInt" xml:space="preserve">
    <value>Wartość danych wejściowych z Math. Factorial nie może być ujemna.</value>
  </data>
  <data name="FactorialOverflow" xml:space="preserve">
    <value>Zwracana wartość Math. Factorial jest poza zakresem.</value>
  </data>
  <data name="FindPointsWithinRadiusNullPointMessage" xml:space="preserve">
    <value>Należy podać punkt środkowy.</value>
  </data>
  <data name="FindPointsWithinRadiusSearchRadiusMessage" xml:space="preserve">
    <value>Promień wyszukiwania nie może być równy zeru.</value>
  </data>
  <data name="FromObjectObsolete" xml:space="preserve">
    <value>Węzeł ten jest przestarzały, należy użyć polecenia „Ciąg z obiektu"</value>
  </data>
  <data name="IntegerOverflow" xml:space="preserve">
    <value>Operacja spowodowała przepełnienie liczby całkowitej. Jej wynik może być nieoczekiwany.</value>
  </data>
  <data name="InvalidDestinationPathErrorMessage" xml:space="preserve">
    <value>Jako ścieżki kopii użyto niewłaściwej ścieżki pliku docelowego.</value>
  </data>
  <data name="InvalidKeysErrorMessage" xml:space="preserve">
    <value>Brak zgodności jednego typu danych wejściowych lub większej ich liczby. Listy jako klucze nie są obsługiwane.</value>
  </data>
  <data name="InvalidKeysLenghtErrorMessage" xml:space="preserve">
    <value>Liczba elementów nie odpowiada liczbie kluczy. href=InvalidKeysLenghtErrorMessage.html</value>
  </data>
  <data name="LoadImageFromPathObsolete" xml:space="preserve">
    <value>Zamiast tego należy użyć węzłów File.FromPath -&gt; Image.ReadFromFile</value>
  </data>
  <data name="MissingPythonEngine" xml:space="preserve">
    <value>Nie można znaleźć wybranego silnika w języku Python</value>
  </data>
  <data name="ObjectArgumentExceptionMessage" xml:space="preserve">
    <value>Obiekt nie może być pusty, należy podać odpowiednią wartość.</value>
  </data>
  <data name="QuadtreeConstructionEmptyUVSetMessage" xml:space="preserve">
    <value>Nie można zbudować drzewa czwórkowego z pustego zbioru punktów.</value>
  </data>
  <data name="QuadtreeConstructionNullUVSetMessage" xml:space="preserve">
    <value>Drzewo czwórkowe nie może być utworzone z pustego zestawu UV.</value>
  </data>
  <data name="ReadImageObsolete" xml:space="preserve">
    <value>Zamiast tego należy użyć węzłów File.FromPath -&gt; Image.ReadFromFile -&gt; Image.Pixels</value>
  </data>
  <data name="ReadTextObsolete" xml:space="preserve">
    <value>Zamiast tego należy użyć węzłów File.FromPath -&gt; File.ReadText.</value>
  </data>
  <data name="StringRemoveCountOutOfRangeMessage" xml:space="preserve">
    <value>Liczba jest poza zakresem!</value>
  </data>
  <data name="StringRemoveStartIndexOutOfRangeMessage" xml:space="preserve">
    <value>startIndex znajduje się poza zakresem!</value>
  </data>
  <data name="StringToNumberInvalidNumberMessage" xml:space="preserve">
    <value>Nie jest prawidłową liczbą.</value>
  </data>
  <data name="WebRequestNullUrlMessage" xml:space="preserve">
    <value>URL nie może być pusty.</value>
  </data>
  <data name="WriteImageObsolete" xml:space="preserve">
    <value>Zamiast tego należy użyć węzła Image.WriteToFile</value>
  </data>
  <data name="DefineDataUnexpectedInputExceptionMessage" xml:space="preserve">
    <value>Ten węzeł oczekiwał danych wejściowych {0}, ale przekazano do niego dane wejściowe {1}. Podaj oczekiwane dane wejściowe lub wybierz nowy typ z menu rozwijanego węzła.</value>
  </data>
  <data name="DefineDataUnsupportedCombinationOfDataTypesExceptionMessage" xml:space="preserve">
    <value>Ten węzeł nie obsługuje kombinacji typów danych na bieżącej liście wejściowej {0}. Upewnij się, że lista wejściowa zawiera elementy tego samego typu danych lub kombinację typów ze wspólnym typem nadrzędnym</value>
  </data>
  <data name="DefineDataUnsupportedDataTypeExceptionMessage" xml:space="preserve">
    <value>Ten węzeł nie obsługuje bieżącego typu danych wejściowych ({0}). Sprawdź obsługiwane typy danych w menu rozwijanym.</value>
  </data>
  <data name="DefineDataSupportedInputValueExceptionMessage" xml:space="preserve">
    <value>Dane wejściowe muszą być pojedynczą wartością lub listą niezagnieżdżoną.</value>
  </data>
  <data name="CurveMapperEqualMinMaxWarning" xml:space="preserve">
    <value>• Min and Max values must not be the same.</value>
  </data>
  <data name="CurveMapperInvalidCountWarning" xml:space="preserve">
    <value>• Values must be a list of numbers or a single number ≥ 2.</value>
  </data>
  <data name="CurveMapperInvalidCurveWarning" xml:space="preserve">
    <value>• Control points for the selected curve are not valid.</value>
  </data>
  <data name="CurveMapperInvalidXYFormatWarning" xml:space="preserve">
    <value>• X and Y inputs must be single numbers (not lists).</value>
  </data>
</root>