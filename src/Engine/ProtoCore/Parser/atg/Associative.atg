//------------------------------Associative----------------------------------//
Hydrogen<out Node codeBlockNode>
=                           
(. 
    ProtoCore.AST.AssociativeAST.CodeBlockNode codeblock = new ProtoCore.AST.AssociativeAST.CodeBlockNode();  
    NodeUtils.SetNodeStartLocation(codeblock, t); 
    ProtoCore.AST.AssociativeAST.AssociativeNode node = null; 
    ProtoFFI.ImportModuleHandler imh = null;
    if (core.IsParsingPreloadedAssembly)
    {
       imh = core.ImportHandler;
    }
    else
    {
        imh = this.ImportModuleHandler;
    }
    bool rootImport = null == imh;  
.)
    {
        (. ProtoCore.AST.AssociativeAST.AssociativeNode importNode = null; .)
        Import_Statement <out importNode>
        (. 
           if (null != importNode)
              (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(importNode);
        .)
    }
 (. 
    imh = null;
    if (core.IsParsingPreloadedAssembly)
    {
       imh = core.ImportHandler;
    }
    else
    {
        imh = ImportModuleHandler;
    }
    if(null != core.ContextDataManager)
    {
       if (imh == null)
           imh = new ProtoFFI.ImportModuleHandler(core);
       ProtoCore.AST.AssociativeAST.AssociativeNode importNode = null;
       importNode = core.ContextDataManager.Compile(imh);
       if (null != importNode)
           (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(importNode);
    }
    
    if (rootImport && null != imh && imh.RootImportNode.CodeNode.Body.Count != 0)
    {
       (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(imh.RootImportNode);
    }

    if (rootImport && core.IsParsingPreloadedAssembly && !builtinMethodsLoaded)
    {
        CoreUtils.InsertPredefinedAndBuiltinMethods(core, codeblock);
       core.ImportNodes = codeblock;
    }
.)
  {
    ( 
        IF(IsNotAttributeFunctionClass())     
        (                            
            Associative_Statement<out node>
        )
        |
        (
            (
                (	               
                    Associative_functiondecl<out node>
                )
                |
                (
                    Associative_classdecl<out node>
                )
            )
        )
    )   
                            (.  if (null != node)
                                {
                                    (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(node); 
                                    
                                    stmtsParsed++;
                                }
                            .)                        
  }         

  
                           (. if (la.val == "if")
                                 SynErr(String.Format(Resources.UseInlineConditional, la.val)); .)
                           (. if ((la.val == "for")||(la.val == "while"))
                                 SynErr(String.Format(Resources.ValidForImperativeBlockOnly, la.val)); .)
                           (. 
                                codeBlockNode = codeblock;

                                // We look ahead (la) here instead of looking at the current token (t)
                                // because when we get here at the end of a language block, "t" would 
                                // have been pointing to the ending token of the last statement in the 
                                // language block. What we really need here is the closing bracket '}'
                                // character, and that's conveniently residing in the look ahead token.
                                // 
                                NodeUtils.SetNodeEndLocation(codeblock, la); 
                           .)
.

Import_Statement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=  SYNC
    (. 
       string moduleName = "", typeName = "", alias = "";
    .)
        kw_import 
        '(' 
            ((
                textstring  (. moduleName = t.val;.) 
             )
            |
            (
                ident       (. typeName = t.val;
                            .)
                kw_from 
                textstring  (. moduleName = t.val; .)
            )) 
        ')' 
        [kw_prefix ident] 
                            (. 
                                if (la.kind != _endline)
                                   SynErr(Resources.SemiColonExpected);
                            .)
        endline
    (.
        if (moduleName == null) {
            node = null;
            return;
        }

        ProtoFFI.ImportModuleHandler imh = null;
        if (core.IsParsingPreloadedAssembly)
        {
            if (core.ImportHandler == null)
            {
                core.ImportHandler = new ProtoFFI.ImportModuleHandler(core);

            }
            imh = core.ImportHandler;
        }
        else
        {
            if (this.ImportModuleHandler == null)
            {

            this.ImportModuleHandler = new ProtoFFI.ImportModuleHandler(core);
         }
            imh = this.ImportModuleHandler;
        }

        node = imh.Import(moduleName, typeName, alias);
    .)
.

//------------------------------------------------------------------------
Associative_Statement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>      
=  SYNC                     (. if (!IsFullClosure()) SynErr(Resources.CloseBracketExpected); .)
                            (. node = null; .)
(
	IF(IsNonAssignmentStatement())
		Associative_NonAssignmentStatement<out node>
	|
    IF(IsFunctionCallStatement())
		Associative_FunctionCallStatement<out node>

	|
        Associative_FunctionalStatement<out node>
    |      
        Associative_LanguageBlock<out node>
    |
        (
            (
                IF(core.ParsingMode == ParseMode.AllowNonAssignment)  
                    [
                        Associative_Expression<out node>
                    ]
                    endline   
            )
            |
            (
                (. 
                    if (la.val != ";")
                        SynErr(Resources.SemiColonExpected);
                .)
                endline   
            )      
        )
)
.

Associative_StatementList<.out List<ProtoCore.AST.AssociativeAST.AssociativeNode> nodelist.> 
=
                    (. nodelist = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); .)
{ 
    (. ProtoCore.AST.AssociativeAST.AssociativeNode node = null; .)
    Associative_Statement<out node> (. if (null != node) nodelist.Add(node); .)
}    
    (.         
        if (la.val == "if")
            SynErr(String.Format(Resources.UseInlineConditional, la.val)); 
        if ((la.val == "for")||(la.val == "while"))
             SynErr(String.Format(Resources.ValidForImperativeBlockOnly, la.val));
    .)
.

Associative_classdecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node.>
=
                                                (. ProtoCore.AST.AssociativeAST.ClassDeclNode classnode = new ProtoCore.AST.AssociativeAST.ClassDeclNode(); .)
                                                (. NodeUtils.SetNodeLocation(classnode, la); .)
    kw_class        
    ident                                       (. classnode.ClassName = t.val; .)      
                                                (. isInClass = true;
                                                    if (IsKeyWord(t.val, true))
                                                    {
                                                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                                    }
                                                .)
    [
        kw_extend
        ident                                   (.
                                                    classnode.BaseClass = t.val;
                                                .)
    ]
    '{'
        {										
                                               (. ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public; .)
            [
                Associative_AccessSpecifier<out access>
            ]
            (           
                (      
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode constr = null; .)   
                    Associative_constructordecl<out constr, access>     
                                                (. if (String.IsNullOrEmpty(constr.Name))
                                                   {
                                                       constr.Name= classnode.ClassName;
                                                   }
                                                   classnode.Procedures.Add(constr); 
                                                .)
                )
                |
                (
                                                (. bool isStatic = false; .)
                    [
                        kw_static               (. isStatic = true; .) 
                    ]
                    (
                        (   
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode varnode = null; .)  
                            Associative_memvardecl<out varnode, access, isStatic>    
                                                (. classnode.Variables.Add(varnode); .)

                                                (. 
                                                   if (la.val != ";")
                                                       SynErr(Resources.SemiColonExpected);  
                                                .)
                                                endline
                                                (. NodeUtils.SetNodeEndLocation(varnode, t); .)
                        )
                        |
                        endline
                    )
                )
            )
            
        }
    '}' 
                                                (. isInClass = false; classnode.endLine = t.line; classnode.endCol = t.col; .)
                                                (. node = classnode; .)
.



Associative_LanguageBlock<out ProtoCore.AST.AssociativeAST.AssociativeNode node>            
=                                       
                                        (. 
                                            node = null; 
                                            ProtoCore.AST.AssociativeAST.LanguageBlockNode langblock = new ProtoCore.AST.AssociativeAST.LanguageBlockNode(); 
                                        .)  
    openbracket                         (. NodeUtils.SetNodeLocation(langblock, t); .)
    ident
                                        (.
                                            if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.imperative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Imperative;
                                            }
                                            else if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.associative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Associative; 
                                            }
                                            else {
                                                langblock.codeblock.Language = ProtoCore.Language.NotSpecified;
                                                errors.SemErr(t.line, t.col, String.Format(Resources.InvalidLanguageBlockIdentifier, t.val));
                                            }
                                        .)
    closebracket    
    '{'                      (. Node codeBlockNode = null; .)
    
    (
    IF( langblock.codeblock.Language == ProtoCore.Language.Associative ||
        langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
    Hydrogen<out codeBlockNode>              
    |    
    IF( langblock.codeblock.Language == ProtoCore.Language.Imperative )
    Imperative<out codeBlockNode>              
    )
    (
     IF( langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
                                            (. int openCurlyBraceCount = 0, closeCurlyBraceCount = 0; .)
                                            (. ProtoCore.AST.AssociativeAST.CodeBlockNode codeBlockInvalid = new ProtoCore.AST.AssociativeAST.CodeBlockNode(); .)
                                            (. ProtoCore.AST.AssociativeAST.AssociativeNode validBlockInInvalid = null; .)
    {
    IF (closeCurlyBraceCount <= openCurlyBraceCount)  
    (                                                                           
        Associative_LanguageBlock<out validBlockInInvalid>   (. codeBlockInvalid.Body.Add(validBlockInInvalid); .)
        |       
        '{'                                 (. openCurlyBraceCount++; .)
        |
        '}'                                 (. closeCurlyBraceCount++; .)
        |
        EOF
        '}'                                 (. break; .)  
        |
                                    (. Get(); .)
    )   
    }                                    
                                            (. codeBlockNode = codeBlockInvalid; .)
    |
    '}'
    )                                       (. langblock.CodeBlockNode = codeBlockNode; .)
                                            (. node = langblock; .)
.       

Associative_constructordecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode constrNode, ProtoCore.CompilerDefinitions.AccessModifier access.>
=                           (.
                                ProtoCore.AST.AssociativeAST.ConstructorDefinitionNode constr = new ProtoCore.AST.AssociativeAST.ConstructorDefinitionNode(); ;                                 
                                string methodName;  
                                ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature; 
                            .)  
    kw_constructor          (. NodeUtils.SetNodeStartLocation(constr, t); .)
    Associative_CtorSignature<out methodName, out argumentSignature>
                            (.
                                var returnType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, Constants.kArbitraryRank);
                            
                                constr.Name = methodName; 
                                constr.ReturnType = returnType;
                                constr.Signature = argumentSignature as ProtoCore.AST.AssociativeAST.ArgumentSignatureNode;
                                constr.Access = access; 
                                ProtoCore.AST.AssociativeAST.AssociativeNode functionBody = null; 
                            .)
    [
        ':'                                         (. ProtoCore.AST.AssociativeAST.AssociativeNode bnode; .)
        Associative_BaseConstructorCall<out bnode>  (. constr.BaseConstructor = bnode as ProtoCore.AST.AssociativeAST.FunctionCallNode; .)
    ]
(
    Associative_FunctionDefinitionBody<out functionBody> 
)
                            (. constr.FunctionBody = functionBody as ProtoCore.AST.AssociativeAST.CodeBlockNode; .)
                            (. NodeUtils.SetNodeEndLocation(constr, functionBody); .)
                            (. constrNode = constr; .)
.

Associative_BaseConstructorCall<out ProtoCore.AST.AssociativeAST.AssociativeNode bnode>
=                                   (. ProtoCore.AST.AssociativeAST.FunctionCallNode f = new ProtoCore.AST.AssociativeAST.FunctionCallNode(); .)
                                    (. List<ProtoCore.AST.AssociativeAST.AssociativeNode> args = null; .)
                                    (. 
                                       if (la.val != "base")
                                       {
                                           SynErr(Resources.BaseIsExpectedToCallBaseConstructor); 
                                       }
                                       else
                                       {
                                           Get();
                                           NodeUtils.SetNodeLocation(f, t);
                                       }
                                    .)
    [ 
        "."
        Associative_Ident<out bnode>            (. f.Function = bnode; .)
    ]
    Associative_Arguments<out args>             (. f.FormalArguments = args; .) 
                                                (. bnode = f; .)
.

//------------------------------------------------------------------------
Associative_AccessSpecifier<out ProtoCore.CompilerDefinitions.AccessModifier access>
=                   (. access = ProtoCore.CompilerDefinitions.AccessModifier.Public; .)
    (
        "public"        
        |
        "private"       (. access = ProtoCore.CompilerDefinitions.AccessModifier.Private; .)
        |
        "protected"     (. access = ProtoCore.CompilerDefinitions.AccessModifier.Protected; .)
    )
.

Associative_functiondecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public, bool isStatic = false.>
=                           
                            (. 
                                ProtoCore.AST.AssociativeAST.FunctionDefinitionNode f = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode(); 
                                string methodName;  
                                ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature; 
                                ProtoCore.Type returnType;  
                                string externLibName = ""; 
                                bool isExternLib = false; 
                            .)  
    kw_def                  (. NodeUtils.SetNodeLocation(f, t); .)
    Associative_MethodSignature<out methodName, out argumentSignature, out returnType>
                            (.
                                if (isExternLib &&  "var" == returnType.Name){
                                    errors.Warning(String.Format("External function {0} does not have a return type defined. Defaulting to var.", methodName));
                                }

                            .) 
                            (. 
                                f.IsExternLib = isExternLib; 
                                f.ExternLibName = externLibName; 
                                f.Name = methodName; 
                                f.ReturnType = returnType; 
                                f.Access = access;
                                f.Signature = argumentSignature as ProtoCore.AST.AssociativeAST.ArgumentSignatureNode; 
                                f.IsStatic = isStatic;
                                ProtoCore.AST.AssociativeAST.AssociativeNode functionBody = null; 
                            .) 
    Associative_FunctionDefinitionBody<out functionBody>
                            (. f.FunctionBody = functionBody as ProtoCore.AST.AssociativeAST.CodeBlockNode; 
                                node = f;   
                            .)
               
.

//------------------------------------------------------------------------
Associative_MethodSignature<out string methodName, out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign, out ProtoCore.Type returnType>
=
ident                           (. methodName = t.val; .)
                                (.  if (IsKeyWord(t.val, true))
                                    {
                                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                    }
                                    ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature = null;
                                    returnType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, Constants.kArbitraryRank);
                                .)
[
    Associative_TypeRestriction<out returnType>
]

Associative_ArgumentSignatureDefinition<out argumentSignature>
                                (. argumentSign = argumentSignature; .)
.

Associative_CtorSignature<out string ctorName, out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign>
=
                                (. ctorName = null;  .)
[
    ident                       (. ctorName = t.val; .)
                                (.  if (IsKeyWord(ctorName, true))
                                    {
                                         errors.SemErr(t.line, t.col, String.Format(Resources.keywordCannotBeUsedAsConstructorName, t.val));
                                    }
                                .)
]
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature = null;.) 
Associative_ArgumentSignatureDefinition<out argumentSignature>
                                (. argumentSign = argumentSignature; .)
.

//------------------------------------------------------------------------
Associative_ArgumentSignatureDefinition<out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign>
                                                (. ProtoCore.AST.AssociativeAST.ArgumentSignatureNode argumentSignature = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode(); .)
= 
'('                                             (. NodeUtils.SetNodeLocation(argumentSignature, t); .)
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode arg;.)
    [
                                                (. if (NotDefaultArg()) { .)
        Associative_ArgDecl<out arg>            (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        
        {                                       (. if (NotDefaultArg()) { .) 
                WEAK ','            
                Associative_ArgDecl<out arg>    (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
                                                (. } else break; .)
        }    
                                                (. } .)
    ]    
    [
        [
            ','
        ]        
        Associative_DefaultArgDecl<out arg>                 (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        {
            ','
           Associative_DefaultArgDecl<out arg>              (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        }
    ]
')'
                                                (. argumentSign = argumentSignature; .)
.

Associative_memvardecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public, bool isStatic = false.>    
= 
                                    (.
                                        ProtoCore.AST.AssociativeAST.IdentifierNode tNode = null; 
                                        ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = new ProtoCore.AST.AssociativeAST.VarDeclNode(); 
                                        varDeclNode.Access = access;
                                        varDeclNode.IsStatic = isStatic;
                                    .)

    (
        ident                       (. 
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        NodeUtils.SetNodeLocation(varDeclNode, t);
                                        tNode = AstFactory.BuildIdentifier(t.val);
                                        NodeUtils.SetNodeLocation(tNode, t);
                                        varDeclNode.NameNode = tNode;
                                    .)  
    )
    [
    ':'
    ident                           (. ProtoCore.Type argtype = new ProtoCore.Type(); argtype.Name = t.val; argtype.rank = 0; .)
    [                               
        openbracket closebracket    (. argtype.rank = 1; .)
        [
            ( ".." openbracket closebracket )   (. argtype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
            |
            ( 
                {
                    openbracket closebracket    (. argtype.rank++; .)
                } 
            )
        ]
    ]
        (.
            string oldName = tNode.Name;
            string oldValue = tNode.Value;

            // Here since the variable has an explicitly specified type 
            // the "IdentifierNode" should really be "TypedIdentifierNode"
            // (which is used to indicate the identifier that has explicit 
            // type specified).
            tNode = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode()
            {
                Name = oldName,
                Value = oldValue
            };

            argtype.UID = core.TypeSystem.GetType(argtype.Name);
            tNode.datatype = argtype;
            varDeclNode.NameNode = tNode;
            varDeclNode.ArgumentType = argtype;
        .)
    ]
   
                                    (. 
                                        node = varDeclNode; 
                                        //if(!isGlobalScope) {
                                        //    localVarCount++;
                                        //}
                                    .)

.

Associative_ArgDecl<out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public>    
= 
                                    (.
                                        ProtoCore.AST.AssociativeAST.IdentifierNode tNode = null; 
                                        ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = new ProtoCore.AST.AssociativeAST.VarDeclNode(); 
                                        varDeclNode.Access = access;
                                    .)

    (
        ident                       (.
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        tNode = AstFactory.BuildIdentifier(t.val);
                                        NodeUtils.SetNodeLocation(tNode, t);
                                        varDeclNode.NameNode = tNode;
                                        NodeUtils.CopyNodeLocation(varDeclNode, tNode);
                                    .)  
    )
                                        (. ProtoCore.Type argtype = new ProtoCore.Type(); argtype.Name = "var"; argtype.rank = 0; argtype.UID = 0; .)
    [                                   
        ':'
        ident                           (. argtype.Name = t.val; .)
        [                               
            openbracket closebracket    (. argtype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   (. argtype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    (. argtype.rank++; .)
                    } 
                )
            ]
        ]
    ]
                                    (.  varDeclNode.ArgumentType = argtype; .)          
                                      (. node = varDeclNode; .)
.


Associative_DefaultArgDecl<out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public>	
=
    Associative_ArgDecl<out node>    (. ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = node as ProtoCore.AST.AssociativeAST.VarDeclNode; .)
    '=' 
                                     (. ProtoCore.AST.AssociativeAST.AssociativeNode rhsNode; .)
    Associative_Expression<out rhsNode> 
                                     (.
                                        ProtoCore.AST.AssociativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
                                        NodeUtils.CopyNodeLocation(bNode, varDeclNode);
                                        bNode.LeftNode = varDeclNode.NameNode;
                                        bNode.RightNode = rhsNode;
                                        bNode.Optr = Operator.assign;
                                        varDeclNode.NameNode = bNode;
                                        .)
                                    (. node = varDeclNode; .)
.

//------------------------------------------------------------------------
Associative_TypeRestriction<out ProtoCore.Type type>
=
  ':'  Associative_ClassReference<out type> (. type.rank = 0; .)
  [                             
        openbracket closebracket    (. type.rank = 1; .)
        [
            ( ".." openbracket closebracket )   (. type.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
            |
            ( 
                {
                    openbracket closebracket    (. type.rank++; .)
                } 
            )
        ]
    ]
.

//------------------------------------------------------------------------
Associative_ClassReference<out ProtoCore.Type type>
=
                                 (. type = new ProtoCore.Type(); .)  
                                 (. string name; .)  
 ident                           (. name = t.val; .)
                                 (. type.Name = name; .)
                                 (. type.UID = 0; .)
.

//------------------------------------------------------------------------
Associative_FunctionDefinitionBody<out ProtoCore.AST.AssociativeAST.AssociativeNode funcBody>
=                                       (.
                                            ProtoCore.AST.AssociativeAST.CodeBlockNode functionBody = new ProtoCore.AST.AssociativeAST.CodeBlockNode(); 
                                            List<ProtoCore.AST.AssociativeAST.AssociativeNode> body = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); 
                                            NodeUtils.SetNodeStartLocation(functionBody, la);
                                        .)
    '{'        
                                         
            Associative_StatementList<out body>                                        
                                        (. functionBody.Body =body;  .)
    '}'                                 (. NodeUtils.SetNodeEndLocation(functionBody, t); .)
                                        (. funcBody = functionBody; .)
.

TypedIdentifierList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
(
		ident
		(. node = new IdentifierNode(t.val); .)
		
			{
				'.'
				(. ProtoCore.AST.AssociativeAST.AssociativeNode rnode = null; .)
				ident
				(. 
					rnode = new IdentifierNode(t.val);
            
					ProtoCore.AST.AssociativeAST.IdentifierListNode bnode = new ProtoCore.AST.AssociativeAST.IdentifierListNode();
					bnode.LeftNode = node;
					bnode.Optr = Operator.dot;
					bnode.RightNode = rnode;
					node = bnode;
					NodeUtils.SetNodeLocation(bnode, bnode.LeftNode, bnode.RightNode); 
				.)
			}
		
 ) 
 .   

Associative_DecoratedIdentifier<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                           (. node = null; .)
(
    (IF (IsLocallyTypedVariable())
    (
        ident           (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var typedVar = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode();
                            typedVar.Name = typedVar.Value = t.val;
                            NodeUtils.SetNodeLocation(typedVar, t);
                        .)
        ':'
            
            
        kw_local         (.
                                typedVar.IsLocal = true;
                         .)
            

        ident
                        (. 
                            int type = core.TypeSystem.GetType(t.val); 
                            if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
                            {
                                var unknownType = new ProtoCore.Type();
                                unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
                                unknownType.Name = t.val; 
                                typedVar.datatype = unknownType;
                            }
                            else
                            {
                                typedVar.datatype = core.TypeSystem.BuildTypeObject(type, 0);
                            }
                        .)

        [                               
                        (. var datatype = typedVar.datatype; .)
            openbracket closebracket    
                        (. datatype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   
                        (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    
                        (. datatype.rank++; .)
                    } 
                )
            ]
                        (. typedVar.datatype = datatype; .)
        ]

                        (.  node = typedVar; .)
        )
    )
     

    |
    (IF (IsLocalVariable())
    (      
        ident       (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var identNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
                            identNode.Name = identNode.Value = t.val;
                            NodeUtils.SetNodeLocation(identNode, t);
                        .)
        ':' 
        kw_local            (.
                                identNode.IsLocal = true;
                            .)
                            (.  node = identNode; .)
    )
    )
    
    |
    (IF (IsTypedVariable())
    (               
        ident           (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var typedVar = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode();
                            typedVar.Name = typedVar.Value = t.val;
                            NodeUtils.SetNodeLocation(typedVar, t);
                        .)
        ':'


            (. 
                string strIdent = string.Empty;
				int type = ProtoCore.DSASM.Constants.kInvalidIndex;
			.)
				
				(IF (IsIdentList())
				(
					TypedIdentifierList<out node>
										(.	strIdent = node.ToString(); .)
				)
				|
				(
					ident
							(. strIdent = t.val; .)
							
				)
				)
				(.
						type = core.TypeSystem.GetType(strIdent);
						typedVar.TypeAlias = strIdent;
						if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
						{
							var unknownType = new ProtoCore.Type();
							unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
							unknownType.Name = strIdent; 
							typedVar.datatype = unknownType;
						}
						else
						{
							typedVar.datatype = core.TypeSystem.BuildTypeObject(type, 0);
						}
				.)		
				
	

        [                               
                        (. var datatype = typedVar.datatype; .)
            openbracket closebracket    
                        (. datatype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   
                        (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    
                        (. datatype.rank++; .)
                    } 
                )
            ]
                        (. typedVar.datatype = datatype; .)
        ]

                        (.  node = typedVar; .)
        )
    )

    |
    (
        Associative_IdentifierList<out node>
    )
)
.

Associative_NonAssignmentStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  SYNC                       (.
								 node = null; 
								 ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
						     .)
(
	(
		Associative_Expression<out rightNode>
					(.
                        //Try to make a false binary expression node.					    
						ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
						ProtoCore.AST.AssociativeAST.IdentifierNode leftNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
						leftNode.Value = leftNode.Name = Constants.kTempProcLeftVar;

						var unknownType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, 0);
						leftNode.datatype = unknownType;
						leftNode.line = rightNode.line;
						leftNode.col = rightNode.col;
						leftNode.endLine = rightNode.endLine;
						leftNode.endCol = rightNode.endCol;

						expressionNode.LeftNode = leftNode;
						expressionNode.RightNode = rightNode;
						expressionNode.Optr = Operator.assign;
						NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
						node = expressionNode;
					.)			
                    
                    (. 
                        if (la.val != ";")
                            SynErr(Resources.SemiColonExpected);  
                    .)
		endline				
					(. NodeUtils.SetNodeEndLocation(node, t); .)

	)
)
.

Associative_FunctionCallStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  SYNC                       (.
								 node = null; 
								 ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
						     .)
(
	(
		Associative_Expression<out rightNode>
					(.
                        bool allowIdentList = core.Options.GenerateSSA && rightNode is ProtoCore.AST.AssociativeAST.IdentifierListNode;

						//Try to make a false binary expression node.
					    if (rightNode is ProtoCore.AST.AssociativeAST.FunctionDotCallNode 
                            || rightNode is ProtoCore.AST.AssociativeAST.FunctionCallNode
                            || allowIdentList)

							{
								ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
								ProtoCore.AST.AssociativeAST.IdentifierNode leftNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
								leftNode.Value = leftNode.Name = Constants.kTempProcLeftVar;

								var unknownType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, 0);
								leftNode.datatype = unknownType;
								leftNode.line = rightNode.line;
								leftNode.col = rightNode.col;
								leftNode.endLine = rightNode.endLine;
								leftNode.endCol = rightNode.endCol;

								expressionNode.LeftNode = leftNode;
								expressionNode.RightNode = rightNode;
								expressionNode.Optr = Operator.assign;
								NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
								node = expressionNode;
							}
					.)			
                    
                    (. 
                        if (la.val != ";")
                            SynErr(Resources.SemiColonExpected);  
                    .)
		endline				
					(. NodeUtils.SetNodeEndLocation(node, t); .)

	)
)
.


Associative_FunctionalStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node> 
=
 SYNC                       (. node = null; .)
 (
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode leftNode = null; .)
                                (. ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode(); .)
    (                           (. isLeft = true; .)
        Associative_DecoratedIdentifier<out leftNode>
                                (. 
                                   isLeft = false;
                                   NodeUtils.CopyNodeLocation(expressionNode, leftNode);
                                   node = leftNode; 
                                .)
    )
    (
        endline
                                (.
                                    // Comment Jun: Graph IDE precompile  does not require conversion to a binary expression
                                    if (core.ParsingMode != ParseMode.AllowNonAssignment)
                                    {
                                        expressionNode.LeftNode = leftNode;
                                        expressionNode.RightNode = null;
                                        expressionNode.Optr = Operator.assign;
                                        NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
                                        node = expressionNode;
                                    }
                                .)
        |
        (
            '='                 
                                (. 
                                    ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
                                    bool isLeftMostNode = false; 
                                    if (leftVar == null) 
                                    {
                                        if (node is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                        {
                                            isLeftVarIdentList = true;
                                            leftVar = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(node);
                                        }
                                        else
                                        {
                                            isLeftVarIdentList = false;
                                            leftVar = node.Name; 
                                        }
                                        isLeftMostNode = true;
                                        withinModifierCheckScope = true;
                                    } 
                                .)                            
            (
                (
                    IF(HasMoreAssignmentStatements())
                        Associative_FunctionalStatement<out rightNode>
                                (.   
                                    expressionNode.LeftNode = leftNode; 
                                    expressionNode.RightNode = rightNode; 
                                    NodeUtils.SetNodeEndLocation(expressionNode, rightNode);
                                    expressionNode.Optr = Operator.assign; 
                                    expressionNode.isMultipleAssign = true;
                                    node = expressionNode; 
                                .)    
                )
                |
                (  
                                (. 
                                    withinModifierCheckScope = false; 
                                .)
                    Associative_LanguageBlock<out rightNode>
                                (. 
                                    NodeUtils.SetNodeEndLocation(expressionNode, t);
                                    expressionNode.LeftNode = leftNode;
                                    expressionNode.RightNode = rightNode;
                                    expressionNode.Optr = Operator.assign;
                                    node = expressionNode; 
                                .)    
                )
                |
                (
                    Associative_Expression<out rightNode>
                                (.
                                    expressionNode.LeftNode = leftNode;
                                    expressionNode.RightNode = rightNode;
                                    expressionNode.Optr = Operator.assign;
                                    NodeUtils.UpdateBinaryExpressionLocation(expressionNode);

                                    if (rightNode is ProtoCore.AST.AssociativeAST.ExprListNode)
                                        expressionNode.RightNode.Name = leftVar;
                                .)			

                                (. 
                                    if (la.kind != _endline)
                                       SynErr(Resources.SemiColonExpected);
                                .)
                    endline				
                                (. NodeUtils.SetNodeEndLocation(expressionNode, t); node = expressionNode; .)
                )
            )
                                (.
                                    if (isLeftMostNode) 
                                    {
                                        leftVar = null;
                                        if (node is ProtoCore.AST.AssociativeAST.BinaryExpressionNode)
                                        {
                                            node.IsModifier = isModifier;   
                                        }
                                        isModifier = false;
                                        withinModifierCheckScope = false;
                                        isLeftVarIdentList = false;                                  
                                    }  
                                .)
        )
        |
        (
            (. SynErr(Resources.SemiColonExpected); .)
        )
    )
)
.

Associative_Expression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=               (. node = null; .)
    (
        Associative_LogicalExpression<out node>
    )
    {
        Associative_TernaryOp<ref node>
    }
.

Associative_TernaryOp<ref ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
                                            (. ProtoCore.AST.AssociativeAST.InlineConditionalNode inlineConNode = new ProtoCore.AST.AssociativeAST.InlineConditionalNode(); .)
        "?"                                 (. inlineConNode.ConditionExpression = node; node = null; .)
        Associative_Expression<out node>    (. inlineConNode.TrueExpression = node; .)
        ":"                                 (. node = null; .)
        Associative_Expression<out node>    (.
                                                inlineConNode.FalseExpression = node;
                                                node = inlineConNode;
                                                NodeUtils.SetNodeLocation(inlineConNode, inlineConNode.ConditionExpression, inlineConNode.FalseExpression);
                                            .)
.

Associative_UnaryExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
    (
        (
            Associative_NegExpression<out node>
        )
    |
        (
            Associative_BitUnaryExpression<out node>
        )
    )
.

Associative_BitUnaryExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.AssociativeAST.AssociativeNode exprNode; .)
    Associative_unaryop<out op>     
    Associative_Factor<out exprNode>    
                        (. 
                            node = GenerateUnaryOperatorMethodCallNode(op, exprNode);
                        .)
.

Associative_NegExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.AssociativeAST.AssociativeNode exprNode = null; .)
    Associative_negop<out op>
    Associative_IdentifierList <out exprNode>
                        (.  
                           node = GenerateUnaryOperatorMethodCallNode(op, exprNode);
                        .)
.

Associative_LogicalExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  Associative_ComparisonExpression<out node>
  { 
                                    (.Operator op;.)

    Associative_LogicalOp<out op> 
                                    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_ComparisonExpression<out expr2>
                                    (.	
                                        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
                                    .)
  }
.

Associative_ComparisonOp<out Operator op>
                            (. op = Operator.none; .)
= ">"                       (. op = Operator.gt; .)
| ">="                      (. op = Operator.ge; .)
| "<"                       (. op = Operator.lt; .)
| "<="                      (. op = Operator.le; .)
| "=="                      (. op = Operator.eq; .)
| "!="                      (. op = Operator.nq; .)
.

Associative_ComparisonExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
Associative_RangeExpr<out node>
{ 
                                (. Operator op; .)
    Associative_ComparisonOp<out op>
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_RangeExpr<out expr2>
                                (.	
                                   node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
                                .)
}
.

Associative_RangeExpr<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
    Associative_ArithmeticExpression<out node>
    [
                                        (.  ProtoCore.AST.AssociativeAST.RangeExprNode rnode = new ProtoCore.AST.AssociativeAST.RangeExprNode(); 
                                            rnode.From = node; NodeUtils.SetNodeStartLocation(rnode, node);
                                            bool hasRangeAmountOperator = false;
                                        .)
        rangeop
        [Associative_rangeAmountOperator<out hasRangeAmountOperator>]
                                        (. rnode.HasRangeAmountOperator = hasRangeAmountOperator; .)
        Associative_ArithmeticExpression<out node>  
                                        (. rnode.To = node; 
                                            NodeUtils.SetNodeEndLocation(rnode, node);
                                        .)
        [                               (. RangeStepOperator op; .)
            rangeop
            Associative_rangeStepOperator<out op>   
                                        (. rnode.StepOperator = op; .)
            Associative_ArithmeticExpression<out node> 
                                        (. rnode.Step = node;
                                           NodeUtils.SetNodeEndLocation(rnode, node);
                                        .)
        ]

                                        (. node = rnode; .)
    ]
.

Associative_AddOp<out Operator op>
=                   (. op = Operator.add; .)
  ( "+"
  | "-"             (. op = Operator.sub; .)
  ).


//------------------------------------------------------------------------
Associative_MulOp<out Operator op>
=                   (. op = Operator.mul; .)
  ( "*"
  | "/"             (. op = Operator.div; .)
  | "%"				(. op = Operator.mod; .)
  ).

Associative_LogicalOp<out Operator op>
=                   (. op = Operator.and; .)
( "&&"
| "||"              (. op = Operator.or; .)
)
.

Associative_negop<out UnaryOperator op>
=           (. op = UnaryOperator.None; .)
(
| '-'       (. op = UnaryOperator.Neg; .)
)
.

Associative_unaryop<out UnaryOperator op>                   
=           
    (. op = UnaryOperator.None; .)  
(	
     '!'       
        (. op = UnaryOperator.Not;    .)

        (. #if ENABLE_BIT_OP          .)
    | 
    '~'       
        (. op = UnaryOperator.Negate; .)
        (. #endif                     .)
)
.

Associative_rangeAmountOperator<out bool hasRangeAmountOperator>
= 
    (. hasRangeAmountOperator = false; .)
(
    '#' 
    (. hasRangeAmountOperator = true; .)
)
.

Associative_rangeStepOperator<out RangeStepOperator op>
=               
    (. op = RangeStepOperator.StepSize; .)
[ 
    '#'     
    (. op = RangeStepOperator.Number; .)
    | 
    '~'           
    (. op = RangeStepOperator.ApproximateSize; .)
]
.

Associative_ArithmeticExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
Associative_Term<out node>
{
    (. Operator op; .)
    Associative_AddOp<out op>
    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_Term<out expr2>
    (.	
        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
    .)
}
.

Associative_Term<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
= 
Associative_Factor<out node>
{
    (. Operator op; .)

    Associative_MulOp<out op> 
    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)   

    Associative_Factor<out expr2>

    (.	
        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
    .)
}
.

Associative_Level<out ProtoCore.AST.AssociativeAST.AssociativeNode node>               
=   (.  
        node = null; 
        int sign = 1;
    .)  
    (
        ident
        (.
            if(t.val[0] != 'L')
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }
            var level = t.val.Remove(0, 1);
            Int64 value;
            if (Int64.TryParse(level, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(-1*value);
            }
            else
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }

            NodeUtils.SetNodeLocation(node, t);
        .)
        |
        [
            '-' 
            (. 
                sign = -1; 
            .)
        ] number
        (.
            Int64 value;
            if (Int64.TryParse(t.val, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(sign*value);
            }
            else
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }

            NodeUtils.SetNodeLocation(node, t);
        .)
    )
.

Associative_Number<out ProtoCore.AST.AssociativeAST.AssociativeNode node>               
=           
    (. 
        node = null; 
        int sign = 1;
        int line = ProtoCore.DSASM.Constants.kInvalidIndex; 
        int col = ProtoCore.DSASM.Constants.kInvalidIndex; 
    .) 
    [
        '-' 
        (. 
            sign = -1; 
            line = t.line; 
            col = t.col; 
        .)
    ]
    (
        number  
        (.  
            Int64 value;
            if (Int64.TryParse(t.val, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.AssociativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex == line
                &&  ProtoCore.DSASM.Constants.kInvalidIndex == col)
            {
                NodeUtils.SetNodeLocation(node, t);
            }
            else
            {
                node.line = line; node.col = col;
				node.endLine = t.line; node.endCol = t.col;
            }
        .)
        | 
        float   
        (.  
            double value;
            if (Double.TryParse(t.val, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.DoubleNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.AssociativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex == line
                &&  ProtoCore.DSASM.Constants.kInvalidIndex == col)
            {
                NodeUtils.SetNodeLocation(node, t);
            }
            else
            {
                node.line = line; node.col = col;
            }
        .)
    )
.

Associative_Char<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=           (. node = null; .)
    char
            (. 
                if (t.val.Length <= 2) {
                    errors.SemErr(t.line, t.col, Resources.EmptyCharacterLiteral);
                }

                node = new ProtoCore.AST.AssociativeAST.CharNode() 
                { 
                    Value = t.val.Substring(1, t.val.Length - 2),
                    line = t.line,
                    col = t.col
                }; 
            .)
.

Associative_String<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=           (. node = null; .)
    textstring
            (. 
                node = new ProtoCore.AST.AssociativeAST.StringNode() 
                { 
                    Value = GetEscapedString(t.val.Length <= 2 ? "" : t.val.Substring(1, t.val.Length - 2)),
                }; 
                NodeUtils.SetNodeLocation(node, t);
            .)
.

Associative_Factor<out ProtoCore.AST.AssociativeAST.AssociativeNode node>           
                                    (.node = null; .)
=
    (
        (
            (IF(IsNumber())
                Associative_Number<out node>
            )
        )
        |
        (
            literal_true                    
            (.
                node = new ProtoCore.AST.AssociativeAST.BooleanNode(true);
                NodeUtils.SetNodeLocation(node, t);
            .)
        )
        |
        (
            literal_false                   
            (.
                node = new ProtoCore.AST.AssociativeAST.BooleanNode(false);
                NodeUtils.SetNodeLocation(node, t);
            .)
        )   
        |
        (
            literal_null                    (.
                                                node = new ProtoCore.AST.AssociativeAST.NullNode();
                                                NodeUtils.SetNodeLocation(node, t);
                                            .)
        )
        | 
        (
            Associative_Char<out node>
        )
        |
        (
            Associative_String<out node>
        )
        |
        (                                    
            Associative_IdentifierList<out node>            
        )
        |
        (
            Associative_UnaryExpression<out node>
        )
     )
 .


Associative_Ident<out ProtoCore.AST.AssociativeAST.AssociativeNode node> 
=
    ident   (. 
                if (!disableKwCheck && IsKeyWord(t.val, false, false))
                {
                    errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                }
                int ltype = (0 == String.Compare(t.val, "return")) ? (int)ProtoCore.PrimitiveType.Return : (int)ProtoCore.PrimitiveType.Var;
                if (ltype == (int)ProtoCore.PrimitiveType.Return && la.val != "=")
                {
                     SynErr(String.Format(Resources.InvalidReturnStatement, la.val));
                }
                
                var identNode = AstFactory.BuildIdentifier(t.val);
                identNode.datatype = TypeSystem.BuildPrimitiveTypeObject((ProtoCore.PrimitiveType)ltype);
                node = identNode;
                NodeUtils.SetNodeLocation(node, t);
            .)
.

Associative_ArrayExprList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
'{'                                     (. ProtoCore.AST.AssociativeAST.ExprListNode exprlist = new ProtoCore.AST.AssociativeAST.ExprListNode(); .)
                                        (. NodeUtils.SetNodeStartLocation(exprlist, t); .)
    [
                                        
        Associative_Expression<out node>            (. exprlist.Exprs.Add(node); .)
        {
            ','
            Associative_Expression<out node>        (. exprlist.Exprs.Add(node); .)
        }
                                        
    ]
'}'                                     (. NodeUtils.SetNodeEndLocation(exprlist, t); .)
                                        (. node = exprlist; .)
.

Associative_NameReference<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
= 
                                        (.
                                            ProtoCore.AST.AssociativeAST.ArrayNameNode nameNode = null; 
                                            ProtoCore.AST.AssociativeAST.GroupExpressionNode groupExprNode = null;
                                        .)
    (
        (
            '('
            Associative_Expression<out node>
                                        (.
                                            if (node is ProtoCore.AST.AssociativeAST.ArrayNameNode)
                                            {
                                                nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                            }
                                            else
                                            {
                                                groupExprNode = new ProtoCore.AST.AssociativeAST.GroupExpressionNode();
                                                groupExprNode.Expression = node;
                                                nameNode = groupExprNode;
                                            }
                                        .) 
            ')'
        )
        |
        IF(IsFunctionCall())
        (                               (.
                                            if (isLeft)
                                            {
                                               errors.SemErr(la.line, la.col, Resources.FunctionCallCannotBeAtLeftSide);
                                            } 
                                        .)
            Associative_FunctionCall<out node>  
                                        (. 
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode; 
                                        .)
        )
        |
        (
            Associative_Ident<out node>         
                                        (. 
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode; 
                                        .)
        )
        |
        (
            Associative_ArrayExprList<out node>
                                        (.
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                        .)
        )
    )

    [
                                        (. 
                                            ProtoCore.AST.AssociativeAST.ArrayNode array = new ProtoCore.AST.AssociativeAST.ArrayNode(); 
                                        .)
        openbracket             
        [
                                        (. 
                                            bool tmpIsLeft = isLeft; 
                                            isLeft = false;
                                        .)
            Associative_Expression<out node>
                                        (. 
                                            isLeft = tmpIsLeft; 
                                            array.Expr = node; 
                                            array.Type = nameNode.ArrayDimensions;
                                            NodeUtils.SetNodeLocation(array, t);
                                            nameNode.ArrayDimensions = array; 
                                            
                                        .)
        ]
        closebracket 
        { 
            openbracket
            [
                                        (. 
                                            bool tmpIsLeft = isLeft; 
                                            isLeft = false;
                                        .) 
                Associative_Expression<out node>  
                                        (. 
                                            isLeft = tmpIsLeft; 
                                            ProtoCore.AST.AssociativeAST.ArrayNode array2 = new ProtoCore.AST.AssociativeAST.ArrayNode();
                                            array2.Expr = node; 
                                            array2.Type = null;
                                            NodeUtils.SetNodeLocation(array2, t);
                                            array.Type = array2;
                                            array = array2;
                                        .)
            ]
            closebracket
        }
                                        (.
                                            if (groupExprNode != null)
                                            {
                                                var expr = groupExprNode.Expression;
                                                if (expr is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                                {
                                                    var rightNode = (expr as ProtoCore.AST.AssociativeAST.IdentifierListNode).RightNode;
                                                    if (rightNode is ProtoCore.AST.AssociativeAST.ArrayNameNode)
                                                    {
                                                        var rightMostArrayNameNode = rightNode as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                                        if (rightMostArrayNameNode.ArrayDimensions == null)
                                                        {
                                                            rightMostArrayNameNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                        }
                                                        else 
                                                        {
                                                            rightMostArrayNameNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                        }
                                                        groupExprNode.ArrayDimensions = null;
                                                    }
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.RangeExprNode)
                                                {    
                                                    var rangeExprNode = expr as ProtoCore.AST.AssociativeAST.RangeExprNode; 
                                                    if (rangeExprNode.ArrayDimensions == null)
                                                    {
                                                        rangeExprNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                    }
                                                    else 
                                                    {
                                                        rangeExprNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.ExprListNode)
                                                {    
                                                    var exprListNode = expr as ProtoCore.AST.AssociativeAST.ExprListNode; 
                                                    if (exprListNode.ArrayDimensions == null)
                                                    {
                                                        exprListNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                    }
                                                    else 
                                                    {
                                                        exprListNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.FunctionDotCallNode)
                                                {
                                                    var dotCall = expr as ProtoCore.AST.AssociativeAST.FunctionDotCallNode;
                                                    var arrayExpr = (dotCall.Arguments[2] as ProtoCore.AST.AssociativeAST.ExprListNode);
                                                    var dimCount = (dotCall.Arguments[3] as ProtoCore.AST.AssociativeAST.IntNode);

                                                    var dims = dimCount.Value;
                                                    var newdims = dims;

                                                    if (arrayExpr != null)
                                                    {
                                                        var newarray = groupExprNode.ArrayDimensions;
                                                        while (newarray != null)
                                                        {
                                                            arrayExpr.Exprs.Add(newarray.Expr);
                                                            newdims++;
                                                            newarray = (newarray.Type as ProtoCore.AST.AssociativeAST.ArrayNode);
                                                        }
                                                        
                                                        (dotCall.Arguments[3] as ProtoCore.AST.AssociativeAST.IntNode).Value = newdims;
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                            }
                                        .)
    ]
    
    [
                                        (. 
                                           AssociativeNode levelNode = null;
                                           bool isDominant = false;
                                        .)
        (
            list_at Associative_Level<out levelNode> 
            |
            dominant_list_at Associative_Level<out levelNode> (. isDominant = true; .)
        )
                                        (. 
                                            IntNode listAtLevel = levelNode as IntNode;
                                            if (listAtLevel != null)
                                            {
                                                var atLevel = new AtLevelNode { Level = listAtLevel.Value, IsDominant = isDominant };
                                                nameNode.AtLevel = atLevel; 
                                            }
                                        .)
    ]

    [ 
        IF(IsReplicationGuide())
        (
                                            (. var guides = new List<AssociativeNode>();.)
            lessthan
                                            (.
                                                string repguide = String.Empty;
                                                bool isLongest = false;
                                                ReplicationGuideNode repGuideNode = null;
                                            .)
       
            (IF(IsPostfixedReplicationGuide())
            (
                postfixed_replicationguide      (.  isLongest = true; .)
                )
                |
                (
                    number                      (.  isLongest = false; .)
                )
            )
                                                (.
                                                    repguide = t.val;
                                                    if (isLongest)
                                                    {
                                                        repguide = repguide.Remove(repguide.Length - 1);
                                                    }
                                                    var numNode = new IdentifierNode() { Value = repguide };
                                                    repGuideNode = new ReplicationGuideNode();
                                                    repGuideNode.RepGuide = numNode;
                                                    repGuideNode.IsLongest = isLongest;
                                                    NodeUtils.SetNodeLocation(numNode, t); 
                                                .)
            greaterthan                         (. guides.Add(repGuideNode); .)
            {                   
                lessthan
                (IF(IsPostfixedReplicationGuide())
                    (
                        postfixed_replicationguide  (.  isLongest = true; .)
                    )
                    |
                    (
                        number                      (.  isLongest = false; .)
                    )
                )
                                            (.
                                                    repguide = t.val;
                                                    if (isLongest)
                                                    {
                                                        repguide = repguide.Remove(repguide.Length - 1);
                                                    }
                                                    numNode = AstFactory.BuildIdentifier(repguide);
                                                    repGuideNode = new ReplicationGuideNode();
                                                    repGuideNode.RepGuide = numNode;
                                                    repGuideNode.IsLongest = isLongest;
                                                    NodeUtils.SetNodeLocation(numNode, t); 
                                            .)
                greaterthan                 (.  guides.Add(repGuideNode); .)
            }
                                            (. 
                                                nameNode.ReplicationGuides = guides; 
                                                if (groupExprNode != null)
                                                {
                                                    var expr = groupExprNode.Expression;
                                                    if (expr is IdentifierListNode)
                                                    {
                                                        var rightNode = (expr as IdentifierListNode).RightNode;
                                                        if (rightNode is ArrayNameNode)
                                                        {
                                                            var rightMostArrayNameNode = rightNode as ArrayNameNode;
                                                            if (rightMostArrayNameNode.ReplicationGuides == null)
                                                            {
                                                                rightMostArrayNameNode.ReplicationGuides = guides;
                                                            }
                                                            else
                                                            {
                                                                rightMostArrayNameNode.ReplicationGuides.InsertRange(0, guides);
                                                            }
                                                            groupExprNode.ReplicationGuides = null;
                                                        }
                                                    }
                                                    else if (expr is FunctionDotCallNode)
                                                    {
                                                        var functionCall = (expr as FunctionDotCallNode).FunctionCall;
                                                        var function = (functionCall.Function as ArrayNameNode);
                                                        if (function.ReplicationGuides == null)
                                                        {
                                                            function.ReplicationGuides = guides;
                                                        }
                                                        else
                                                        {
                                                            function.ReplicationGuides.InsertRange(0, guides);
                                                        }
                                                        groupExprNode.ReplicationGuides = null;
                                                    }
                                                }
                                            .)
        )
    ]
                                        (. 
                                            if (groupExprNode != null && groupExprNode.ArrayDimensions == null && (groupExprNode.ReplicationGuides == null || groupExprNode.ReplicationGuides.Count == 0))
                                            {
                                                node = groupExprNode.Expression;
                                            }
                                            else
                                            {
                                                node = nameNode; 
                                            }
                                        .)
.

Associative_IdentifierList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                                   (. 
                                        node = null;
                                        if (isInClass && IsIdentList())
                                        {
                                            disableKwCheck = true;
                                        }
                                    .)

    Associative_NameReference<out node> 
                                    (. 
                                        disableKwCheck = false; 
                                        ProtoCore.AST.AssociativeAST.AssociativeNode inode = node; 
                                    .)
    {
        '.'
                                    (. ProtoCore.AST.AssociativeAST.AssociativeNode rnode = null; .)

        Associative_NameReference<out rnode>
                                    (.
                                        if ((inode is ProtoCore.AST.AssociativeAST.IdentifierNode) &&
                                            (inode as ProtoCore.AST.AssociativeAST.IdentifierNode).Name == ProtoCore.DSDefinitions.Keyword.This &&
                                            (rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode))
                                        {
                                            node = rnode;
                                            return;
                                        }

                                        
                                        ProtoCore.AST.AssociativeAST.IdentifierListNode bnode = new ProtoCore.AST.AssociativeAST.IdentifierListNode();
                                        bnode.LeftNode = node;
                                        bnode.Optr = Operator.dot;
                                        bnode.RightNode = rnode;
                                        node = bnode;
                                        NodeUtils.SetNodeLocation(bnode, bnode.LeftNode, bnode.RightNode);
                                        
                                        if (!core.Options.GenerateSSA)
                                        {
                                        bool isNeitherIdentOrFunctionCall = !(rnode is ProtoCore.AST.AssociativeAST.IdentifierNode || rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode);
                                        if (isLeft || isNeitherIdentOrFunctionCall)
                                        {
                                            node = inode;
                                        }
                                        else 
                                        {
                                            if (rnode is ProtoCore.AST.AssociativeAST.IdentifierNode)
                                            {
                                                ProtoCore.AST.AssociativeAST.FunctionCallNode rcall = new ProtoCore.AST.AssociativeAST.FunctionCallNode();
                                                rcall.Function = rnode;
                                                rcall.Function.Name = ProtoCore.DSASM.Constants.kGetterPrefix + rcall.Function.Name;
                                                bnode.RightNode = rcall;

                                                NodeUtils.SetNodeLocation(rcall, rnode, rnode);
                                                node = ProtoCore.Utils.CoreUtils.GenerateCallDotNode(bnode.LeftNode, rcall, core);
                                            }
                                            else
                                            {
                                                string rhsName = null;
                                                ProtoCore.AST.AssociativeAST.ExprListNode dimList = null;
                                                int dim = 0;
                                                if (rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode)
                                                {
                                                    ProtoCore.AST.AssociativeAST.FunctionCallNode rhsFNode = rnode as ProtoCore.AST.AssociativeAST.FunctionCallNode;
                                                    node = ProtoCore.Utils.CoreUtils.GenerateCallDotNode(node, rhsFNode, core);
                                                }
                                            }
                                        }
        }
                                    .)
    }

                                    (.  
                                        //if (!core.Options.GenerateSSA)
                                        {
                                            if (!isModifier && withinModifierCheckScope)
                                            {
                                                if (isLeftVarIdentList)
                                                {
                                                    if (inode is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                                    {
                                                        isModifier = false;
                                                        if (node is ProtoCore.AST.AssociativeAST.FunctionDotCallNode)
                                                        {
                                                            ProtoCore.AST.AssociativeAST.FunctionDotCallNode fdotCall = node as ProtoCore.AST.AssociativeAST.FunctionDotCallNode;
                                                            string checkVar = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(fdotCall.GetIdentList());
                                                            isModifier = (leftVar == checkVar);
                                                        }
                                                    }
                                                }
                                                else if (inode is ProtoCore.AST.AssociativeAST.IdentifierNode)
                                                {
                                                    isModifier = (leftVar == inode.Name);
                                                }   

                                                // The LHS is an identifier
                                                else
                                                {
                                                    // It is a modifier if the lhs is:
                                                    //   1. the same as the current node
                                                    //   2. the current node starts with the lhs identifier
                                                    isModifier = (leftVar == inode.Name);
                                                    if (!isModifier)
                                                    {
                                                        string rhsString = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(inode);

                                                        isModifier = rhsString.StartsWith(leftVar);
                                                    }
                                                }
                                            }
                                        }
                                    .)
.



Associative_FunctionCall<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                                   (. ProtoCore.AST.AssociativeAST.FunctionCallNode f = new ProtoCore.AST.AssociativeAST.FunctionCallNode(); .)
    Associative_Ident<out node>     (. NodeUtils.SetNodeStartLocation(f, t); .)
                                    (. List<ProtoCore.AST.AssociativeAST.AssociativeNode> args = null; .)
    Associative_Arguments<out args> (.                                      
                                        f.FormalArguments = args;
                                        f.Function = node;
                                        NodeUtils.SetNodeEndLocation(f, t);
                                        node = f; 
                                    .)
.


Associative_Arguments<.out List<ProtoCore.AST.AssociativeAST.AssociativeNode> nodes.>
=                                           
    '('										(. if (!IsFullClosure()) SynErr(Resources.CloseBracketExpected); .)
                                            (. nodes = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); .)
        [
                                            (. ProtoCore.AST.AssociativeAST.AssociativeNode t; .)
            Associative_Expression<out t>               (. nodes.Add(t); .)
            {
                WEAK ','                            
                Associative_Expression<out t>           (. nodes.Add(t); .)                         
            }
        ]
                        
    ')'
.  
