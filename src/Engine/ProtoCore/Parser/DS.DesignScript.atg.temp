
COMPILER DesignScriptParser

    public Node root { get; set; }
    public CodeBlockNode commentNode { get; set; }
    public ProtoFFI.ImportModuleHandler ImportModuleHandler { get; set; }
    
    //used for isModifier check
    private string leftVar { get; set; }
    private bool isModifier = false;
    private bool withinModifierCheckScope = false;
    private bool isLeftVarIdentList = false;
    //end

    private int localVarCount = 0;
    private bool isGlobalScope = true;

    private bool isInClass = false;
    private bool disableKwCheck = false;

    private bool isLeft = false; // check if it is left hand side of the assignment expression

    // This is used by GraphIDE mode parsing when determining how many statements the parser has processed
    private int stmtsParsed = 0;


    private string GetEscapedString(string s)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();

        int i = 0;
        while (i < s.Length)
        {
            if (s[i] == '\\' && (i + 1) < s.Length)
            {
                i = i + 1;
                switch (s[i])
                {
                    case '\\':
                        sb.Append('\\');
                        break;
                    case '"':
                        sb.Append('"');
                        break;
                    case 'a':
                        sb.Append('\a');
                        break;
                    case 'b':
                        sb.Append('\b');
                        break;
                    case 'f':
                        sb.Append('\f');
                        break;
                    case 'n':
                        sb.Append('\n');
                        break;
                    case 'r':
                        sb.Append('\r');
                        break;
                    case 't':
                        sb.Append('\t');
                        break;
                    case 'v':
                        sb.Append('\v');
                        break;
                    case '0':
                        sb.Append('\0');
                        break;
                    default:
                        i = i - 1;
                        sb.Append(s[i]);
                        break;
                }
            }
			else if (s[i] == '\\' && i == s.Length - 1) {
                 SynErr(Resources.EOF_expected);
                }
            else
            {
                sb.Append(s[i]);
            }
            i = i + 1;
        }
        return sb.ToString();
    }

    private bool IsIdentList()
    {
        Token pt = la;
        if (_ident == pt.kind)
        {
            pt = scanner.Peek();
            if ("." == pt.val)
            {
                pt = scanner.Peek();
                scanner.ResetPeek();
                if (_ident == pt.kind)
                    return true;
            }
        }
        scanner.ResetPeek();
        return false;
    }

	// Recognize: 
    //     { "foo" :   
    // OR   
    //     { foo :
    private bool IsDictionaryExpression()
    {
        short state = 0;
        Token pt = la;
        while (pt.kind != _EOF)
        {
            switch (state)
            {
                case 0:
                    if (pt.val == "{")
                    {
                        state = 1;
                        pt = scanner.Peek();
                        continue;
                    }
                    goto fail;
                case 1:
                    if (pt.kind == _textstring || pt.kind ==_ident)
                    {
                        state = 2;
                        pt = scanner.Peek();
                        continue;
                    }
                    goto fail;
                case 2:
                    if (pt.val == ":")
                    {
                        scanner.ResetPeek();
                        return true;
                    }
                    goto fail;
            }
        }

        fail:
        scanner.ResetPeek();
        return false;
    }

    private bool IsFunctionCall()
    {
        Token pt = la;
        if( _ident == pt.kind ) 
        {
            pt = scanner.Peek();
            scanner.ResetPeek();
            if( _openparen == pt.kind ) {
                return true;
            }
        }
        scanner.ResetPeek();
        return false;
    }

	private bool IsFunctionCallStatement()
	{
        Token pt = la;
        while (pt.kind != _EOF)
        {
			if( _ident == pt.kind ) 
			{
				pt = scanner.Peek();
				if( _openparen == pt.kind )
				{
					scanner.ResetPeek();
					return true;
				}
				else if( _period == pt.kind )
				{
					pt = scanner.Peek();
					continue;
				}
			}
			else
			{
				break;
			}			
		}

        scanner.ResetPeek();
        return false;
	}

	private bool IsNonAssignmentStatement()
    {
		if (core.ParsingMode != ParseMode.AllowNonAssignment)
            return false;

		if (IsTypedVariable())
            return false;

        Token pt = la;
        while (pt.kind != _EOF)
        {
            if (pt.val == ";" && la.val == ";")
            {
                scanner.ResetPeek();
                return false;
            }
            else if (pt.val == "=")
            {
                scanner.ResetPeek();
                return false;
            }
			else if (pt.val == ";")
                break;

            pt = scanner.Peek();
        }

        scanner.ResetPeek();
        return true;
    }

    private bool IsAssignmentStatement()
    {
        Token pt = la;
        while (pt.kind != _EOF)
        {
            if (pt.val == ";")
            {
                scanner.ResetPeek();
                return false;
            }
            else if (pt.val == "=")
            {
                scanner.ResetPeek();
                return true;
            }

            pt = scanner.Peek();
        }

        scanner.ResetPeek();
        return false;
    }

    private bool IsVariableDeclaration()
    {
        Token t = la;
        if (_ident == t.kind) {
            t = scanner.Peek();
            if (":" == t.val) {
                t = scanner.Peek();
                if (_ident == t.kind) {
                    t = scanner.Peek();
                    scanner.ResetPeek();
                    return (_endline == t.kind || "[" == t.val);
                }
                scanner.ResetPeek();
                return false;
            }
            else if (_endline == t.kind) {
                scanner.ResetPeek();
                return true;
            }

            scanner.ResetPeek();
            return false;
        }
        return false;
    }
   
    private bool IsReplicationGuide()
    {
        bool isRepGuide = false;
        Token pt = la;
        if (_lessthan == pt.kind)
        {
            pt = scanner.Peek();
            if (_number == pt.kind || _postfixed_replicationguide == pt.kind)
            {
                pt = scanner.Peek();
                if (_greaterthan == pt.kind)
                {
                    isRepGuide = true;
                }
            }

        }
        scanner.ResetPeek();
        return isRepGuide;
    }

    private bool IsPostfixedReplicationGuide()
    {
        bool isPostFixedRepGuide = false;
        Token pt = la;
        if (_postfixed_replicationguide == pt.kind)
        {
            pt = scanner.Peek();
            if (_greaterthan == pt.kind)
            {
                isPostFixedRepGuide = true;
            }
        }

        scanner.ResetPeek();
        return isPostFixedRepGuide;
    }

    private bool IsNumber()
    {
        Token pt = la;

        if (pt.val == "-") {
            pt = scanner.Peek();
            scanner.ResetPeek();
        }

        return ((_number == pt.kind) || (_float == pt.kind));
    }

    private bool IsLocalVariable()
    {
        Token pt = la;
        bool isLocal = false;

        if (_ident == pt.kind) 
        {
            pt = scanner.Peek();
            if (":" == pt.val)
            { 
                pt = scanner.Peek();
                if (_kw_local == pt.kind) 
                {
                    isLocal = true;
                }
            }
        }
        scanner.ResetPeek();
        return isLocal;
    }

    private bool IsTypedVariable()
    {
        Token pt = la;
        bool isTyped = false;

        if (_ident == pt.kind) 
        {
            pt = scanner.Peek();
            if (":" == pt.val)
            { 
                pt = scanner.Peek();
                if (_ident == pt.kind) 
                {
                    isTyped = true;
                }
            }
        }
        scanner.ResetPeek();
        return isTyped;
    }

    private bool IsLocallyTypedVariable()
    {
        Token pt = la;
        bool isLocallyTyped = false;

        if (_ident == pt.kind) 
        {
            pt = scanner.Peek();
            if (":" == pt.val)
            { 
                pt = scanner.Peek();
                if (_kw_local == pt.kind) 
                {
                    pt = scanner.Peek();
                    if (_ident == pt.kind) 
                    {
                        isLocallyTyped = true;
                    }
                }
            }
        }
        scanner.ResetPeek();
        return isLocallyTyped;
    }
	
	private bool IsFullClosure()
    {
        Token pt = la;
        int closureCount = 0;

        while (true)
        {
            pt = scanner.Peek();
            if (pt.val == "(") { closureCount++; continue; }
            if (pt.val == ")") { closureCount--; continue; }
			if ((pt.kind == 0)||(pt.kind == _endline)) break;
		}
        scanner.ResetPeek();
        return (closureCount > 0) ? false : true;
    }

    private bool HasMoreAssignmentStatements()
    {
        Token pt = la;

        if (pt.kind != _ident)
            return false;

        bool gotAssignmentToken = false;
        bool isAssignmentStatement = false;

        while (true) {
            pt = scanner.Peek();
            if (pt.kind == 0) {
                break;
            }
            else if (pt.val == "=") {
                isAssignmentStatement = true;
                break;
            }
            else if (pt.kind == _endline) {
                isAssignmentStatement = gotAssignmentToken;
                break;
            }
            else if (pt.val == "{")
                break;
        }

        scanner.ResetPeek();
        return isAssignmentStatement;
    }

    private bool NotDefaultArg()
    {
        Token pt = la;          
        if (pt.val == ",")
            pt = scanner.Peek();
        //pt should be ident now
        if (pt.kind == _ident)
        {         
            pt = scanner.Peek();    //':'
            if (pt.val == ":")
            {
                pt = scanner.Peek();    //type
                if (pt.kind == _ident)
                {
                    pt = scanner.Peek();
                    scanner.ResetPeek();
                    if (pt.val == "=")
                         return false;
                }
            }
			if (pt.val == "=")
			{
				scanner.ResetPeek();
				return false;
			}
        }
        scanner.ResetPeek();        
        return true;    
    }

    private AssociativeNode GenerateBinaryOperatorMethodCallNode(Operator op, ProtoCore.AST.AssociativeAST.AssociativeNode op1, ProtoCore.AST.AssociativeAST.AssociativeNode op2)
    {
        FunctionCallNode funCallNode = new FunctionCallNode();
        IdentifierNode funcName = new IdentifierNode { Value = ProtoCore.DSASM.Op.GetOpFunction(op), Name = ProtoCore.DSASM.Op.GetOpFunction(op) };
        funCallNode.Function = funcName;
        funCallNode.Name = ProtoCore.DSASM.Op.GetOpFunction(op);
        funCallNode.FormalArguments.Add(op1); funCallNode.FormalArguments.Add(op2);

        NodeUtils.SetNodeLocation(funCallNode, op1, op2);
        return funCallNode;
    }

 	private AssociativeNode GenerateUnaryOperatorMethodCallNode(UnaryOperator op, ProtoCore.AST.AssociativeAST.AssociativeNode operand)
    {
        FunctionCallNode funCallNode = new FunctionCallNode();
        IdentifierNode funcName = new IdentifierNode { Value = ProtoCore.DSASM.Op.GetUnaryOpFunction(op), Name = ProtoCore.DSASM.Op.GetUnaryOpFunction(op) };
        funCallNode.Function = funcName;
        funCallNode.Name = ProtoCore.DSASM.Op.GetUnaryOpFunction(op);
        funCallNode.FormalArguments.Add(operand);

        NodeUtils.CopyNodeLocation(funCallNode, operand);
        return funCallNode;
    }

    public static AST.ImperativeAST.IdentifierNode BuildImperativeIdentifier(string name, ProtoCore.PrimitiveType type = ProtoCore.PrimitiveType.Var)
    {
        var ident = new AST.ImperativeAST.IdentifierNode();
        ident.Name = ident.Value = name;
        ident.DataType = TypeSystem.BuildPrimitiveTypeObject(type, 0);
        return ident;
    }

    private bool IsKeyWord(string identName, bool checkReturn = false, bool checkThis = true)
    {
        if (identName == ProtoCore.DSDefinitions.Keyword.Return && !checkReturn)
        {
            return false;
        }

        if (checkThis && identName == ProtoCore.DSDefinitions.Keyword.This)
        {
            return true;
        }

        foreach (string kw in ProtoCore.DSDefinitions.Keyword.KeywordList)
        {
            if (kw == identName)
                return true;
        }
        return false;
    }

	 // use by associative
	 private bool IsNotAttributeFunctionClass()
	 {
		if (la.val == "[")
		{
		    Token t = scanner.Peek();
            while (t.val != "]" && t.kind != _EOF)
            {
                t = scanner.Peek();
            }
          
            if (t.val == "]")
            {
                Token next = scanner.Peek(); 
                scanner.ResetPeek();
                return (next.val == "{");
            }
            else
            {
                scanner.ResetPeek();
                return false;
            }
		}

		if (la.kind != _kw_class && la.kind != _kw_def)
			return true;
		return false;
	 }

	 // used by imperative
	 private bool IsNotAttributeFunction()
	 {
	    if (la.val == "[")
		{
		    Token t = scanner.Peek();
            while (t.val != "]" && t.kind != _EOF)
            {
                t = scanner.Peek();
               
            }
          
            if (t.val == "]")
            {
                Token next = scanner.Peek(); 
                scanner.ResetPeek();
                return (next.val == "{");
            }
            else
            {
                scanner.ResetPeek();
                return false;
            }
		}

        return la.kind != _kw_def;
	 }

	 
	 //Experiment for user-defined synErr message
	 private void SynErr (string s) {
		if (errDist >= minErrDist) 
		core.BuildStatus.LogSyntaxError(s, core.CurrentDSFileName, la.line, la.col);
		errors.count++;
		errDist = 0;
	 }


CHARACTERS

    unicodeIdentifierStart = '_' + 'a'..'z' + 'A'..'Z' + '\u00aa'+'\u00b5'+'\u00ba'+'\u00c0'..'\u00d6'+'\u00d8'..'\u00f6'+'\u00f8'..'\u02c1'+'\u02c6'..'\u02d1'+'\u02e0'..'\u02e4'+'\u02ec'+'\u02ee'+'\u0370'..'\u0374'+'\u0376'+'\u0377'+'\u037a'..'\u037d'+'\u0386'+'\u0388'..'\u038a'+'\u038c'+'\u038e'..'\u03a1'+'\u03a3'..'\u03f5'+'\u03f7'..'\u0481'+'\u048a'..'\u0527'+'\u0531'..'\u0556'+'\u0559'+'\u0561'..'\u0587'+'\u05d0'..'\u05ea'+'\u05f0'..'\u05f2'+'\u0620'..'\u064a'+'\u066e'+'\u066f'+'\u0671'..'\u06d3'+'\u06d5'+'\u06e5'+'\u06e6'+'\u06ee'+'\u06ef'+'\u06fa'..'\u06fc'+'\u06ff'+'\u0710'+'\u0712'..'\u072f'+'\u074d'..'\u07a5'+'\u07b1'+'\u07ca'..'\u07ea'+'\u07f4'+'\u07f5'+'\u07fa'+'\u0800'..'\u0815'+'\u081a'+'\u0824'+'\u0828'+'\u0840'..'\u0858'+'\u08a0'+'\u08a2'..'\u08ac'+'\u0904'..'\u0939'+'\u093d'+'\u0950'+'\u0958'..'\u0961'+'\u0971'..'\u0977'+'\u0979'..'\u097f'+'\u0985'..'\u098c'+'\u098f'+'\u0990'+'\u0993'..'\u09a8'+'\u09aa'..'\u09b0'+'\u09b2'+'\u09b6'..'\u09b9'+'\u09bd'+'\u09ce'+'\u09dc'+'\u09dd'+'\u09df'..'\u09e1'+'\u09f0'+'\u09f1'+'\u0a05'..'\u0a0a'+'\u0a0f'+'\u0a10'+'\u0a13'..'\u0a28'+'\u0a2a'..'\u0a30'+'\u0a32'+'\u0a33'+'\u0a35'+'\u0a36'+'\u0a38'+'\u0a39'+'\u0a59'..'\u0a5c'+'\u0a5e'+'\u0a72'..'\u0a74'+'\u0a85'..'\u0a8d'+'\u0a8f'..'\u0a91'+'\u0a93'..'\u0aa8'+'\u0aaa'..'\u0ab0'+'\u0ab2'+'\u0ab3'+'\u0ab5'..'\u0ab9'+'\u0abd'+'\u0ad0'+'\u0ae0'+'\u0ae1'+'\u0b05'..'\u0b0c'+'\u0b0f'+'\u0b10'+'\u0b13'..'\u0b28'+'\u0b2a'..'\u0b30'+'\u0b32'+'\u0b33'+'\u0b35'..'\u0b39'+'\u0b3d'+'\u0b5c'+'\u0b5d'+'\u0b5f'..'\u0b61'+'\u0b71'+'\u0b83'+'\u0b85'..'\u0b8a'+'\u0b8e'..'\u0b90'+'\u0b92'..'\u0b95'+'\u0b99'+'\u0b9a'+'\u0b9c'+'\u0b9e'+'\u0b9f'+'\u0ba3'+'\u0ba4'+'\u0ba8'..'\u0baa'+'\u0bae'..'\u0bb9'+'\u0bd0'+'\u0c05'..'\u0c0c'+'\u0c0e'..'\u0c10'+'\u0c12'..'\u0c28'+'\u0c2a'..'\u0c33'+'\u0c35'..'\u0c39'+'\u0c3d'+'\u0c58'+'\u0c59'+'\u0c60'+'\u0c61'+'\u0c85'..'\u0c8c'+'\u0c8e'..'\u0c90'+'\u0c92'..'\u0ca8'+'\u0caa'..'\u0cb3'+'\u0cb5'..'\u0cb9'+'\u0cbd'+'\u0cde'+'\u0ce0'+'\u0ce1'+'\u0cf1'+'\u0cf2'+'\u0d05'..'\u0d0c'+'\u0d0e'..'\u0d10'+'\u0d12'..'\u0d3a'+'\u0d3d'+'\u0d4e'+'\u0d60'+'\u0d61'+'\u0d7a'..'\u0d7f'+'\u0d85'..'\u0d96'+'\u0d9a'..'\u0db1'+'\u0db3'..'\u0dbb'+'\u0dbd'+'\u0dc0'..'\u0dc6'+'\u0e01'..'\u0e30'+'\u0e32'+'\u0e33'+'\u0e40'..'\u0e46'+'\u0e81'+'\u0e82'+'\u0e84'+'\u0e87'+'\u0e88'+'\u0e8a'+'\u0e8d'+'\u0e94'..'\u0e97'+'\u0e99'..'\u0e9f'+'\u0ea1'..'\u0ea3'+'\u0ea5'+'\u0ea7'+'\u0eaa'+'\u0eab'+'\u0ead'..'\u0eb0'+'\u0eb2'+'\u0eb3'+'\u0ebd'+'\u0ec0'..'\u0ec4'+'\u0ec6'+'\u0edc'..'\u0edf'+'\u0f00'+'\u0f40'..'\u0f47'+'\u0f49'..'\u0f6c'+'\u0f88'..'\u0f8c'+'\u1000'..'\u102a'+'\u103f'+'\u1050'..'\u1055'+'\u105a'..'\u105d'+'\u1061'+'\u1065'+'\u1066'+'\u106e'..'\u1070'+'\u1075'..'\u1081'+'\u108e'+'\u10a0'..'\u10c5'+'\u10c7'+'\u10cd'+'\u10d0'..'\u10fa'+'\u10fc'..'\u1248'+'\u124a'..'\u124d'+'\u1250'..'\u1256'+'\u1258'+'\u125a'..'\u125d'+'\u1260'..'\u1288'+'\u128a'..'\u128d'+'\u1290'..'\u12b0'+'\u12b2'..'\u12b5'+'\u12b8'..'\u12be'+'\u12c0'+'\u12c2'..'\u12c5'+'\u12c8'..'\u12d6'+'\u12d8'..'\u1310'+'\u1312'..'\u1315'+'\u1318'..'\u135a'+'\u1380'..'\u138f'+'\u13a0'..'\u13f4'+'\u1401'..'\u166c'+'\u166f'..'\u167f'+'\u1681'..'\u169a'+'\u16a0'..'\u16ea'+'\u16ee'..'\u16f0'+'\u1700'..'\u170c'+'\u170e'..'\u1711'+'\u1720'..'\u1731'+'\u1740'..'\u1751'+'\u1760'..'\u176c'+'\u176e'..'\u1770'+'\u1780'..'\u17b3'+'\u17d7'+'\u17dc'+'\u1820'..'\u1877'+'\u1880'..'\u18a8'+'\u18aa'+'\u18b0'..'\u18f5'+'\u1900'..'\u191c'+'\u1950'..'\u196d'+'\u1970'..'\u1974'+'\u1980'..'\u19ab'+'\u19c1'..'\u19c7'+'\u1a00'..'\u1a16'+'\u1a20'..'\u1a54'+'\u1aa7'+'\u1b05'..'\u1b33'+'\u1b45'..'\u1b4b'+'\u1b83'..'\u1ba0'+'\u1bae'+'\u1baf'+'\u1bba'..'\u1be5'+'\u1c00'..'\u1c23'+'\u1c4d'..'\u1c4f'+'\u1c5a'..'\u1c7d'+'\u1ce9'..'\u1cec'+'\u1cee'..'\u1cf1'+'\u1cf5'+'\u1cf6'+'\u1d00'..'\u1dbf'+'\u1e00'..'\u1f15'+'\u1f18'..'\u1f1d'+'\u1f20'..'\u1f45'+'\u1f48'..'\u1f4d'+'\u1f50'..'\u1f57'+'\u1f59'+'\u1f5b'+'\u1f5d'+'\u1f5f'..'\u1f7d'+'\u1f80'..'\u1fb4'+'\u1fb6'..'\u1fbc'+'\u1fbe'+'\u1fc2'..'\u1fc4'+'\u1fc6'..'\u1fcc'+'\u1fd0'..'\u1fd3'+'\u1fd6'..'\u1fdb'+'\u1fe0'..'\u1fec'+'\u1ff2'..'\u1ff4'+'\u1ff6'..'\u1ffc'+'\u2071'+'\u207f'+'\u2090'..'\u209c'+'\u2102'+'\u2107'+'\u210a'..'\u2113'+'\u2115'+'\u2119'..'\u211d'+'\u2124'+'\u2126'+'\u2128'+'\u212a'..'\u212d'+'\u212f'..'\u2139'+'\u213c'..'\u213f'+'\u2145'..'\u2149'+'\u214e'+'\u2160'..'\u2188'+'\u2c00'..'\u2c2e'+'\u2c30'..'\u2c5e'+'\u2c60'..'\u2ce4'+'\u2ceb'..'\u2cee'+'\u2cf2'+'\u2cf3'+'\u2d00'..'\u2d25'+'\u2d27'+'\u2d2d'+'\u2d30'..'\u2d67'+'\u2d6f'+'\u2d80'..'\u2d96'+'\u2da0'..'\u2da6'+'\u2da8'..'\u2dae'+'\u2db0'..'\u2db6'+'\u2db8'..'\u2dbe'+'\u2dc0'..'\u2dc6'+'\u2dc8'..'\u2dce'+'\u2dd0'..'\u2dd6'+'\u2dd8'..'\u2dde'+'\u2e2f'+'\u3005'..'\u3007'+'\u3021'..'\u3029'+'\u3031'..'\u3035'+'\u3038'..'\u303c'+'\u3041'..'\u3096'+'\u309d'..'\u309f'+'\u30a1'..'\u30fa'+'\u30fc'..'\u30ff'+'\u3105'..'\u312d'+'\u3131'..'\u318e'+'\u31a0'..'\u31ba'+'\u31f0'..'\u31ff'+'\u3400'..'\u4db5'+'\u4e00'..'\u9fcc'+'\ua000'..'\ua48c'+'\ua4d0'..'\ua4fd'+'\ua500'..'\ua60c'+'\ua610'..'\ua61f'+'\ua62a'+'\ua62b'+'\ua640'..'\ua66e'+'\ua67f'..'\ua697'+'\ua6a0'..'\ua6ef'+'\ua717'..'\ua71f'+'\ua722'..'\ua788'+'\ua78b'..'\ua78e'+'\ua790'..'\ua793'+'\ua7a0'..'\ua7aa'+'\ua7f8'..'\ua801'+'\ua803'..'\ua805'+'\ua807'..'\ua80a'+'\ua80c'..'\ua822'+'\ua840'..'\ua873'+'\ua882'..'\ua8b3'+'\ua8f2'..'\ua8f7'+'\ua8fb'+'\ua90a'..'\ua925'+'\ua930'..'\ua946'+'\ua960'..'\ua97c'+'\ua984'..'\ua9b2'+'\ua9cf'+'\uaa00'..'\uaa28'+'\uaa40'..'\uaa42'+'\uaa44'..'\uaa4b'+'\uaa60'..'\uaa76'+'\uaa7a'+'\uaa80'..'\uaaaf'+'\uaab1'+'\uaab5'+'\uaab6'+'\uaab9'..'\uaabd'+'\uaac0'+'\uaac2'+'\uaadb'..'\uaadd'+'\uaae0'..'\uaaea'+'\uaaf2'..'\uaaf4'+'\uab01'..'\uab06'+'\uab09'..'\uab0e'+'\uab11'..'\uab16'+'\uab20'..'\uab26'+'\uab28'..'\uab2e'+'\uabc0'..'\uabe2'+'\uac00'..'\ud7a3'+'\ud7b0'..'\ud7c6'+'\ud7cb'..'\ud7fb'+'\uf900'..'\ufa6d'+'\ufa70'..'\ufad9'+'\ufb00'..'\ufb06'+'\ufb13'..'\ufb17'+'\ufb1d'+'\ufb1f'..'\ufb28'+'\ufb2a'..'\ufb36'+'\ufb38'..'\ufb3c'+'\ufb3e'+'\ufb40'+'\ufb41'+'\ufb43'+'\ufb44'+'\ufb46'..'\ufbb1'+'\ufbd3'..'\ufd3d'+'\ufd50'..'\ufd8f'+'\ufd92'..'\ufdc7'+'\ufdf0'..'\ufdfb'+'\ufe70'..'\ufe74'+'\ufe76'..'\ufefc'+'\uff21'..'\uff3a'+'\uff41'..'\uff5a'+'\uff66'..'\uffbe'+'\uffc2'..'\uffc7'+'\uffca'..'\uffcf'+'\uffd2'..'\uffd7'+'\uffda'..'\uffdc'.
	unicodeIdentifierPart = '_' + 'a'..'z' + 'A'..'Z' + '0'..'9' + '\u00aa'+'\u00b5'+'\u00ba'+'\u00c0'..'\u00d6'+'\u00d8'..'\u00f6'+'\u00f8'..'\u02c1'+'\u02c6'..'\u02d1'+'\u02e0'..'\u02e4'+'\u02ec'+'\u02ee'+'\u0370'..'\u0374'+'\u0376'+'\u0377'+'\u037a'..'\u037d'+'\u0386'+'\u0388'..'\u038a'+'\u038c'+'\u038e'..'\u03a1'+'\u03a3'..'\u03f5'+'\u03f7'..'\u0481'+'\u048a'..'\u0527'+'\u0531'..'\u0556'+'\u0559'+'\u0561'..'\u0587'+'\u05d0'..'\u05ea'+'\u05f0'..'\u05f2'+'\u0620'..'\u064a'+'\u066e'+'\u066f'+'\u0671'..'\u06d3'+'\u06d5'+'\u06e5'+'\u06e6'+'\u06ee'+'\u06ef'+'\u06fa'..'\u06fc'+'\u06ff'+'\u0710'+'\u0712'..'\u072f'+'\u074d'..'\u07a5'+'\u07b1'+'\u07ca'..'\u07ea'+'\u07f4'+'\u07f5'+'\u07fa'+'\u0800'..'\u0815'+'\u081a'+'\u0824'+'\u0828'+'\u0840'..'\u0858'+'\u08a0'+'\u08a2'..'\u08ac'+'\u0904'..'\u0939'+'\u093d'+'\u0950'+'\u0958'..'\u0961'+'\u0971'..'\u0977'+'\u0979'..'\u097f'+'\u0985'..'\u098c'+'\u098f'+'\u0990'+'\u0993'..'\u09a8'+'\u09aa'..'\u09b0'+'\u09b2'+'\u09b6'..'\u09b9'+'\u09bd'+'\u09ce'+'\u09dc'+'\u09dd'+'\u09df'..'\u09e1'+'\u09f0'+'\u09f1'+'\u0a05'..'\u0a0a'+'\u0a0f'+'\u0a10'+'\u0a13'..'\u0a28'+'\u0a2a'..'\u0a30'+'\u0a32'+'\u0a33'+'\u0a35'+'\u0a36'+'\u0a38'+'\u0a39'+'\u0a59'..'\u0a5c'+'\u0a5e'+'\u0a72'..'\u0a74'+'\u0a85'..'\u0a8d'+'\u0a8f'..'\u0a91'+'\u0a93'..'\u0aa8'+'\u0aaa'..'\u0ab0'+'\u0ab2'+'\u0ab3'+'\u0ab5'..'\u0ab9'+'\u0abd'+'\u0ad0'+'\u0ae0'+'\u0ae1'+'\u0b05'..'\u0b0c'+'\u0b0f'+'\u0b10'+'\u0b13'..'\u0b28'+'\u0b2a'..'\u0b30'+'\u0b32'+'\u0b33'+'\u0b35'..'\u0b39'+'\u0b3d'+'\u0b5c'+'\u0b5d'+'\u0b5f'..'\u0b61'+'\u0b71'+'\u0b83'+'\u0b85'..'\u0b8a'+'\u0b8e'..'\u0b90'+'\u0b92'..'\u0b95'+'\u0b99'+'\u0b9a'+'\u0b9c'+'\u0b9e'+'\u0b9f'+'\u0ba3'+'\u0ba4'+'\u0ba8'..'\u0baa'+'\u0bae'..'\u0bb9'+'\u0bd0'+'\u0c05'..'\u0c0c'+'\u0c0e'..'\u0c10'+'\u0c12'..'\u0c28'+'\u0c2a'..'\u0c33'+'\u0c35'..'\u0c39'+'\u0c3d'+'\u0c58'+'\u0c59'+'\u0c60'+'\u0c61'+'\u0c85'..'\u0c8c'+'\u0c8e'..'\u0c90'+'\u0c92'..'\u0ca8'+'\u0caa'..'\u0cb3'+'\u0cb5'..'\u0cb9'+'\u0cbd'+'\u0cde'+'\u0ce0'+'\u0ce1'+'\u0cf1'+'\u0cf2'+'\u0d05'..'\u0d0c'+'\u0d0e'..'\u0d10'+'\u0d12'..'\u0d3a'+'\u0d3d'+'\u0d4e'+'\u0d60'+'\u0d61'+'\u0d7a'..'\u0d7f'+'\u0d85'..'\u0d96'+'\u0d9a'..'\u0db1'+'\u0db3'..'\u0dbb'+'\u0dbd'+'\u0dc0'..'\u0dc6'+'\u0e01'..'\u0e30'+'\u0e32'+'\u0e33'+'\u0e40'..'\u0e46'+'\u0e81'+'\u0e82'+'\u0e84'+'\u0e87'+'\u0e88'+'\u0e8a'+'\u0e8d'+'\u0e94'..'\u0e97'+'\u0e99'..'\u0e9f'+'\u0ea1'..'\u0ea3'+'\u0ea5'+'\u0ea7'+'\u0eaa'+'\u0eab'+'\u0ead'..'\u0eb0'+'\u0eb2'+'\u0eb3'+'\u0ebd'+'\u0ec0'..'\u0ec4'+'\u0ec6'+'\u0edc'..'\u0edf'+'\u0f00'+'\u0f40'..'\u0f47'+'\u0f49'..'\u0f6c'+'\u0f88'..'\u0f8c'+'\u1000'..'\u102a'+'\u103f'+'\u1050'..'\u1055'+'\u105a'..'\u105d'+'\u1061'+'\u1065'+'\u1066'+'\u106e'..'\u1070'+'\u1075'..'\u1081'+'\u108e'+'\u10a0'..'\u10c5'+'\u10c7'+'\u10cd'+'\u10d0'..'\u10fa'+'\u10fc'..'\u1248'+'\u124a'..'\u124d'+'\u1250'..'\u1256'+'\u1258'+'\u125a'..'\u125d'+'\u1260'..'\u1288'+'\u128a'..'\u128d'+'\u1290'..'\u12b0'+'\u12b2'..'\u12b5'+'\u12b8'..'\u12be'+'\u12c0'+'\u12c2'..'\u12c5'+'\u12c8'..'\u12d6'+'\u12d8'..'\u1310'+'\u1312'..'\u1315'+'\u1318'..'\u135a'+'\u1380'..'\u138f'+'\u13a0'..'\u13f4'+'\u1401'..'\u166c'+'\u166f'..'\u167f'+'\u1681'..'\u169a'+'\u16a0'..'\u16ea'+'\u16ee'..'\u16f0'+'\u1700'..'\u170c'+'\u170e'..'\u1711'+'\u1720'..'\u1731'+'\u1740'..'\u1751'+'\u1760'..'\u176c'+'\u176e'..'\u1770'+'\u1780'..'\u17b3'+'\u17d7'+'\u17dc'+'\u1820'..'\u1877'+'\u1880'..'\u18a8'+'\u18aa'+'\u18b0'..'\u18f5'+'\u1900'..'\u191c'+'\u1950'..'\u196d'+'\u1970'..'\u1974'+'\u1980'..'\u19ab'+'\u19c1'..'\u19c7'+'\u1a00'..'\u1a16'+'\u1a20'..'\u1a54'+'\u1aa7'+'\u1b05'..'\u1b33'+'\u1b45'..'\u1b4b'+'\u1b83'..'\u1ba0'+'\u1bae'+'\u1baf'+'\u1bba'..'\u1be5'+'\u1c00'..'\u1c23'+'\u1c4d'..'\u1c4f'+'\u1c5a'..'\u1c7d'+'\u1ce9'..'\u1cec'+'\u1cee'..'\u1cf1'+'\u1cf5'+'\u1cf6'+'\u1d00'..'\u1dbf'+'\u1e00'..'\u1f15'+'\u1f18'..'\u1f1d'+'\u1f20'..'\u1f45'+'\u1f48'..'\u1f4d'+'\u1f50'..'\u1f57'+'\u1f59'+'\u1f5b'+'\u1f5d'+'\u1f5f'..'\u1f7d'+'\u1f80'..'\u1fb4'+'\u1fb6'..'\u1fbc'+'\u1fbe'+'\u1fc2'..'\u1fc4'+'\u1fc6'..'\u1fcc'+'\u1fd0'..'\u1fd3'+'\u1fd6'..'\u1fdb'+'\u1fe0'..'\u1fec'+'\u1ff2'..'\u1ff4'+'\u1ff6'..'\u1ffc'+'\u2071'+'\u207f'+'\u2090'..'\u209c'+'\u2102'+'\u2107'+'\u210a'..'\u2113'+'\u2115'+'\u2119'..'\u211d'+'\u2124'+'\u2126'+'\u2128'+'\u212a'..'\u212d'+'\u212f'..'\u2139'+'\u213c'..'\u213f'+'\u2145'..'\u2149'+'\u214e'+'\u2160'..'\u2188'+'\u2c00'..'\u2c2e'+'\u2c30'..'\u2c5e'+'\u2c60'..'\u2ce4'+'\u2ceb'..'\u2cee'+'\u2cf2'+'\u2cf3'+'\u2d00'..'\u2d25'+'\u2d27'+'\u2d2d'+'\u2d30'..'\u2d67'+'\u2d6f'+'\u2d80'..'\u2d96'+'\u2da0'..'\u2da6'+'\u2da8'..'\u2dae'+'\u2db0'..'\u2db6'+'\u2db8'..'\u2dbe'+'\u2dc0'..'\u2dc6'+'\u2dc8'..'\u2dce'+'\u2dd0'..'\u2dd6'+'\u2dd8'..'\u2dde'+'\u2e2f'+'\u3005'..'\u3007'+'\u3021'..'\u3029'+'\u3031'..'\u3035'+'\u3038'..'\u303c'+'\u3041'..'\u3096'+'\u309d'..'\u309f'+'\u30a1'..'\u30fa'+'\u30fc'..'\u30ff'+'\u3105'..'\u312d'+'\u3131'..'\u318e'+'\u31a0'..'\u31ba'+'\u31f0'..'\u31ff'+'\u3400'..'\u4db5'+'\u4e00'..'\u9fcc'+'\ua000'..'\ua48c'+'\ua4d0'..'\ua4fd'+'\ua500'..'\ua60c'+'\ua610'..'\ua61f'+'\ua62a'+'\ua62b'+'\ua640'..'\ua66e'+'\ua67f'..'\ua697'+'\ua6a0'..'\ua6ef'+'\ua717'..'\ua71f'+'\ua722'..'\ua788'+'\ua78b'..'\ua78e'+'\ua790'..'\ua793'+'\ua7a0'..'\ua7aa'+'\ua7f8'..'\ua801'+'\ua803'..'\ua805'+'\ua807'..'\ua80a'+'\ua80c'..'\ua822'+'\ua840'..'\ua873'+'\ua882'..'\ua8b3'+'\ua8f2'..'\ua8f7'+'\ua8fb'+'\ua90a'..'\ua925'+'\ua930'..'\ua946'+'\ua960'..'\ua97c'+'\ua984'..'\ua9b2'+'\ua9cf'+'\uaa00'..'\uaa28'+'\uaa40'..'\uaa42'+'\uaa44'..'\uaa4b'+'\uaa60'..'\uaa76'+'\uaa7a'+'\uaa80'..'\uaaaf'+'\uaab1'+'\uaab5'+'\uaab6'+'\uaab9'..'\uaabd'+'\uaac0'+'\uaac2'+'\uaadb'..'\uaadd'+'\uaae0'..'\uaaea'+'\uaaf2'..'\uaaf4'+'\uab01'..'\uab06'+'\uab09'..'\uab0e'+'\uab11'..'\uab16'+'\uab20'..'\uab26'+'\uab28'..'\uab2e'+'\uabc0'..'\uabe2'+'\uac00'..'\ud7a3'+'\ud7b0'..'\ud7c6'+'\ud7cb'..'\ud7fb'+'\uf900'..'\ufa6d'+'\ufa70'..'\ufad9'+'\ufb00'..'\ufb06'+'\ufb13'..'\ufb17'+'\ufb1d'+'\ufb1f'..'\ufb28'+'\ufb2a'..'\ufb36'+'\ufb38'..'\ufb3c'+'\ufb3e'+'\ufb40'+'\ufb41'+'\ufb43'+'\ufb44'+'\ufb46'..'\ufbb1'+'\ufbd3'..'\ufd3d'+'\ufd50'..'\ufd8f'+'\ufd92'..'\ufdc7'+'\ufdf0'..'\ufdfb'+'\ufe70'..'\ufe74'+'\ufe76'..'\ufefc'+'\uff21'..'\uff3a'+'\uff41'..'\uff5a'+'\uff66'..'\uffbe'+'\uffc2'..'\uffc7'+'\uffca'..'\uffcf'+'\uffd2'..'\uffd7'+'\uffda'..'\uffdc'+'\u0300'..'\u036f'+'\u0483'..'\u0487'+'\u0591'..'\u05bd'+'\u05bf'+'\u05c1'+'\u05c2'+'\u05c4'+'\u05c5'+'\u05c7'+'\u0610'..'\u061a'+'\u064b'..'\u0669'+'\u0670'+'\u06d6'..'\u06dc'+'\u06df'..'\u06e4'+'\u06e7'+'\u06e8'+'\u06ea'..'\u06ed'+'\u06f0'..'\u06f9'+'\u0711'+'\u0730'..'\u074a'+'\u07a6'..'\u07b0'+'\u07c0'..'\u07c9'+'\u07eb'..'\u07f3'+'\u0816'..'\u0819'+'\u081b'..'\u0823'+'\u0825'..'\u0827'+'\u0829'..'\u082d'+'\u0859'..'\u085b'+'\u08e4'..'\u08fe'+'\u0900'..'\u0903'+'\u093a'..'\u093c'+'\u093e'..'\u094f'+'\u0951'..'\u0957'+'\u0962'+'\u0963'+'\u0966'..'\u096f'+'\u0981'..'\u0983'+'\u09bc'+'\u09be'..'\u09c4'+'\u09c7'+'\u09c8'+'\u09cb'..'\u09cd'+'\u09d7'+'\u09e2'+'\u09e3'+'\u09e6'..'\u09ef'+'\u0a01'..'\u0a03'+'\u0a3c'+'\u0a3e'..'\u0a42'+'\u0a47'+'\u0a48'+'\u0a4b'..'\u0a4d'+'\u0a51'+'\u0a66'..'\u0a71'+'\u0a75'+'\u0a81'..'\u0a83'+'\u0abc'+'\u0abe'..'\u0ac5'+'\u0ac7'..'\u0ac9'+'\u0acb'..'\u0acd'+'\u0ae2'+'\u0ae3'+'\u0ae6'..'\u0aef'+'\u0b01'..'\u0b03'+'\u0b3c'+'\u0b3e'..'\u0b44'+'\u0b47'+'\u0b48'+'\u0b4b'..'\u0b4d'+'\u0b56'+'\u0b57'+'\u0b62'+'\u0b63'+'\u0b66'..'\u0b6f'+'\u0b82'+'\u0bbe'..'\u0bc2'+'\u0bc6'..'\u0bc8'+'\u0bca'..'\u0bcd'+'\u0bd7'+'\u0be6'..'\u0bef'+'\u0c01'..'\u0c03'+'\u0c3e'..'\u0c44'+'\u0c46'..'\u0c48'+'\u0c4a'..'\u0c4d'+'\u0c55'+'\u0c56'+'\u0c62'+'\u0c63'+'\u0c66'..'\u0c6f'+'\u0c82'+'\u0c83'+'\u0cbc'+'\u0cbe'..'\u0cc4'+'\u0cc6'..'\u0cc8'+'\u0cca'..'\u0ccd'+'\u0cd5'+'\u0cd6'+'\u0ce2'+'\u0ce3'+'\u0ce6'..'\u0cef'+'\u0d02'+'\u0d03'+'\u0d3e'..'\u0d44'+'\u0d46'..'\u0d48'+'\u0d4a'..'\u0d4d'+'\u0d57'+'\u0d62'+'\u0d63'+'\u0d66'..'\u0d6f'+'\u0d82'+'\u0d83'+'\u0dca'+'\u0dcf'..'\u0dd4'+'\u0dd6'+'\u0dd8'..'\u0ddf'+'\u0df2'+'\u0df3'+'\u0e31'+'\u0e34'..'\u0e3a'+'\u0e47'..'\u0e4e'+'\u0e50'..'\u0e59'+'\u0eb1'+'\u0eb4'..'\u0eb9'+'\u0ebb'+'\u0ebc'+'\u0ec8'..'\u0ecd'+'\u0ed0'..'\u0ed9'+'\u0f18'+'\u0f19'+'\u0f20'..'\u0f29'+'\u0f35'+'\u0f37'+'\u0f39'+'\u0f3e'+'\u0f3f'+'\u0f71'..'\u0f84'+'\u0f86'+'\u0f87'+'\u0f8d'..'\u0f97'+'\u0f99'..'\u0fbc'+'\u0fc6'+'\u102b'..'\u103e'+'\u1040'..'\u1049'+'\u1056'..'\u1059'+'\u105e'..'\u1060'+'\u1062'..'\u1064'+'\u1067'..'\u106d'+'\u1071'..'\u1074'+'\u1082'..'\u108d'+'\u108f'..'\u109d'+'\u135d'..'\u135f'+'\u1712'..'\u1714'+'\u1732'..'\u1734'+'\u1752'+'\u1753'+'\u1772'+'\u1773'+'\u17b4'..'\u17d3'+'\u17dd'+'\u17e0'..'\u17e9'+'\u180b'..'\u180d'+'\u1810'..'\u1819'+'\u18a9'+'\u1920'..'\u192b'+'\u1930'..'\u193b'+'\u1946'..'\u194f'+'\u19b0'..'\u19c0'+'\u19c8'+'\u19c9'+'\u19d0'..'\u19d9'+'\u1a17'..'\u1a1b'+'\u1a55'..'\u1a5e'+'\u1a60'..'\u1a7c'+'\u1a7f'..'\u1a89'+'\u1a90'..'\u1a99'+'\u1b00'..'\u1b04'+'\u1b34'..'\u1b44'+'\u1b50'..'\u1b59'+'\u1b6b'..'\u1b73'+'\u1b80'..'\u1b82'+'\u1ba1'..'\u1bad'+'\u1bb0'..'\u1bb9'+'\u1be6'..'\u1bf3'+'\u1c24'..'\u1c37'+'\u1c40'..'\u1c49'+'\u1c50'..'\u1c59'+'\u1cd0'..'\u1cd2'+'\u1cd4'..'\u1ce8'+'\u1ced'+'\u1cf2'..'\u1cf4'+'\u1dc0'..'\u1de6'+'\u1dfc'..'\u1dff'+'\u200c'+'\u200d'+'\u203f'+'\u2040'+'\u2054'+'\u20d0'..'\u20dc'+'\u20e1'+'\u20e5'..'\u20f0'+'\u2cef'..'\u2cf1'+'\u2d7f'+'\u2de0'..'\u2dff'+'\u302a'..'\u302f'+'\u3099'+'\u309a'+'\ua620'..'\ua629'+'\ua66f'+'\ua674'..'\ua67d'+'\ua69f'+'\ua6f0'+'\ua6f1'+'\ua802'+'\ua806'+'\ua80b'+'\ua823'..'\ua827'+'\ua880'+'\ua881'+'\ua8b4'..'\ua8c4'+'\ua8d0'..'\ua8d9'+'\ua8e0'..'\ua8f1'+'\ua900'..'\ua909'+'\ua926'..'\ua92d'+'\ua947'..'\ua953'+'\ua980'..'\ua983'+'\ua9b3'..'\ua9c0'+'\ua9d0'..'\ua9d9'+'\uaa29'..'\uaa36'+'\uaa43'+'\uaa4c'+'\uaa4d'+'\uaa50'..'\uaa59'+'\uaa7b'+'\uaab0'+'\uaab2'..'\uaab4'+'\uaab7'+'\uaab8'+'\uaabe'+'\uaabf'+'\uaac1'+'\uaaeb'..'\uaaef'+'\uaaf5'+'\uaaf6'+'\uabe3'..'\uabea'+'\uabec'+'\uabed'+'\uabf0'..'\uabf9'+'\ufb1e'+'\ufe00'..'\ufe0f'+'\ufe20'..'\ufe26'+'\ufe33'+'\ufe34'+'\ufe4d'..'\ufe4f'+'\uff10'..'\uff19'+'\uff3f'. 
    digit = '0'..'9'.
    cr  = '\r'. 
    lf  = '\n'.
    tab = '\t'.
    anyButDoubleQuote = ANY - '\"' - '\\'.
    anyButQuote = ANY - '\''.
    anychar = ANY.
    other = ANY - '/' - '*'.
    anyExcludingEndOfLine = ANY - lf.

TOKENS
    ident = unicodeIdentifierStart {unicodeIdentifierPart}.
    number = digit {digit} .
    float = digit {digit} '.' digit {digit} [('E' | 'e') ['+'|'-'] digit {digit}].
    textstring = '"' {anyButDoubleQuote | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\u"} '"'.
    char = "'" (anyButQuote | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\u") "'".
    period = '.'.
    postfixed_replicationguide = digit {digit} 'L'.

    list_at = '@'.
    dominant_list_at = "@@".

    openbracket = '['.
    closebracket = ']'.
    openparen = '('.
    closeparen = ')'.

    not = '!'.
    neg = '-'.
    pipe = '|'.
    lessthan = '<'.
    greaterthan = '>'.
    lessequal = "<=".
    greaterequal = ">=".
    equal = "==".
    notequal = "!=".
    endline = ';'.
    rangeop = "..".

    kw_class = "class".
    kw_constructor = "constructor".
    kw_def = "def".
    kw_extend = "extends".
    kw_if = "if".
    kw_elseif = "elseif".
    kw_else = "else".
    kw_while = "while".
    kw_for = "for".
    kw_import = "import".
    kw_prefix = "prefix".
    kw_from = "from".
    kw_break = "break".
    kw_continue = "continue".
    kw_static = "static".
    kw_local = "local".

    literal_true = "true".
    literal_false = "false".
    literal_null = "null".

PRAGMAS

    inlinecomment =  "//" {anyExcludingEndOfLine}.			(. 
                                                                   CommentNode cNode = new CommentNode(la.col, la.line, la.val, CommentNode.CommentType.Inline); 
                                                                   commentNode.Body.Add(cNode); .)
    blockcomment = "/*" {'/' | other | '*' {'*'} other} '*' {'*'} '/'. (.
                                                             CommentNode cNode = new CommentNode(la.col, la.line, la.val, CommentNode.CommentType.Block); 
                                                             commentNode.Body.Add(cNode); .)

IGNORE cr + lf + tab

PRODUCTIONS


//-----------------------------DesignScriptParser---------------------------//
DesignScriptParser
=                           (. Node node = null; .)
    Hydrogen<out node>       
        (. 
            if (!core.IsParsingPreloadedAssembly && !core.IsParsingCodeBlockNode && !builtinMethodsLoaded)
            {
                CoreUtils.InsertPredefinedAndBuiltinMethods(core, node as CodeBlockNode);
                root = node;
            }
            else
            {
                root = node;
            } 
        .)

.
//------------------------------Associative----------------------------------//
Hydrogen<out Node codeBlockNode>
=                           
(. 
    ProtoCore.AST.AssociativeAST.CodeBlockNode codeblock = new ProtoCore.AST.AssociativeAST.CodeBlockNode();  
    NodeUtils.SetNodeStartLocation(codeblock, t); 
    ProtoCore.AST.AssociativeAST.AssociativeNode node = null; 
    ProtoFFI.ImportModuleHandler imh = null;
    if (core.IsParsingPreloadedAssembly)
    {
       imh = core.ImportHandler;
    }
    else
    {
        imh = this.ImportModuleHandler;
    }
    bool rootImport = null == imh;  
.)
    {
        (. ProtoCore.AST.AssociativeAST.AssociativeNode importNode = null; .)
        Import_Statement <out importNode>
        (. 
           if (null != importNode)
              (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(importNode);
        .)
    }
 (. 
    imh = null;
    if (core.IsParsingPreloadedAssembly)
    {
       imh = core.ImportHandler;
    }
    else
    {
        imh = ImportModuleHandler;
    }
    if(null != core.ContextDataManager)
    {
       if (imh == null)
           imh = new ProtoFFI.ImportModuleHandler(core);
       ProtoCore.AST.AssociativeAST.AssociativeNode importNode = null;
       importNode = core.ContextDataManager.Compile(imh);
       if (null != importNode)
           (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(importNode);
    }
    
    if (rootImport && null != imh && imh.RootImportNode.CodeNode.Body.Count != 0)
    {
       (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(imh.RootImportNode);
    }

    if (rootImport && core.IsParsingPreloadedAssembly && !builtinMethodsLoaded)
    {
        CoreUtils.InsertPredefinedAndBuiltinMethods(core, codeblock);
       core.ImportNodes = codeblock;
    }
.)
  {
    ( 
        IF(IsNotAttributeFunctionClass())     
        (                            
            Associative_Statement<out node>
        )
        |
        (
            (
                (	               
                    Associative_functiondecl<out node>
                )
                |
                (
                    Associative_classdecl<out node>
                )
            )
        )
    )   
                            (.  if (null != node)
                                {
                                    (codeblock as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(node); 
                                    
                                    stmtsParsed++;
                                }
                            .)                        
  }         

  
                           (. if (la.val == "if")
                                 SynErr(String.Format(Resources.UseInlineConditional, la.val)); .)
                           (. if ((la.val == "for")||(la.val == "while"))
                                 SynErr(String.Format(Resources.ValidForImperativeBlockOnly, la.val)); .)
                           (. 
                                codeBlockNode = codeblock;

                                // We look ahead (la) here instead of looking at the current token (t)
                                // because when we get here at the end of a language block, "t" would 
                                // have been pointing to the ending token of the last statement in the 
                                // language block. What we really need here is the closing bracket '}'
                                // character, and that's conveniently residing in the look ahead token.
                                // 
                                NodeUtils.SetNodeEndLocation(codeblock, la); 
                           .)
.

Import_Statement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=  SYNC
    (. 
       string moduleName = "", typeName = "", alias = "";
    .)
        kw_import 
        '(' 
            ((
                textstring  (. moduleName = t.val;.) 
             )
            |
            (
                ident       (. typeName = t.val;
                            .)
                kw_from 
                textstring  (. moduleName = t.val; .)
            )) 
        ')' 
        [kw_prefix ident] 
                            (. 
                                if (la.kind != _endline)
                                   SynErr(Resources.SemiColonExpected);
                            .)
        endline
    (.
        if (moduleName == null) {
            node = null;
            return;
        }

        ProtoFFI.ImportModuleHandler imh = null;
        if (core.IsParsingPreloadedAssembly)
        {
            if (core.ImportHandler == null)
            {
                core.ImportHandler = new ProtoFFI.ImportModuleHandler(core);

            }
            imh = core.ImportHandler;
        }
        else
        {
            if (this.ImportModuleHandler == null)
            {

            this.ImportModuleHandler = new ProtoFFI.ImportModuleHandler(core);
         }
            imh = this.ImportModuleHandler;
        }

        node = imh.Import(moduleName, typeName, alias);
    .)
.

//------------------------------------------------------------------------
Associative_Statement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>      
=  SYNC                     (. if (!IsFullClosure()) SynErr(Resources.CloseBracketExpected); .)
                            (. node = null; .)
(
		Associative_ReturnStatement<out node>
    |      
        Associative_LanguageBlock<out node>
	|
	IF(IsNonAssignmentStatement())
		Associative_NonAssignmentStatement<out node>
	|
    IF(IsFunctionCallStatement())
		Associative_FunctionCallStatement<out node>

	|
        Associative_FunctionalStatement<out node>
    |
        (
            (
                IF(core.ParsingMode == ParseMode.AllowNonAssignment)  
                    [
                        Associative_Expression<out node>
                    ]
                    endline   
            )
            |
            (
                (. 
                    if (la.val != ";")
                        SynErr(Resources.SemiColonExpected);
                .)
                endline   
            )      
        )
)
.

Associative_ReturnStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
	(.
        var bNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
		NodeUtils.SetNodeLocation(bNode, la);
	.)
	"return"
	[
		'='
	]
	(.
		var lhs = AstFactory.BuildIdentifier("return");
		lhs.datatype = TypeSystem.BuildPrimitiveTypeObject(ProtoCore.PrimitiveType.Return);
		bNode.LeftNode = lhs;

		ProtoCore.AST.AssociativeAST.AssociativeNode rhs = null;
	.)
	(
		    Associative_LanguageBlock<out rhs>
		|
			Associative_Expression<out rhs>
			endline
	)
	(.
        bNode.RightNode = rhs;
        bNode.Optr = Operator.assign;

		node = bNode;
	.)
.

Associative_StatementList<.out List<ProtoCore.AST.AssociativeAST.AssociativeNode> nodelist.> 
=
                    (. nodelist = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); .)
{ 
    (. ProtoCore.AST.AssociativeAST.AssociativeNode node = null; .)
    Associative_Statement<out node> (. if (null != node) nodelist.Add(node); .)
}    
    (.         
        if (la.val == "if")
            SynErr(String.Format(Resources.UseInlineConditional, la.val)); 
        if ((la.val == "for")||(la.val == "while"))
             SynErr(String.Format(Resources.ValidForImperativeBlockOnly, la.val));
    .)
.

Associative_classdecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node.>
=
                                                (. ProtoCore.AST.AssociativeAST.ClassDeclNode classnode = new ProtoCore.AST.AssociativeAST.ClassDeclNode(); .)
                                                (. NodeUtils.SetNodeLocation(classnode, la); .)
    kw_class        
    ident                                       (. classnode.ClassName = t.val; .)      
                                                (. isInClass = true;
                                                    if (IsKeyWord(t.val, true))
                                                    {
                                                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                                    }
                                                .)
    [
        kw_extend
        ident								(. String baseClass = t.val; .)
		{	
			'.'
			(. baseClass += t.val; .)
			ident
			(. baseClass += t.val; .)
		}
						                      (.
                                                    classnode.BaseClass = baseClass;
                                                .)
    ]
    '{'
        {										
                                               (. ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public; .)
            [
                Associative_AccessSpecifier<out access>
            ]
            (           
                (      
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode constr = null; .)   
                    Associative_constructordecl<out constr, access>     
                                                (. if (String.IsNullOrEmpty(constr.Name))
                                                   {
                                                       constr.Name= classnode.ClassName;
                                                   }
                                                   classnode.Procedures.Add(constr); 
                                                .)
                )
                |
                (
                                                (. bool isStatic = false; .)
                    [
                        kw_static               (. isStatic = true; .) 
                    ]
                    (
						(
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode funcnode; .)
                            Associative_functiondecl<out funcnode, access, isStatic>      
                                                (. classnode.Procedures.Add(funcnode); .)
                        )
                        |
                        (   
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode varnode = null; .)  
                            Associative_memvardecl<out varnode, access, isStatic>    
                                                (. classnode.Variables.Add(varnode); .)

                                                (. 
                                                   if (la.val != ";")
                                                       SynErr(Resources.SemiColonExpected);  
                                                .)
                                                endline
                                                (. NodeUtils.SetNodeEndLocation(varnode, t); .)
                        )
                        |
                        endline
                    )
                )
            )
            
        }
    '}' 
                                                (. isInClass = false; classnode.endLine = t.line; classnode.endCol = t.col; .)
                                                (. node = classnode; .)
.



Associative_LanguageBlock<out ProtoCore.AST.AssociativeAST.AssociativeNode node>            
=                                       
                                        (. 
                                            node = null; 
                                            ProtoCore.AST.AssociativeAST.LanguageBlockNode langblock = new ProtoCore.AST.AssociativeAST.LanguageBlockNode(); 
                                        .)  
    openbracket                         (. NodeUtils.SetNodeLocation(langblock, t); .)
    ident
                                        (.
                                            if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.imperative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Imperative;
                                            }
                                            else if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.associative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Associative; 
                                            }
                                            else {
                                                langblock.codeblock.Language = ProtoCore.Language.NotSpecified;
                                                errors.SemErr(t.line, t.col, String.Format(Resources.InvalidLanguageBlockIdentifier, t.val));
                                            }
                                        .)
    closebracket    
    '{'                      (. Node codeBlockNode = null; .)
    
    (
    IF( langblock.codeblock.Language == ProtoCore.Language.Associative ||
        langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
    Hydrogen<out codeBlockNode>              
    |    
    IF( langblock.codeblock.Language == ProtoCore.Language.Imperative )
    Imperative<out codeBlockNode>              
    )
    (
     IF( langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
                                            (. int openCurlyBraceCount = 0, closeCurlyBraceCount = 0; .)
                                            (. ProtoCore.AST.AssociativeAST.CodeBlockNode codeBlockInvalid = new ProtoCore.AST.AssociativeAST.CodeBlockNode(); .)
                                            (. ProtoCore.AST.AssociativeAST.AssociativeNode validBlockInInvalid = null; .)
    {
    IF (closeCurlyBraceCount <= openCurlyBraceCount)  
    (                                                                           
        Associative_LanguageBlock<out validBlockInInvalid>   (. codeBlockInvalid.Body.Add(validBlockInInvalid); .)
        |       
        '{'                                 (. openCurlyBraceCount++; .)
        |
        '}'                                 (. closeCurlyBraceCount++; .)
        |
        EOF
        '}'                                 (. break; .)  
        |
                                    (. Get(); .)
    )   
    }                                    
                                            (. codeBlockNode = codeBlockInvalid; .)
    |
    '}'
    )                                       (. langblock.CodeBlockNode = codeBlockNode; .)
                                            (. node = langblock; .)
.       

Associative_constructordecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode constrNode, ProtoCore.CompilerDefinitions.AccessModifier access.>
=                           (.
                                ProtoCore.AST.AssociativeAST.ConstructorDefinitionNode constr = new ProtoCore.AST.AssociativeAST.ConstructorDefinitionNode(); ;                                 
                                string methodName;  
                                ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature; 
                            .)  
    kw_constructor          (. NodeUtils.SetNodeStartLocation(constr, t); .)
    Associative_CtorSignature<out methodName, out argumentSignature>
                            (.
                                var returnType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, Constants.kArbitraryRank);
                            
                                constr.Name = methodName; 
                                constr.ReturnType = returnType;
                                constr.Signature = argumentSignature as ProtoCore.AST.AssociativeAST.ArgumentSignatureNode;
                                constr.Access = access; 
                                ProtoCore.AST.AssociativeAST.AssociativeNode functionBody = null; 
                            .)
    [
        ':'                                         (. ProtoCore.AST.AssociativeAST.AssociativeNode bnode; .)
        Associative_BaseConstructorCall<out bnode>  (. constr.BaseConstructor = bnode as ProtoCore.AST.AssociativeAST.FunctionCallNode; .)
    ]
(
    Associative_FunctionDefinitionBody<out functionBody> 
)
                            (. constr.FunctionBody = functionBody as ProtoCore.AST.AssociativeAST.CodeBlockNode; .)
                            (. NodeUtils.SetNodeEndLocation(constr, functionBody); .)
                            (. constrNode = constr; .)
.

Associative_BaseConstructorCall<out ProtoCore.AST.AssociativeAST.AssociativeNode bnode>
=                                   (. ProtoCore.AST.AssociativeAST.FunctionCallNode f = new ProtoCore.AST.AssociativeAST.FunctionCallNode(); .)
                                    (. List<ProtoCore.AST.AssociativeAST.AssociativeNode> args = null; .)
                                    (. 
                                       if (la.val != "base")
                                       {
                                           SynErr(Resources.BaseIsExpectedToCallBaseConstructor); 
                                       }
                                       else
                                       {
                                           Get();
                                           NodeUtils.SetNodeLocation(f, t);
                                       }
                                    .)
    [ 
        "."
        Associative_Ident<out bnode>            (. f.Function = bnode; .)
    ]
    Associative_Arguments<out args>             (. f.FormalArguments = args; .) 
                                                (. bnode = f; .)
.

//------------------------------------------------------------------------
Associative_AccessSpecifier<out ProtoCore.CompilerDefinitions.AccessModifier access>
=                   (. access = ProtoCore.CompilerDefinitions.AccessModifier.Public; .)
    (
        "public"        
        |
        "private"       (. access = ProtoCore.CompilerDefinitions.AccessModifier.Private; .)
        |
        "protected"     (. access = ProtoCore.CompilerDefinitions.AccessModifier.Protected; .)
    )
.

Associative_functiondecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public, bool isStatic = false.>
=                           
                            (. 
                                ProtoCore.AST.AssociativeAST.FunctionDefinitionNode f = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode(); 
                                string methodName;  
                                ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature; 
                                ProtoCore.Type returnType;  
                                string externLibName = ""; 
                                bool isExternLib = false; 
                            .)  
    kw_def                  (. NodeUtils.SetNodeLocation(f, t); .)
    Associative_MethodSignature<out methodName, out argumentSignature, out returnType>
                            (.
                                if (isExternLib &&  "var" == returnType.Name){
                                    errors.Warning(String.Format("External function {0} does not have a return type defined. Defaulting to var.", methodName));
                                }

                            .) 
                            (. 
                                f.IsExternLib = isExternLib; 
                                f.ExternLibName = externLibName; 
                                f.Name = methodName; 
                                f.ReturnType = returnType; 
                                f.Access = access;
                                f.Signature = argumentSignature as ProtoCore.AST.AssociativeAST.ArgumentSignatureNode; 
                                f.IsStatic = isStatic;
                                ProtoCore.AST.AssociativeAST.AssociativeNode functionBody = null; 
                            .) 
    Associative_FunctionDefinitionBody<out functionBody>
                            (. f.FunctionBody = functionBody as ProtoCore.AST.AssociativeAST.CodeBlockNode; 
                                node = f;   
                            .)
               
.

//------------------------------------------------------------------------
Associative_MethodSignature<out string methodName, out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign, out ProtoCore.Type returnType>
=
ident                           (. methodName = t.val; .)
                                (.  if (IsKeyWord(t.val, true))
                                    {
                                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                    }
                                    ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature = null;
                                    returnType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, Constants.kArbitraryRank);
                                .)
[
    Associative_TypeRestriction<out returnType>
]

Associative_ArgumentSignatureDefinition<out argumentSignature>
                                (. argumentSign = argumentSignature; .)
.

Associative_CtorSignature<out string ctorName, out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign>
=
                                (. ctorName = null;  .)
[
    ident                       (. ctorName = t.val; .)
                                (.  if (IsKeyWord(ctorName, true))
                                    {
                                         errors.SemErr(t.line, t.col, String.Format(Resources.keywordCannotBeUsedAsConstructorName, t.val));
                                    }
                                .)
]
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode argumentSignature = null;.) 
Associative_ArgumentSignatureDefinition<out argumentSignature>
                                (. argumentSign = argumentSignature; .)
.

//------------------------------------------------------------------------
Associative_ArgumentSignatureDefinition<out ProtoCore.AST.AssociativeAST.AssociativeNode argumentSign>
                                                (. ProtoCore.AST.AssociativeAST.ArgumentSignatureNode argumentSignature = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode(); .)
= 
'('                                             (. NodeUtils.SetNodeLocation(argumentSignature, t); .)
                                                (. ProtoCore.AST.AssociativeAST.AssociativeNode arg;.)
    [
                                                (. if (NotDefaultArg()) { .)
        Associative_ArgDecl<out arg>            (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        
        {                                       (. if (NotDefaultArg()) { .) 
                WEAK ','            
                Associative_ArgDecl<out arg>    (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
                                                (. } else break; .)
        }    
                                                (. } .)
    ]    
    [
        [
            ','
        ]        
        Associative_DefaultArgDecl<out arg>                 (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        {
            ','
           Associative_DefaultArgDecl<out arg>              (. argumentSignature.AddArgument(arg as ProtoCore.AST.AssociativeAST.VarDeclNode); .)
        }
    ]
')'
                                                (. argumentSign = argumentSignature; .)
.

Associative_memvardecl<.out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public, bool isStatic = false.>    
= 
                                    (.
                                        ProtoCore.AST.AssociativeAST.IdentifierNode tNode = null; 
                                        ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = new ProtoCore.AST.AssociativeAST.VarDeclNode(); 
                                        varDeclNode.Access = access;
                                        varDeclNode.IsStatic = isStatic;
                                    .)

    (
        ident                       (. 
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        NodeUtils.SetNodeLocation(varDeclNode, t);
                                        tNode = AstFactory.BuildIdentifier(t.val);
                                        NodeUtils.SetNodeLocation(tNode, t);
                                        varDeclNode.NameNode = tNode;
                                    .)  
    )
    [
    ':'
    ident                           (. ProtoCore.Type argtype = new ProtoCore.Type(); argtype.Name = t.val; argtype.rank = 0; .)
    [                               
        openbracket closebracket    (. argtype.rank = 1; .)
        [
            ( ".." openbracket closebracket )   (. argtype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
            |
            ( 
                {
                    openbracket closebracket    (. argtype.rank++; .)
                } 
            )
        ]
    ]
        (.
            string oldName = tNode.Name;
            string oldValue = tNode.Value;

            // Here since the variable has an explicitly specified type 
            // the "IdentifierNode" should really be "TypedIdentifierNode"
            // (which is used to indicate the identifier that has explicit 
            // type specified).
            tNode = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode()
            {
                Name = oldName,
                Value = oldValue
            };

            argtype.UID = core.TypeSystem.GetType(argtype.Name);
            tNode.datatype = argtype;
            varDeclNode.NameNode = tNode;
            varDeclNode.ArgumentType = argtype;
        .)
    ]
   
                                    (. 
                                        node = varDeclNode; 
                                        //if(!isGlobalScope) {
                                        //    localVarCount++;
                                        //}
                                    .)

.

Associative_ArgDecl<out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public>    
= 
                                    (.
                                        ProtoCore.AST.AssociativeAST.IdentifierNode tNode = null; 
                                        ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = new ProtoCore.AST.AssociativeAST.VarDeclNode(); 
                                        varDeclNode.Access = access;
                                    .)

    (
        ident                       (.
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        tNode = AstFactory.BuildIdentifier(t.val);
                                        NodeUtils.SetNodeLocation(tNode, t);
                                        varDeclNode.NameNode = tNode;
                                        NodeUtils.CopyNodeLocation(varDeclNode, tNode);
                                    .)  
    )
                                        (. ProtoCore.Type argtype = new ProtoCore.Type(); argtype.Name = "var"; argtype.rank = 0; argtype.UID = 0; .)
    [                                   
        ':'
        ident                           (. argtype.Name = t.val; .)
        [                               
            openbracket closebracket    (. argtype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   (. argtype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    (. argtype.rank++; .)
                    } 
                )
            ]
        ]
    ]
                                    (.  varDeclNode.ArgumentType = argtype; .)          
                                      (. node = varDeclNode; .)
.


Associative_DefaultArgDecl<out ProtoCore.AST.AssociativeAST.AssociativeNode node, ProtoCore.CompilerDefinitions.AccessModifier access = ProtoCore.CompilerDefinitions.AccessModifier.Public>	
=
    Associative_ArgDecl<out node>    (. ProtoCore.AST.AssociativeAST.VarDeclNode varDeclNode = node as ProtoCore.AST.AssociativeAST.VarDeclNode; .)
    '=' 
                                     (. ProtoCore.AST.AssociativeAST.AssociativeNode rhsNode; .)
    Associative_Expression<out rhsNode> 
                                     (.
                                        ProtoCore.AST.AssociativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
                                        NodeUtils.CopyNodeLocation(bNode, varDeclNode);
                                        bNode.LeftNode = varDeclNode.NameNode;
                                        bNode.RightNode = rhsNode;
                                        bNode.Optr = Operator.assign;
                                        varDeclNode.NameNode = bNode;
                                        .)
                                    (. node = varDeclNode; .)
.

//------------------------------------------------------------------------
Associative_TypeRestriction<out ProtoCore.Type type>
=
  ':'  Associative_ClassReference<out type> (. type.rank = 0; .)
  [                             
        openbracket closebracket    (. type.rank = 1; .)
        [
            ( ".." openbracket closebracket )   (. type.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
            |
            ( 
                {
                    openbracket closebracket    (. type.rank++; .)
                } 
            )
        ]
    ]
.

//------------------------------------------------------------------------
Associative_ClassReference<out ProtoCore.Type type>
=
                                 (. type = new ProtoCore.Type(); .)  
                                 (. string name; .)  
 ident                           (. name = t.val; .)
                                 (. type.Name = name; .)
                                 (. type.UID = 0; .)
.

//------------------------------------------------------------------------
Associative_FunctionDefinitionBody<out ProtoCore.AST.AssociativeAST.AssociativeNode funcBody>
=                                       (.
                                            ProtoCore.AST.AssociativeAST.CodeBlockNode functionBody = new ProtoCore.AST.AssociativeAST.CodeBlockNode(); 
                                            List<ProtoCore.AST.AssociativeAST.AssociativeNode> body = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); 
                                            NodeUtils.SetNodeStartLocation(functionBody, la);
                                        .)
    '{'        
                                         
            Associative_StatementList<out body>                                        
                                        (. functionBody.Body =body;  .)
    '}'                                 (. NodeUtils.SetNodeEndLocation(functionBody, t); .)
                                        (. funcBody = functionBody; .)
.

TypedIdentifierList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
(
		ident
		(. node = new IdentifierNode(t.val); .)
		
			{
				'.'
				(. ProtoCore.AST.AssociativeAST.AssociativeNode rnode = null; .)
				ident
				(. 
					rnode = new IdentifierNode(t.val);
            
					ProtoCore.AST.AssociativeAST.IdentifierListNode bnode = new ProtoCore.AST.AssociativeAST.IdentifierListNode();
					bnode.LeftNode = node;
					bnode.Optr = Operator.dot;
					bnode.RightNode = rnode;
					node = bnode;
					NodeUtils.SetNodeLocation(bnode, bnode.LeftNode, bnode.RightNode); 
				.)
			}
		
 ) 
 .   

Associative_DecoratedIdentifier<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                           (. node = null; .)
(
    (IF (IsLocallyTypedVariable())
    (
        ident           (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var typedVar = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode();
                            typedVar.Name = typedVar.Value = t.val;
                            NodeUtils.SetNodeLocation(typedVar, t);
                        .)
        ':'
            
            
        kw_local         (.
                                typedVar.IsLocal = true;
                         .)
            

        ident
                        (. 
                            int type = core.TypeSystem.GetType(t.val); 
                            if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
                            {
                                var unknownType = new ProtoCore.Type();
                                unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
                                unknownType.Name = t.val; 
                                typedVar.datatype = unknownType;
                            }
                            else
                            {
                                typedVar.datatype = core.TypeSystem.BuildTypeObject(type, 0);
                            }
                        .)

        [                               
                        (. var datatype = typedVar.datatype; .)
            openbracket closebracket    
                        (. datatype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   
                        (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    
                        (. datatype.rank++; .)
                    } 
                )
            ]
                        (. typedVar.datatype = datatype; .)
        ]

                        (.  node = typedVar; .)
        )
    )
     

    |
    (IF (IsLocalVariable())
    (      
        ident       (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var identNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
                            identNode.Name = identNode.Value = t.val;
                            NodeUtils.SetNodeLocation(identNode, t);
                        .)
        ':' 
        kw_local            (.
                                identNode.IsLocal = true;
                            .)
                            (.  node = identNode; .)
    )
    )
    
    |
    (IF (IsTypedVariable())
    (               
        ident           (.  
                            if (IsKeyWord(t.val, true))
                            {
                                errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                            }
                            var typedVar = new ProtoCore.AST.AssociativeAST.TypedIdentifierNode();
                            typedVar.Name = typedVar.Value = t.val;
                            NodeUtils.SetNodeLocation(typedVar, t);
                        .)
        ':'


            (. 
                string strIdent = string.Empty;
				int type = ProtoCore.DSASM.Constants.kInvalidIndex;
			.)
				
				(IF (IsIdentList())
				(
					TypedIdentifierList<out node>
										(.	strIdent = node.ToString(); .)
				)
				|
				(
					ident
							(. strIdent = t.val; .)
							
				)
				)
				(.
						type = core.TypeSystem.GetType(strIdent);
						typedVar.TypeAlias = strIdent;
						if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
						{
							var unknownType = new ProtoCore.Type();
							unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
							unknownType.Name = strIdent; 
							typedVar.datatype = unknownType;
						}
						else
						{
							typedVar.datatype = core.TypeSystem.BuildTypeObject(type, 0);
						}
				.)		
				
	

        [                               
                        (. var datatype = typedVar.datatype; .)
            openbracket closebracket    
                        (. datatype.rank = 1; .)
            [
                ( ".." openbracket closebracket )   
                        (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                |
                ( 
                    {
                        openbracket closebracket    
                        (. datatype.rank++; .)
                    } 
                )
            ]
                        (. typedVar.datatype = datatype; .)
        ]

                        (.  node = typedVar; .)
        )
    )

    |
    (
        Associative_IdentifierList<out node>
    )
)
.

Associative_NonAssignmentStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  SYNC                       (.
								 node = null; 
								 ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
						     .)
(
	(
		Associative_Expression<out rightNode>
					(.
						//Try to make a false binary expression node.					    
						ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
						ProtoCore.AST.AssociativeAST.IdentifierNode leftNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
						leftNode.Value = leftNode.Name = Constants.kTempProcLeftVar;

						var unknownType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, 0);
						leftNode.datatype = unknownType;
						leftNode.line = rightNode.line;
						leftNode.col = rightNode.col;
						leftNode.endLine = rightNode.endLine;
						leftNode.endCol = rightNode.endCol;

						expressionNode.LeftNode = leftNode;
						expressionNode.RightNode = rightNode;
						expressionNode.Optr = Operator.assign;
						NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
						node = expressionNode;
					.)			
                    
                    (. 
                        if (la.val != ";")
                            SynErr(Resources.SemiColonExpected);  
                    .)
		endline				
					(. NodeUtils.SetNodeEndLocation(node, t); .)

	)
)
.

Associative_FunctionCallStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  SYNC                       (.
								 node = null; 
								 ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
						     .)
(
	(
		Associative_Expression<out rightNode>
					(.
                        bool allowIdentList = core.Options.GenerateSSA && rightNode is ProtoCore.AST.AssociativeAST.IdentifierListNode;

						//Try to make a false binary expression node.
					    if (rightNode is ProtoCore.AST.AssociativeAST.FunctionDotCallNode 
                            || rightNode is ProtoCore.AST.AssociativeAST.FunctionCallNode
                            || allowIdentList)
						{
							ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode();
							ProtoCore.AST.AssociativeAST.IdentifierNode leftNode = new ProtoCore.AST.AssociativeAST.IdentifierNode();
							leftNode.Value = leftNode.Name = Constants.kTempProcLeftVar;

							var unknownType = TypeSystem.BuildPrimitiveTypeObject(PrimitiveType.Var, 0);
							leftNode.datatype = unknownType;
							leftNode.line = rightNode.line;
							leftNode.col = rightNode.col;
							leftNode.endLine = rightNode.endLine;
							leftNode.endCol = rightNode.endCol;

							expressionNode.LeftNode = leftNode;
							expressionNode.RightNode = rightNode;
							expressionNode.Optr = Operator.assign;
							NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
							node = expressionNode;
						}
					.)			
                    
                    (. 
                        if (la.val != ";")
                            SynErr(Resources.SemiColonExpected);  
                    .)
		endline				
					(. NodeUtils.SetNodeEndLocation(node, t); .)

	)
)
.


Associative_FunctionalStatement<out ProtoCore.AST.AssociativeAST.AssociativeNode node> 
=
 SYNC                       (. node = null; .)
 (
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode leftNode = null; .)
                                (. ProtoCore.AST.AssociativeAST.BinaryExpressionNode expressionNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode(); .)
    (                           (. isLeft = true; .)
        Associative_DecoratedIdentifier<out leftNode>
                                (. 
                                   isLeft = false;
                                   NodeUtils.CopyNodeLocation(expressionNode, leftNode);
                                   node = leftNode; 
                                .)
    )
    (
        endline
                                (.
                                    // Comment Jun: Graph IDE precompile  does not require conversion to a binary expression
                                    if (core.ParsingMode != ParseMode.AllowNonAssignment)
                                    {
                                        expressionNode.LeftNode = leftNode;
                                        expressionNode.RightNode = null;
                                        expressionNode.Optr = Operator.assign;
                                        NodeUtils.UpdateBinaryExpressionLocation(expressionNode);
                                        node = expressionNode;
                                    }
                                .)
        |
        (
            '='                 
                                (. 
                                    ProtoCore.AST.AssociativeAST.AssociativeNode rightNode = null;
                                    bool isLeftMostNode = false; 
                                    if (leftVar == null) 
                                    {
                                        if (node is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                        {
                                            isLeftVarIdentList = true;
                                            leftVar = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(node);
                                        }
                                        else
                                        {
                                            isLeftVarIdentList = false;
                                            leftVar = node.Name; 
                                        }
                                        isLeftMostNode = true;
                                        withinModifierCheckScope = true;
                                    } 
                                .)                            
            (
                (
                    IF(HasMoreAssignmentStatements())
                        Associative_FunctionalStatement<out rightNode>
                                (.   
                                    expressionNode.LeftNode = leftNode; 
                                    expressionNode.RightNode = rightNode; 
                                    NodeUtils.SetNodeEndLocation(expressionNode, rightNode);
                                    expressionNode.Optr = Operator.assign; 
                                    expressionNode.isMultipleAssign = true;
                                    node = expressionNode; 
                                .)    
                )
                |
                (  
                                (. 
                                    withinModifierCheckScope = false; 
                                .)
                    Associative_LanguageBlock<out rightNode>
                                (. 
                                    NodeUtils.SetNodeEndLocation(expressionNode, t);
                                    expressionNode.LeftNode = leftNode;
                                    expressionNode.RightNode = rightNode;
                                    expressionNode.Optr = Operator.assign;
                                    node = expressionNode; 
                                .)    
                )
                |
                (
                    Associative_Expression<out rightNode>
                                (.
                                    expressionNode.LeftNode = leftNode;
                                    expressionNode.RightNode = rightNode;
                                    expressionNode.Optr = Operator.assign;
                                    NodeUtils.UpdateBinaryExpressionLocation(expressionNode);

                                    if (rightNode is ProtoCore.AST.AssociativeAST.ExprListNode)
                                        expressionNode.RightNode.Name = leftVar;
                                .)			

                                (. 
                                    if (la.kind != _endline)
                                       SynErr(Resources.SemiColonExpected);
                                .)
                    endline				
                                (. NodeUtils.SetNodeEndLocation(expressionNode, t); node = expressionNode; .)
                )
            )
                                (.
                                    if (isLeftMostNode) 
                                    {
                                        leftVar = null;
                                        if (node is ProtoCore.AST.AssociativeAST.BinaryExpressionNode)
                                        {
                                            node.IsModifier = isModifier;   
                                        }
                                        isModifier = false;
                                        withinModifierCheckScope = false;
                                        isLeftVarIdentList = false;                                  
                                    }  
                                .)
        )
        |
        (
            (. SynErr(Resources.SemiColonExpected); .)
        )
    )
)
.

Associative_Expression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=               (. node = null; .)
    (
        Associative_LogicalExpression<out node>
    )
    {
        Associative_TernaryOp<ref node>
    }
.

Associative_TernaryOp<ref ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
                                            (. ProtoCore.AST.AssociativeAST.InlineConditionalNode inlineConNode = new ProtoCore.AST.AssociativeAST.InlineConditionalNode(); .)
        "?"                                 (. inlineConNode.ConditionExpression = node; node = null; .)
        Associative_Expression<out node>    (. inlineConNode.TrueExpression = node; .)
        ":"                                 (. node = null; .)
        Associative_Expression<out node>    (.
                                                inlineConNode.FalseExpression = node;
                                                node = inlineConNode;
                                                NodeUtils.SetNodeLocation(inlineConNode, inlineConNode.ConditionExpression, inlineConNode.FalseExpression);
                                            .)
.

Associative_UnaryExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
    (
        (
            Associative_NegExpression<out node>
        )
    |
        (
            Associative_BitUnaryExpression<out node>
        )
    )
.

Associative_BitUnaryExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.AssociativeAST.AssociativeNode exprNode; .)
    Associative_unaryop<out op>     
    Associative_Factor<out exprNode>    
                        (. 
                            node = GenerateUnaryOperatorMethodCallNode(op, exprNode);
                        .)
.

Associative_NegExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.AssociativeAST.AssociativeNode exprNode = null; .)
    Associative_negop<out op>
    Associative_IdentifierList <out exprNode>
                        (.  
                           node = GenerateUnaryOperatorMethodCallNode(op, exprNode);
                        .)
.

Associative_LogicalExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
  Associative_ComparisonExpression<out node>
  { 
                                    (.Operator op;.)

    Associative_LogicalOp<out op> 
                                    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_ComparisonExpression<out expr2>
                                    (.	
                                        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
                                    .)
  }
.

Associative_ComparisonOp<out Operator op>
                            (. op = Operator.none; .)
= ">"                       (. op = Operator.gt; .)
| ">="                      (. op = Operator.ge; .)
| "<"                       (. op = Operator.lt; .)
| "<="                      (. op = Operator.le; .)
| "=="                      (. op = Operator.eq; .)
| "!="                      (. op = Operator.nq; .)
.

Associative_ComparisonExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
Associative_RangeExpr<out node>
{ 
                                (. Operator op; .)
    Associative_ComparisonOp<out op>
                                (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_RangeExpr<out expr2>
                                (.	
                                   node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
                                .)
}
.

Associative_RangeExpr<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
    Associative_ArithmeticExpression<out node>
    [
                                        (.  ProtoCore.AST.AssociativeAST.RangeExprNode rnode = new ProtoCore.AST.AssociativeAST.RangeExprNode(); 
                                            rnode.From = node; NodeUtils.SetNodeStartLocation(rnode, node);
                                            bool hasRangeAmountOperator = false;
                                        .)
        rangeop
        [Associative_rangeAmountOperator<out hasRangeAmountOperator>]
                                        (. rnode.HasRangeAmountOperator = hasRangeAmountOperator; .)
        Associative_ArithmeticExpression<out node>  
                                        (. rnode.To = node; 
                                            NodeUtils.SetNodeEndLocation(rnode, node);
                                        .)
        [                               (. RangeStepOperator op; .)
            rangeop
            Associative_rangeStepOperator<out op>   
                                        (. rnode.StepOperator = op; .)
            Associative_ArithmeticExpression<out node> 
                                        (. rnode.Step = node;
                                           NodeUtils.SetNodeEndLocation(rnode, node);
                                        .)
        ]

                                        (. node = rnode; .)
    ]
.

Associative_AddOp<out Operator op>
=                   (. op = Operator.add; .)
  ( "+"
  | "-"             (. op = Operator.sub; .)
  ).


//------------------------------------------------------------------------
Associative_MulOp<out Operator op>
=                   (. op = Operator.mul; .)
  ( "*"
  | "/"             (. op = Operator.div; .)
  | "%"				(. op = Operator.mod; .)
  ).

Associative_LogicalOp<out Operator op>
=                   (. op = Operator.and; .)
( "&&"
| "||"              (. op = Operator.or; .)
)
.

Associative_negop<out UnaryOperator op>
=           (. op = UnaryOperator.None; .)
(
| '-'       (. op = UnaryOperator.Neg; .)
)
.

Associative_unaryop<out UnaryOperator op>                   
=           
    (. op = UnaryOperator.None; .)  
(	
     '!'       
        (. op = UnaryOperator.Not;    .)

        (. #if ENABLE_BIT_OP          .)
    | 
    '~'       
        (. op = UnaryOperator.Negate; .)
        (. #endif                     .)
)
.

Associative_rangeAmountOperator<out bool hasRangeAmountOperator>
= 
    (. hasRangeAmountOperator = false; .)
(
    '#' 
    (. hasRangeAmountOperator = true; .)
)
.

Associative_rangeStepOperator<out RangeStepOperator op>
=               
    (. op = RangeStepOperator.StepSize; .)
[ 
    '#'     
    (. op = RangeStepOperator.Number; .)
    | 
    '~'           
    (. op = RangeStepOperator.ApproximateSize; .)
]
.

Associative_ArithmeticExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
Associative_Term<out node>
{
    (. Operator op; .)
    Associative_AddOp<out op>
    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)
    Associative_Term<out expr2>
    (.	
        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
    .)
}
.

Associative_Term<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
= 
Associative_Factor<out node>
{
    (. Operator op; .)

    Associative_MulOp<out op> 
    (. ProtoCore.AST.AssociativeAST.AssociativeNode expr2; .)   

    Associative_Factor<out expr2>

    (.	
        node = GenerateBinaryOperatorMethodCallNode(op, node, expr2);
    .)
}
.

Associative_Level<out ProtoCore.AST.AssociativeAST.AssociativeNode node>               
=   (.  
        node = null; 
        int sign = 1;
    .)  
    (
        ident
        (.
            if(t.val[0] != 'L')
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }
            var level = t.val.Remove(0, 1);
            Int64 value;
            if (Int64.TryParse(level, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(-1*value);
            }
            else
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }

            NodeUtils.SetNodeLocation(node, t);
        .)
        |
        [
            '-' 
            (. 
                sign = -1; 
            .)
        ] number
        (.
            Int64 value;
            if (Int64.TryParse(t.val, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(sign*value);
            }
            else
            {
                errors.SemErr(t.line, t.col, String.Format(Resources.kInvalidListLevelName, t.val));
            }

            NodeUtils.SetNodeLocation(node, t);
        .)
    )
.

Associative_Number<out ProtoCore.AST.AssociativeAST.AssociativeNode node>               
=           
    (. 
        node = null; 
        int sign = 1;
        int line = ProtoCore.DSASM.Constants.kInvalidIndex; 
        int col = ProtoCore.DSASM.Constants.kInvalidIndex; 
    .) 
    [
        '-' 
        (. 
            sign = -1; 
            line = t.line; 
            col = t.col; 
        .)
    ]
    (
        number  
        (.  
            Int64 value;
            if (Int64.TryParse(t.val, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.IntNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.AssociativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex == line
                &&  ProtoCore.DSASM.Constants.kInvalidIndex == col)
            {
                NodeUtils.SetNodeLocation(node, t);
            }
            else
            {
                node.line = line; node.col = col;
				node.endLine = t.line; node.endCol = t.col;
            }
        .)
        | 
        float   
        (.  
            double value;
            if (Double.TryParse(t.val, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.AssociativeAST.DoubleNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.AssociativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex == line
                &&  ProtoCore.DSASM.Constants.kInvalidIndex == col)
            {
                NodeUtils.SetNodeLocation(node, t);
            }
            else
            {
                node.line = line; node.col = col;
            }
        .)
    )
.

Associative_Char<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=           (. node = null; .)
    char
            (. 
                if (t.val.Length <= 2) {
                    errors.SemErr(t.line, t.col, Resources.EmptyCharacterLiteral);
                }

                node = new ProtoCore.AST.AssociativeAST.CharNode() 
                { 
                    Value = t.val.Substring(1, t.val.Length - 2),
                    line = t.line,
                    col = t.col
                }; 
            .)
.

Associative_String<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=           (. node = null; .)
    textstring
            (. 
                node = new ProtoCore.AST.AssociativeAST.StringNode() 
                { 
                    Value = GetEscapedString(t.val.Length <= 2 ? "" : t.val.Substring(1, t.val.Length - 2)),
                }; 
                NodeUtils.SetNodeLocation(node, t);
            .)
.

Associative_Factor<out ProtoCore.AST.AssociativeAST.AssociativeNode node>           
                                    (.node = null; .)
=
    (
        (
            (IF(IsNumber())
                Associative_Number<out node>
            )
        )
        |
        (
            literal_true                    
            (.
                node = new ProtoCore.AST.AssociativeAST.BooleanNode(true);
                NodeUtils.SetNodeLocation(node, t);
            .)
        )
        |
        (
            literal_false                   
            (.
                node = new ProtoCore.AST.AssociativeAST.BooleanNode(false);
                NodeUtils.SetNodeLocation(node, t);
            .)
        )   
        |
        (
            literal_null                    (.
                                                node = new ProtoCore.AST.AssociativeAST.NullNode();
                                                NodeUtils.SetNodeLocation(node, t);
                                            .)
        )
        | 
        (
            Associative_Char<out node>
        )
        |
        (
            Associative_String<out node>
        )
        |
        (                                    
            Associative_IdentifierList<out node>            
        )
        |
        (
            Associative_UnaryExpression<out node>
        )
     )
 .


Associative_Ident<out ProtoCore.AST.AssociativeAST.AssociativeNode node> 
=
    ident   (. 
                if (!disableKwCheck && IsKeyWord(t.val, false, false))
                {
                    errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                }
                var identNode = AstFactory.BuildIdentifier(t.val);
                identNode.datatype = TypeSystem.BuildPrimitiveTypeObject(ProtoCore.PrimitiveType.Var);
                node = identNode;
                NodeUtils.SetNodeLocation(node, t);
            .)
.

Associative_ArrayExprList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
'{'                                     (. ProtoCore.AST.AssociativeAST.ExprListNode exprlist = new ProtoCore.AST.AssociativeAST.ExprListNode(); .)
                                        (. NodeUtils.SetNodeStartLocation(exprlist, t); .)
    [
                                        
        Associative_Expression<out node>            (. exprlist.Exprs.Add(node); .)
        {
            ','
            Associative_Expression<out node>        (. exprlist.Exprs.Add(node); .)
        }
                                        
    ]
'}'                                     (. NodeUtils.SetNodeEndLocation(exprlist, t); .)
                                        (. node = exprlist; .)
.

Associative_DictionaryExpression<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=
'{'                                     (. var dictBuilder = new ProtoCore.AST.AssociativeAST.DictionaryExpressionBuilder(); .)
                                        (. dictBuilder.SetNodeStartLocation(t); .)
    [
		(
			textstring	(. var str = new StringNode {Value = t.val.Trim('"')}; .)  
						(. dictBuilder.AddKey(str); .)
		)
		|
		(
			ident		(. var ident = new IdentifierNode(t.val); .)
						(. NodeUtils.SetNodeLocation(ident, t); .)
						(. dictBuilder.AddKey(ident); .)
		)
	]
	':'                     
	Associative_Expression<out node>            (. dictBuilder.AddValue(node); .)
	{
		','
		[
			(
				textstring	(. var str = new StringNode { Value = t.val.Trim('"') }; .)
							(. dictBuilder.AddKey(str); .)  
			)
			|
			(
				ident		(. var ident = new IdentifierNode(t.val); .)
							(. NodeUtils.SetNodeLocation(ident, t); .)
							(. dictBuilder.AddKey(ident); .)
			)
		]
		':'                     
		Associative_Expression<out node>            (. dictBuilder.AddValue(node); .)
	}
'}'                                     (. dictBuilder.SetNodeEndLocation(t); .)
                                        (. node = dictBuilder.ToFunctionCall(); .)
.

Associative_NameReference<ref ProtoCore.AST.AssociativeAST.AssociativeNode node>
= 
                                        (.
                                            ProtoCore.AST.AssociativeAST.ArrayNameNode nameNode = null; 
                                            ProtoCore.AST.AssociativeAST.GroupExpressionNode groupExprNode = null;
											ProtoCore.AST.AssociativeAST.ArrayNameNode qualifierNode = node as AST.AssociativeAST.ArrayNameNode;
                                        .)
    (
        (
            '('
            Associative_Expression<out node>
                                        (.
                                            if (node is ProtoCore.AST.AssociativeAST.ArrayNameNode)
                                            {
                                                nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                            }
                                            else
                                            {
                                                groupExprNode = new ProtoCore.AST.AssociativeAST.GroupExpressionNode();
                                                groupExprNode.Expression = node;
                                                nameNode = groupExprNode;
                                            }
                                        .) 
            ')'
        )
        |
        IF(IsFunctionCall())
        (                               (.
                                            if (isLeft)
                                            {
                                               errors.SemErr(la.line, la.col, Resources.FunctionCallCannotBeAtLeftSide);
                                            } 
                                        .)
            Associative_FunctionCall<out node>  
                                        (. 
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode; 
                                        .)
        )
        |
        (
            Associative_Ident<out node>         
                                        (. 
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode; 
                                        .)
        )
		|
		IF(IsDictionaryExpression())
        (
            Associative_DictionaryExpression<out node>
                                        (.
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                        .)
        )
        |
        (
            Associative_ArrayExprList<out node>
                                        (.
                                            nameNode = node as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                        .)
        )
    )

    [
										(. 
											ProtoCore.AST.AssociativeAST.ArrayNode array = null;
										.)
        openbracket             
        [
                                        (. 
                                            bool tmpIsLeft = isLeft; 
                                            isLeft = false;
                                        .)
            Associative_Expression<out node>
                                        (. 
											if (tmpIsLeft) {
												// if "foo[bar]" is on the lhs, it is interpreted as an array initialization expression
												array = new ProtoCore.AST.AssociativeAST.ArrayNode
												{
													Expr = node,
													Type = nameNode.ArrayDimensions
												};

												NodeUtils.SetNodeLocation(array, t);
												nameNode.ArrayDimensions = array;
											} else {
												if (qualifierNode != null)
												{
													ProtoCore.AST.AssociativeAST.IdentifierListNode inode = new ProtoCore.AST.AssociativeAST.IdentifierListNode();
													inode.LeftNode = qualifierNode;
													inode.Optr = Operator.dot;
													inode.RightNode = nameNode;
													NodeUtils.SetNodeLocation(inode, inode.LeftNode, inode.RightNode);
													nameNode = inode;
												}
												// if "foo[bar]" is on the rhs, it is interpreted as an lookup in an array or dictionary
												nameNode = AstFactory.BuildIndexExpression(nameNode, node) as ArrayNameNode;
											}

											isLeft = tmpIsLeft; 
                                        .)
        ]
        closebracket 
        { 
            openbracket
            [
                                        (. 
                                            bool tmpIsLeft = isLeft; 
                                            isLeft = false;
                                        .) 
                Associative_Expression<out node>
                                        (.
											if (tmpIsLeft) {
												var array2 = new ProtoCore.AST.AssociativeAST.ArrayNode
												{
													Expr = node,
													Type = null
												};

												NodeUtils.SetNodeLocation(array2, t);
												array.Type = array2;
												array = array2;
											} else {
												nameNode = AstFactory.BuildIndexExpression(nameNode, node) as ArrayNameNode;
											}

											isLeft = tmpIsLeft; 
                                        .)
            ]
            closebracket
        }
                                        (.
                                            if (groupExprNode != null)
                                            {
                                                var expr = groupExprNode.Expression;
                                                if (expr is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                                {
                                                    var rightNode = (expr as ProtoCore.AST.AssociativeAST.IdentifierListNode).RightNode;
                                                    if (rightNode is ProtoCore.AST.AssociativeAST.ArrayNameNode)
                                                    {
                                                        var rightMostArrayNameNode = rightNode as ProtoCore.AST.AssociativeAST.ArrayNameNode;
                                                        if (rightMostArrayNameNode.ArrayDimensions == null)
                                                        {
                                                            rightMostArrayNameNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                        }
                                                        else 
                                                        {
                                                            rightMostArrayNameNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                        }
                                                        groupExprNode.ArrayDimensions = null;
                                                    }
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.RangeExprNode)
                                                {    
                                                    var rangeExprNode = expr as ProtoCore.AST.AssociativeAST.RangeExprNode; 
                                                    if (rangeExprNode.ArrayDimensions == null)
                                                    {
                                                        rangeExprNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                    }
                                                    else 
                                                    {
                                                        rangeExprNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.ExprListNode)
                                                {    
                                                    var exprListNode = expr as ProtoCore.AST.AssociativeAST.ExprListNode; 
                                                    if (exprListNode.ArrayDimensions == null)
                                                    {
                                                        exprListNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                                    }
                                                    else 
                                                    {
                                                        exprListNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                                else if (expr is ProtoCore.AST.AssociativeAST.FunctionDotCallNode)
                                                {
                                                    var dotCall = expr as ProtoCore.AST.AssociativeAST.FunctionDotCallNode;
                                                    var arrayExpr = (dotCall.Arguments[2] as ProtoCore.AST.AssociativeAST.ExprListNode);
                                                    var dimCount = (dotCall.Arguments[3] as ProtoCore.AST.AssociativeAST.IntNode);

                                                    var dims = dimCount.Value;
                                                    var newdims = dims;

                                                    if (arrayExpr != null)
                                                    {
                                                        var newarray = groupExprNode.ArrayDimensions;
                                                        while (newarray != null)
                                                        {
                                                            arrayExpr.Exprs.Add(newarray.Expr);
                                                            newdims++;
                                                            newarray = (newarray.Type as ProtoCore.AST.AssociativeAST.ArrayNode);
                                                        }
                                                        
                                                        (dotCall.Arguments[3] as ProtoCore.AST.AssociativeAST.IntNode).Value = newdims;
                                                    }
                                                    groupExprNode.ArrayDimensions = null;
                                                }
                                            }
                                        .)
    ]
    
    [
                                        (. 
                                           AssociativeNode levelNode = null;
                                           bool isDominant = false;
                                        .)
        (
            list_at Associative_Level<out levelNode> 
            |
            dominant_list_at Associative_Level<out levelNode> (. isDominant = true; .)
        )
                                        (. 
                                            IntNode listAtLevel = levelNode as IntNode;
                                            if (listAtLevel != null)
                                            {
                                                var atLevel = new AtLevelNode { Level = listAtLevel.Value, IsDominant = isDominant };
                                                nameNode.AtLevel = atLevel; 
                                            }
                                        .)
    ]

    [ 
        IF(IsReplicationGuide())
        (
                                            (. var guides = new List<AssociativeNode>();.)
            lessthan
                                            (.
                                                string repguide = String.Empty;
                                                bool isLongest = false;
                                                ReplicationGuideNode repGuideNode = null;
                                            .)
       
            (IF(IsPostfixedReplicationGuide())
            (
                postfixed_replicationguide      (.  isLongest = true; .)
                )
                |
                (
                    number                      (.  isLongest = false; .)
                )
            )
                                                (.
                                                    repguide = t.val;
                                                    if (isLongest)
                                                    {
                                                        repguide = repguide.Remove(repguide.Length - 1);
                                                    }
                                                    var numNode = new IdentifierNode() { Value = repguide };
                                                    repGuideNode = new ReplicationGuideNode();
                                                    repGuideNode.RepGuide = numNode;
                                                    repGuideNode.IsLongest = isLongest;
                                                    NodeUtils.SetNodeLocation(numNode, t); 
                                                .)
            greaterthan                         (. guides.Add(repGuideNode); .)
            {                   
                lessthan
                (IF(IsPostfixedReplicationGuide())
                    (
                        postfixed_replicationguide  (.  isLongest = true; .)
                    )
                    |
                    (
                        number                      (.  isLongest = false; .)
                    )
                )
                                            (.
                                                    repguide = t.val;
                                                    if (isLongest)
                                                    {
                                                        repguide = repguide.Remove(repguide.Length - 1);
                                                    }
                                                    numNode = AstFactory.BuildIdentifier(repguide);
                                                    repGuideNode = new ReplicationGuideNode();
                                                    repGuideNode.RepGuide = numNode;
                                                    repGuideNode.IsLongest = isLongest;
                                                    NodeUtils.SetNodeLocation(numNode, t); 
                                            .)
                greaterthan                 (.  guides.Add(repGuideNode); .)
            }
                                            (. 
                                                nameNode.ReplicationGuides = guides; 
                                                if (groupExprNode != null)
                                                {
                                                    var expr = groupExprNode.Expression;
                                                    if (expr is IdentifierListNode)
                                                    {
                                                        var rightNode = (expr as IdentifierListNode).RightNode;
                                                        if (rightNode is ArrayNameNode)
                                                        {
                                                            var rightMostArrayNameNode = rightNode as ArrayNameNode;
                                                            if (rightMostArrayNameNode.ReplicationGuides == null)
                                                            {
                                                                rightMostArrayNameNode.ReplicationGuides = guides;
                                                            }
                                                            else
                                                            {
                                                                rightMostArrayNameNode.ReplicationGuides.InsertRange(0, guides);
                                                            }
                                                            groupExprNode.ReplicationGuides = null;
                                                        }
                                                    }
                                                    else if (expr is FunctionDotCallNode)
                                                    {
                                                        var functionCall = (expr as FunctionDotCallNode).FunctionCall;
                                                        var function = (functionCall.Function as ArrayNameNode);
                                                        if (function.ReplicationGuides == null)
                                                        {
                                                            function.ReplicationGuides = guides;
                                                        }
                                                        else
                                                        {
                                                            function.ReplicationGuides.InsertRange(0, guides);
                                                        }
                                                        groupExprNode.ReplicationGuides = null;
                                                    }
                                                }
                                            .)
        )
    ]
                                        (. 
                                            if (groupExprNode != null && groupExprNode.ArrayDimensions == null && (groupExprNode.ReplicationGuides == null || groupExprNode.ReplicationGuides.Count == 0))
                                            {
                                                node = groupExprNode.Expression;
                                            }
                                            else
                                            {
                                                node = nameNode; 
                                            }
                                        .)
.

Associative_IdentifierList<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                                   (. 
                                        node = null;
                                        if (isInClass && IsIdentList())
                                        {
                                            disableKwCheck = true;
                                        }
                                    .)

    Associative_NameReference<ref node> 
                                    (. 
                                        disableKwCheck = false; 
                                        ProtoCore.AST.AssociativeAST.AssociativeNode inode = node; 
                                    .)
    {
        '.'
                                    (. ProtoCore.AST.AssociativeAST.AssociativeNode rnode = node; .)

        Associative_NameReference<ref rnode>
                                    (.
                                        if ((inode is ProtoCore.AST.AssociativeAST.IdentifierNode) &&
                                            (inode as ProtoCore.AST.AssociativeAST.IdentifierNode).Name == ProtoCore.DSDefinitions.Keyword.This &&
                                            (rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode))
                                        {
                                            node = rnode;
                                            return;
                                        }

                                        
                                        ProtoCore.AST.AssociativeAST.IdentifierListNode bnode;

										ProtoCore.AST.AssociativeAST.IdentifierListNode idnode = rnode as ProtoCore.AST.AssociativeAST.IdentifierListNode;
										if (idnode != null && idnode.LeftNode.Name == "DesignScript.Builtin.Get")
										{
											bnode = idnode;
										}
										else
										{
											bnode = new ProtoCore.AST.AssociativeAST.IdentifierListNode();
											bnode.LeftNode = node;
											bnode.Optr = Operator.dot;
											bnode.RightNode = rnode;
											NodeUtils.SetNodeLocation(bnode, bnode.LeftNode, bnode.RightNode);
										}
										node = bnode;
                                        
                                        if (!core.Options.GenerateSSA)
                                        {
                                        bool isNeitherIdentOrFunctionCall = !(rnode is ProtoCore.AST.AssociativeAST.IdentifierNode || rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode);
                                        if (isLeft || isNeitherIdentOrFunctionCall)
                                        {
                                            node = inode;
                                        }
                                        else 
                                        {
                                            if (rnode is ProtoCore.AST.AssociativeAST.IdentifierNode)
                                            {
                                                ProtoCore.AST.AssociativeAST.FunctionCallNode rcall = new ProtoCore.AST.AssociativeAST.FunctionCallNode();
                                                rcall.Function = rnode;
                                                rcall.Function.Name = ProtoCore.DSASM.Constants.kGetterPrefix + rcall.Function.Name;
                                                bnode.RightNode = rcall;

                                                NodeUtils.SetNodeLocation(rcall, rnode, rnode);
                                                node = ProtoCore.Utils.CoreUtils.GenerateCallDotNode(bnode.LeftNode, rcall, core);
                                            }
                                            else
                                            {
                                                string rhsName = null;
                                                ProtoCore.AST.AssociativeAST.ExprListNode dimList = null;
                                                int dim = 0;
                                                if (rnode is ProtoCore.AST.AssociativeAST.FunctionCallNode)
                                                {
                                                    ProtoCore.AST.AssociativeAST.FunctionCallNode rhsFNode = rnode as ProtoCore.AST.AssociativeAST.FunctionCallNode;
                                                    node = ProtoCore.Utils.CoreUtils.GenerateCallDotNode(node, rhsFNode, core);
                                                }
                                            }
                                        }
        }
                                    .)
    }

                                    (.  
                                        //if (!core.Options.GenerateSSA)
                                        {
                                            if (!isModifier && withinModifierCheckScope)
                                            {
                                                if (isLeftVarIdentList)
                                                {
                                                    if (inode is ProtoCore.AST.AssociativeAST.IdentifierListNode)
                                                    {
                                                        isModifier = false;
                                                        if (node is ProtoCore.AST.AssociativeAST.FunctionDotCallNode)
                                                        {
                                                            ProtoCore.AST.AssociativeAST.FunctionDotCallNode fdotCall = node as ProtoCore.AST.AssociativeAST.FunctionDotCallNode;
                                                            string checkVar = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(fdotCall.GetIdentList());
                                                            isModifier = (leftVar == checkVar);
                                                        }
                                                    }
                                                }
                                                else if (inode is ProtoCore.AST.AssociativeAST.IdentifierNode)
                                                {
                                                    isModifier = (leftVar == inode.Name);
                                                }   

                                                // The LHS is an identifier
                                                else
                                                {
                                                    // It is a modifier if the lhs is:
                                                    //   1. the same as the current node
                                                    //   2. the current node starts with the lhs identifier
                                                    isModifier = (leftVar == inode.Name);
                                                    if (!isModifier)
                                                    {
                                                        string rhsString = ProtoCore.Utils.CoreUtils.GenerateIdentListNameString(inode);

                                                        isModifier = rhsString.StartsWith(leftVar);
                                                    }
                                                }
                                            }
                                        }
                                    .)
.



Associative_FunctionCall<out ProtoCore.AST.AssociativeAST.AssociativeNode node>
=                                   (. ProtoCore.AST.AssociativeAST.FunctionCallNode f = new ProtoCore.AST.AssociativeAST.FunctionCallNode(); .)
    Associative_Ident<out node>     (. NodeUtils.SetNodeStartLocation(f, t); .)
                                    (. List<ProtoCore.AST.AssociativeAST.AssociativeNode> args = null; .)
    Associative_Arguments<out args> (.                                      
                                        f.FormalArguments = args;
                                        f.Function = node;
                                        NodeUtils.SetNodeEndLocation(f, t);
                                        node = f; 
                                    .)
.


Associative_Arguments<.out List<ProtoCore.AST.AssociativeAST.AssociativeNode> nodes.>
=                                           
    '('										(. if (!IsFullClosure()) SynErr(Resources.CloseBracketExpected); .)
                                            (. nodes = new List<ProtoCore.AST.AssociativeAST.AssociativeNode>(); .)
        [
                                            (. ProtoCore.AST.AssociativeAST.AssociativeNode t; .)
            Associative_Expression<out t>               (. nodes.Add(t); .)
            {
                WEAK ','                            
                Associative_Expression<out t>           (. nodes.Add(t); .)                         
            }
        ]
                        
    ')'
.  
//------------------------------Imperative-----------------------------------//
Imperative<out Node codeBlockNode> 
=   
                            (.
                                ProtoCore.AST.ImperativeAST.ImperativeNode node = null; 
                                ProtoCore.AST.ImperativeAST.CodeBlockNode codeblock = new ProtoCore.AST.ImperativeAST.CodeBlockNode();
                                NodeUtils.SetNodeStartLocation(codeblock, t);
                            .)
    {
        Imperative_stmt<out node>
                            (.  if (null != node)   
                                    codeblock.Body.Add(node); 
                            .)
    }                       (.
                                codeBlockNode = codeblock;

                                // We look ahead (la) here instead of looking at the current token (t)
                                // because when we get here at the end of a language block, "t" would 
                                // have been pointing to the ending token of the last statement in the 
                                // language block. What we really need here is the closing bracket '}'
                                // character, and that's conveniently residing in the look ahead token.
                                // 
                                NodeUtils.SetNodeEndLocation(codeblock, la);
                            .)
.

Imperative_languageblock<out ProtoCore.AST.ImperativeAST.ImperativeNode node>           
=                                       
                                        (. 
                                            node = null; 
                                            ProtoCore.AST.ImperativeAST.LanguageBlockNode langblock = new ProtoCore.AST.ImperativeAST.LanguageBlockNode(); 
                                        .)  
    openbracket                         (. NodeUtils.SetNodeLocation(langblock, t); .)
    ident
                                        (.
                                            if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.imperative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Imperative;
                                            }
                                            else if( 0 == t.val.CompareTo(ProtoCore.DSASM.kw.associative)) {
                                                langblock.codeblock.Language = ProtoCore.Language.Associative; 
                                            }
                                            else {
                                                langblock.codeblock.Language = ProtoCore.Language.NotSpecified; 
                                                errors.SemErr(t.line, t.col, String.Format(Resources.InvalidLanguageBlockIdentifier, t.val));
                                            }
                                        .)
    closebracket                        
    '{'                      (. Node codeBlockNode = null; .)
    (
    IF( langblock.codeblock.Language == ProtoCore.Language.Associative ||
        langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
    Hydrogen<out codeBlockNode>              
    |    
    IF( langblock.codeblock.Language == ProtoCore.Language.Imperative )
    Imperative<out codeBlockNode>              
    )
    (
    IF( langblock.codeblock.Language == ProtoCore.Language.NotSpecified)
                                            (. int openCurlyBraceCount = 0, closeCurlyBraceCount = 0; .)
                                            (. ProtoCore.AST.ImperativeAST.CodeBlockNode codeBlockInvalid = new ProtoCore.AST.ImperativeAST.CodeBlockNode(); .)
                                            (. ProtoCore.AST.ImperativeAST.ImperativeNode validBlockInInvalid = null; .)
    {
    IF (closeCurlyBraceCount <= openCurlyBraceCount) 
    (                                                                           
        Imperative_languageblock<out validBlockInInvalid>     (. codeBlockInvalid.Body.Add(validBlockInInvalid); .)
        |       
        '{'                                 (. openCurlyBraceCount++; .)
        |
        '}'                                 (. closeCurlyBraceCount++; .)
        |
        EOF
        '}'                                 (. break; .)                      
        |
                                            (. Get(); .)
    )
    }                                      
                                            (. codeBlockNode = codeBlockInvalid; .)
    |
    '}' 
    )                                       (. langblock.CodeBlockNode = codeBlockNode; .)                                          
                                            (. node = langblock; .) 
. 

Imperative_stmt<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
                                (. node = null; .)
    (
        Imperative_ifstmt<out node>
        |
        Imperative_whilestmt<out node>
        |
        Imperative_forloop<out node>
        |
        Imperative_languageblock<out node>      
        |
        (
            kw_break 
            (.
                if (la.kind != _endline)
                    SynErr(Resources.SemiColonExpected);
            .)
            endline
        )     (. node = new ProtoCore.AST.ImperativeAST.BreakNode(); NodeUtils.SetNodeLocation(node, t); .)
        |
        (
            kw_continue 
            (.
                if (la.kind != _endline)
                   SynErr(Resources.SemiColonExpected);
            .)
            endline
        )  (. node = new ProtoCore.AST.ImperativeAST.ContinueNode(); NodeUtils.SetNodeLocation(node, t); .)
        |
		Imperative_returnstmt<out node>
		|
        (IF(IsAssignmentStatement() || IsVariableDeclaration())
            Imperative_assignstmt<out node>
        )
        |
        ( 
            Imperative_expr<out node> 
            (.
                if (la.kind != _endline)
                   SynErr(Resources.SemiColonExpected);
            .)
            endline
        )
        |
        (
            (.
                if (la.kind != _endline)
                   SynErr(Resources.SemiColonExpected);
            .)
            endline 
        )
    )   
.

Imperative_returnstmt<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
    (.
		node = null;
        var bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
        NodeUtils.SetNodeLocation(bNode, la);
	.)
	"return"
	[
		'='
	]
	(.
		var lhs = BuildImperativeIdentifier("return", ProtoCore.PrimitiveType.Return);
		bNode.LeftNode = lhs;

		ProtoCore.AST.ImperativeAST.ImperativeNode rhs = null;
	.)

	(
	Imperative_languageblock<out rhs>
	|
	Imperative_expr<out rhs>
    (.
        if (la.kind != _endline)
            SynErr(Resources.SemiColonExpected);
    .)
    endline
	)
	(.
        bNode.RightNode = rhs;
        bNode.Optr = Operator.assign;

		node = bNode;
	.)
.

Imperative_stmtlist<.out List<ProtoCore.AST.ImperativeAST.ImperativeNode> nodelist.> 
=
                    (. nodelist = new List<ProtoCore.AST.ImperativeAST.ImperativeNode>(); .)
{ 
                    (. ProtoCore.AST.ImperativeAST.ImperativeNode node = null; .)
    Imperative_stmt<out node>   (. if (node != null) nodelist.Add(node); .)
}
.

Imperative_decoratedIdentifier<out ProtoCore.AST.ImperativeAST.ImperativeNode node>         
=                                   (. node = null; .)
    (                                   
        
            ( IF (IsLocallyTypedVariable())
                ident               (. 
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        var typedVar = new ProtoCore.AST.ImperativeAST.TypedIdentifierNode();
                                        typedVar.Name = typedVar.Value = t.val;
                                        NodeUtils.SetNodeLocation(typedVar, t);
                                    .)
                ':'
                
                
                kw_local        (.
                                    typedVar.IsLocal = true;
                                .)
                

                ident
                                    (. 
                                       int type = core.TypeSystem.GetType(t.val); 
                                       if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
                                       {
                                           var unknownType = new ProtoCore.Type();
                                           unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
                                           unknownType.Name = t.val; 
                                           typedVar.DataType = unknownType;
                                       }
                                       else
                                       {
                                           typedVar.DataType = core.TypeSystem.BuildTypeObject(type, 0);
                                       }
                                    .)

                [                   (. var datatype = typedVar.DataType; .)
                    openbracket closebracket    
                                    (. datatype.rank = 1; .)
                    [
                        ( ".." openbracket closebracket )   
                                    (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                        |
                        ( 
                            {
                                openbracket closebracket    
                                    (. datatype.rank++; .)
                            } 
                        )
                    ]
                                    (. typedVar.DataType = datatype; .)
                ]
                                    (. node = typedVar; .)

            )
            |
            (IF (IsLocalVariable())
            (      
                ident       (.  
                                    if (IsKeyWord(t.val, true))
                                    {
                                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                    }
                                    var identNode = new ProtoCore.AST.ImperativeAST.IdentifierNode();
                                    identNode.Name = identNode.Value = t.val;
                                    NodeUtils.SetNodeLocation(identNode, t);
                                .)
                ':' 
                kw_local            (.
                                        identNode.IsLocal = true;
                                    .)
                                    (.  node = identNode; .)
            )
            )
            |
            ( IF (IsTypedVariable())
                ident               (. 
                                        if (IsKeyWord(t.val, true))
                                        {
                                            errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                                        }
                                        var typedVar = new ProtoCore.AST.ImperativeAST.TypedIdentifierNode();
                                        typedVar.Name = typedVar.Value = t.val;
                                        NodeUtils.SetNodeLocation(typedVar, t);
                                    .)
                ':'
                

                ident
                                    (. 
                                       int type = core.TypeSystem.GetType(t.val); 
                                       if (type == ProtoCore.DSASM.Constants.kInvalidIndex)
                                       {
                                           var unknownType = new ProtoCore.Type();
                                           unknownType.UID = ProtoCore.DSASM.Constants.kInvalidIndex;
                                           unknownType.Name = t.val; 
                                           typedVar.DataType = unknownType;
                                       }
                                       else
                                       {
                                           typedVar.DataType = core.TypeSystem.BuildTypeObject(type, 0);
                                       }
                                    .)

                [                   (. var datatype = typedVar.DataType; .)
                    openbracket closebracket    
                                    (. datatype.rank = 1; .)
                    [
                        ( ".." openbracket closebracket )   
                                    (. datatype.rank = ProtoCore.DSASM.Constants.nDimensionArrayRank; .)
                        |
                        ( 
                            {
                                openbracket closebracket    
                                    (. datatype.rank++; .)
                            } 
                        )
                    ]
                                    (. typedVar.DataType = datatype; .)
                ]
                                    (. node = typedVar; .)

            )


            |
            Imperative_IdentifierList<out node>
        
    )
.

Imperative_assignstmt<out ProtoCore.AST.ImperativeAST.ImperativeNode node>      
                        (. node = null; .)
=                       (. 
                            ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                            ProtoCore.AST.ImperativeAST.ImperativeNode lhsNode = null; 
                            NodeUtils.SetNodeLocation(bNode, la);
							isLeft = true;
                        .)
    (   
        Imperative_decoratedIdentifier<out lhsNode>
    )
                        (. 
							isLeft = false;
							node = lhsNode; 
						.)

    (
        endline
                        (.
                            bNode.LeftNode = lhsNode;
                            bNode.RightNode = null;
                            bNode.Optr = Operator.assign;
                            NodeUtils.SetNodeEndLocation(bNode, t);
                            node = bNode; 
                        .)
        |
        (
            '='     
            (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode = null; .)
            (   
                ( 
                    IF(HasMoreAssignmentStatements())
                        Imperative_assignstmt<out rhsNode>
                )
                |        
                (
                    Imperative_expr<out rhsNode>        
                    (.
                        if (la.kind != _endline)
                           SynErr(Resources.SemiColonExpected);
                    .)
                    endline
                )
                |
                (
                    Imperative_languageblock<out rhsNode>       
                )
            )
            (.
                bNode.LeftNode = lhsNode;
                bNode.RightNode = rhsNode;
                bNode.Optr = Operator.assign;
                NodeUtils.SetNodeEndLocation(bNode, t);
                node = bNode;       
            .)                                      
        )
        |
        (
            (. SynErr("';' is expected"); .)
        )
    )
.   

Imperative_ifstmt<out ProtoCore.AST.ImperativeAST.ImperativeNode node>  
= 
                                    (. ProtoCore.AST.ImperativeAST.IfStmtNode ifStmtNode = new ProtoCore.AST.ImperativeAST.IfStmtNode(); .)
                                    (. List<ProtoCore.AST.ImperativeAST.ImperativeNode> body = null; .)
    kw_if                           (. NodeUtils.SetNodeLocation(ifStmtNode, t); .)
    '('											
        Imperative_expr<out node>               (. ifStmtNode.IfExprNode = node; .)                 
    ')'                                         (. 
                                                    NodeUtils.SetNodeStartLocation(ifStmtNode.IfExprNode, ifStmtNode);
                                                    NodeUtils.SetNodeEndLocation(ifStmtNode.IfExprNode, t);
                                                    NodeUtils.SetNodeStartLocation(ifStmtNode.IfBodyPosition, la);
                                                .)
    (           
        (
            '{'                         
                Imperative_stmtlist<out body>           (. ifStmtNode.IfBody = body; .) 
            '}'
        )
        |
        (                           (. ProtoCore.AST.ImperativeAST.ImperativeNode singleStmt; .)
            Imperative_stmt<out singleStmt> (. ifStmtNode.IfBody.Add(singleStmt); .)
        )
    )								(. NodeUtils.SetNodeEndLocation(ifStmtNode.IfBodyPosition, t); .)
     
    { 
                                    (. ProtoCore.AST.ImperativeAST.ElseIfBlock elseifBlock = new ProtoCore.AST.ImperativeAST.ElseIfBlock(); .)
        kw_elseif                   (. int line = t.line; int col = t.col; .)
        '('						
            Imperative_expr<out node>           
        ')'							(.
                                        elseifBlock.Expr = node;
                                        elseifBlock.Expr.line = line;
                                        elseifBlock.Expr.col = col;
                                        NodeUtils.SetNodeEndLocation(elseifBlock.Expr, t);
                                        NodeUtils.SetNodeStartLocation(elseifBlock.ElseIfBodyPosition, la);
                                    .)
        (
            (    
                '{' 
                    Imperative_stmtlist<out body>       (.  elseifBlock.Body = body; .)         
                '}' 
            )
            |
            (                       (. ProtoCore.AST.ImperativeAST.ImperativeNode singleStmt = null; .)
                Imperative_stmt<out singleStmt>(. elseifBlock.Body.Add(singleStmt); .)
            )

        )							(. NodeUtils.SetNodeEndLocation(elseifBlock.ElseIfBodyPosition, t); .)
                                    (. ifStmtNode.ElseIfList.Add(elseifBlock); .)
    } 

    [ 
        kw_else                             (. NodeUtils.SetNodeStartLocation(ifStmtNode.ElseBodyPosition, la); .)
        (
            ( 
                '{'
                    Imperative_stmtlist<out body>       (. ifStmtNode.ElseBody = body; .)                 
                '}' 
            )
            |
            (                               (. ProtoCore.AST.ImperativeAST.ImperativeNode singleStmt = null; .)
                Imperative_stmt<out singleStmt>     (. ifStmtNode.ElseBody.Add(singleStmt); .)
            )
        )												(. NodeUtils.SetNodeEndLocation(ifStmtNode.ElseBodyPosition, t); .)
    ]    
                                    (. node = ifStmtNode; .)                        
.

Imperative_whilestmt<out ProtoCore.AST.ImperativeAST.ImperativeNode node>  
= 
                                    (. ProtoCore.AST.ImperativeAST.WhileStmtNode whileStmtNode = new ProtoCore.AST.ImperativeAST.WhileStmtNode(); .)
                                    (. List<ProtoCore.AST.ImperativeAST.ImperativeNode> body = null; .)
        kw_while                    (. NodeUtils.SetNodeStartLocation(whileStmtNode, t); .)
        '(' 
            Imperative_expr<out node>                              
        ')'                         (.
                                        whileStmtNode.Expr = node; 
                                        NodeUtils.SetNodeStartLocation(whileStmtNode.Expr, whileStmtNode);
                                        NodeUtils.SetNodeEndLocation(whileStmtNode.Expr, t);
                                    .)
        '{'
            Imperative_stmtlist<out body>       (. whileStmtNode.Body = body; .)                  
        '}'                         
                                    (. 
                                       NodeUtils.SetNodeEndLocation(whileStmtNode, t);
                                       node = whileStmtNode;
                                    .)

.
Imperative_forloop<out ProtoCore.AST.ImperativeAST.ImperativeNode forloop>
=
                                        (. 
                                            ProtoCore.AST.ImperativeAST.ImperativeNode node;
                                            ProtoCore.AST.ImperativeAST.ForLoopNode loopNode = new ProtoCore.AST.ImperativeAST.ForLoopNode();
                                            List<ProtoCore.AST.ImperativeAST.ImperativeNode> body = null;   
                                        .)
        kw_for                          (. NodeUtils.SetNodeLocation(loopNode, t); loopNode.KwForLine = t.line; loopNode.KwForCol = t.col; .)
        '('												(. int idLine = la.line; int idCol = la.col; .)
            Imperative_Ident<out node>             (. loopNode.LoopVariable = node; loopNode.LoopVariable.line = idLine; loopNode.LoopVariable.col = idCol; .)   
        "in"							(. loopNode.KwInLine = t.line; loopNode.KwInCol = t.col; int exprLine = la.line; int exprCol = la.col; .)
            Imperative_expr<out node>               (. loopNode.Expression = node; if (loopNode.Expression != null) {  loopNode.Expression.line = exprLine; loopNode.Expression.col = exprCol; } .)
        ')'
        (
            (
                '{'                                         
                Imperative_stmtlist<out body>   
                    (.  loopNode.Body = body; .)
                '}'

                    (.  NodeUtils.SetNodeEndLocation(loopNode, t); .)
            )
            |
            (                               (. ProtoCore.AST.ImperativeAST.ImperativeNode singleStmt = null; .)
                Imperative_stmt<out singleStmt>     (. loopNode.Body.Add(singleStmt); .)
            )
        )                                                   
        (.
            forloop = loopNode;
        .)
.


Imperative_expr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>        
=                       (. node = null; .)  
    (
        Imperative_binexpr<out node>                            
    )
    {
        Imperative_TernaryOp<ref node>
    }
.

Imperative_TernaryOp<ref ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
                                            (. ProtoCore.AST.ImperativeAST.InlineConditionalNode inlineConNode = new ProtoCore.AST.ImperativeAST.InlineConditionalNode(); .)
        "?"                                 (. inlineConNode.ConditionExpression = node; node = null; .)
        Imperative_expr<out node>           (. inlineConNode.TrueExpression = node; .)
        ":"                                 (. node = null; .)
        Imperative_expr<out node>           (. inlineConNode.FalseExpression = node; .)
                                            (. node = inlineConNode; .)
.

Imperative_IdentifierList<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=                                       (. node = null; .)
                                        (. if (isInClass && IsIdentList())
                                          disableKwCheck = true;
                                        .)
    Imperative_NameReference<ref node>  (. disableKwCheck = false; .)
    {
        '.'                             (. ProtoCore.AST.ImperativeAST.ImperativeNode rnode = node; .)              
        Imperative_NameReference<ref rnode>
                                        (.
                                            ProtoCore.AST.ImperativeAST.IdentifierListNode inode = rnode as ProtoCore.AST.ImperativeAST.IdentifierListNode;
											ProtoCore.AST.ImperativeAST.IdentifierListNode bnode;
											if (inode != null && inode.LeftNode.Name == "DesignScript.Builtin.Get")
											{
												bnode = inode;
											}
											else
											{
													bnode = new ProtoCore.AST.ImperativeAST.IdentifierListNode();
													bnode.LeftNode = node;
													bnode.Optr = Operator.dot;
													bnode.RightNode = rnode;
													NodeUtils.SetNodeLocation(bnode, bnode.LeftNode, bnode.RightNode);
											}

                                            if (bnode.RightNode is ProtoCore.AST.ImperativeAST.FunctionCallNode)
                                            {
                                                // We want the entire "Point.Project()" to be highlighted, 
                                                // not just "Project()". So if the RHS is a function call node,
                                                // then the identifier list should be extended to include both 
                                                // LeftNode and RightNode (which is the entire 'bnode' here).
                                                NodeUtils.CopyNodeLocation(bnode.RightNode, bnode);
                                            }
                                            node = bnode; 
                                        .)
    }                                       
.   

Imperative_unaryexpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=                       (. node = null; .)
    (
        (
            Imperative_negexpr<out node>
        )
    |
        (
            Imperative_bitunaryexpr<out node>
        )
    )
.

Imperative_bitunaryexpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.ImperativeAST.ImperativeNode exprNode; .)
    Imperative_unaryop<out op>      (. .)
    Imperative_factor<out exprNode>
                            (. 
                            ProtoCore.AST.ImperativeAST.UnaryExpressionNode unary = new ProtoCore.AST.ImperativeAST.UnaryExpressionNode(); 
                            unary.Operator = op;                            
                            unary.Expression = exprNode;
                            NodeUtils.SetNodeLocation(unary, t);
                            node = unary;
                        .)
.

Imperative_negexpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=                       (. node = null; .)
                        (. UnaryOperator op; .)
                        (. ProtoCore.AST.ImperativeAST.ImperativeNode exprNode = null; .)
    Imperative_negop<out op>
    Imperative_IdentifierList<out exprNode>
                        (. 
                            ProtoCore.AST.ImperativeAST.UnaryExpressionNode unary = new ProtoCore.AST.ImperativeAST.UnaryExpressionNode(); 
                            unary.Operator = op;
                            unary.Expression = exprNode;
                            NodeUtils.SetNodeLocation(unary, t);
                            node = unary;
                        .)
.

Imperative_binexpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>         
=                           
                                (. node = null;.)                               
    Imperative_logicalexpr<out node>  
    {       
                                (. Operator op; .)
        Imperative_logicalop<out op>
                                (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode = null; .)    
        Imperative_logicalexpr<out rhsNode> 
                                (. 
                                    ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                                    bNode.LeftNode = node;
                                    bNode.RightNode = rhsNode;
                                    bNode.Optr = op;
                                    NodeUtils.CopyNodeLocation(bNode, node);
                                    node = bNode;
                                .)                  
    }
.

Imperative_logicalexpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>         
=                           
                                (. node = null;.)                               
    Imperative_RangeExpr<out node>  
    {       
                                (. Operator op; .)
        Imperative_relop<out op>
                                (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode = null; .)    
        Imperative_RangeExpr<out rhsNode>   
                                (. 
                                    ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                                    bNode.LeftNode = node;
                                    bNode.RightNode = rhsNode;
                                    bNode.Optr = op;
                                    NodeUtils.SetNodeLocation(bNode, bNode.LeftNode, bNode.RightNode);
                                    node = bNode;
                                .)                  
    }
.

Imperative_RangeExpr<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
Imperative_rel<out node>
[
                                    (.  ProtoCore.AST.ImperativeAST.RangeExprNode rnode = new ProtoCore.AST.ImperativeAST.RangeExprNode(); 
                                        rnode.From = node;
                                        NodeUtils.SetNodeStartLocation(rnode, rnode.From);
                                        bool hasAmountOperator = false;
                                    .)
    rangeop
    [Imperative_rangeAmountOperator<out hasAmountOperator>]
                                    (. rnode.HasRangeAmountOperator = hasAmountOperator; .)
    Imperative_rel<out node>                    (.
                                                    rnode.To = node;
                                                    NodeUtils.SetNodeEndLocation(rnode, rnode.To);
                                                .)
    [                                           (. RangeStepOperator op; .)
        rangeop
        Imperative_rangeStepOperator<out op>    (. rnode.StepOperator = op; .)  
        Imperative_rel<out node>                (.
                                                    rnode.Step = node;
                                                    NodeUtils.SetNodeEndLocation(rnode, rnode.Step);
                                                .)
    ]                                           (. node = rnode; .)
]
.

Imperative_rel<out ProtoCore.AST.ImperativeAST.ImperativeNode node>         
=       
                                (. node = null;.)                               
    Imperative_term<out node>           
    {       
                                (. Operator op; .)
        Imperative_addop<out op>
                                (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode; .)   
        Imperative_term<out rhsNode>    
                                (. 
                                    ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                                    bNode.LeftNode = node;
                                    bNode.RightNode = rhsNode;
                                    bNode.Optr = op;
                                    NodeUtils.SetNodeLocation(bNode, bNode.LeftNode, bNode.RightNode);
                                    node = bNode;
                                .)                  
    }
.

Imperative_term<out ProtoCore.AST.ImperativeAST.ImperativeNode node>        
=           
                                (. node = null;.)               
    (. #if ENABLE_BIT_OP .)
    Imperative_interimfactor<out node> 
    (. #else             .)
    Imperative_factor<out node>
    (. #endif            .)
    { 
                                (. Operator op; .)
        Imperative_mulop<out op>
                                (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode; .)   
        (. #if ENABLE_BIT_OP .)
        Imperative_interimfactor<out rhsNode>                   
        (. #else             .)
        Imperative_factor<out rhsNode>
        (. #endif            .)
        
                                (. 
                                    ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                                    bNode.LeftNode = node;
                                    bNode.RightNode = rhsNode;
                                    bNode.Optr = op;
                                    NodeUtils.CopyNodeLocation(bNode, node);
                                    node = bNode;
                                .)
                
    }
.

Imperative_interimfactor<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
                            (. node = null;.)               
    Imperative_factor<out node> 
    { 
                                (. Operator op; .)
        Imperative_bitop<out op>
                                (. ProtoCore.AST.ImperativeAST.ImperativeNode rhsNode; .)   
        Imperative_factor<out rhsNode>                  
        
                                (. 
                                    ProtoCore.AST.ImperativeAST.BinaryExpressionNode bNode = new ProtoCore.AST.ImperativeAST.BinaryExpressionNode();
                                    bNode.LeftNode = node;
                                    bNode.RightNode = rhsNode;
                                    bNode.Optr = op;
                                    NodeUtils.CopyNodeLocation(bNode, node);
                                    node = bNode;
                                .)
                
    }
.

Imperative_Char<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
                    (. node = null; .)
=
    char            (. 
                        if (t.val.Length <= 2) {
                            errors.SemErr(t.line, t.col, Resources.EmptyCharacterLiteral);
                        }

                        node = new ProtoCore.AST.ImperativeAST.CharNode() 
                        { 
                            Value = t.val.Substring(1, t.val.Length - 2),
                            line = t.line,
                            col = t.col
                        }; 
                    .)
.

Imperative_String<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
                    (. node = null; .)
=
    textstring      (. 
                        node = new ProtoCore.AST.ImperativeAST.StringNode() 
                        { 
                            Value = GetEscapedString(t.val.Length <= 2 ? "" : t.val.Substring(1, t.val.Length - 2)), 
                            line = t.line,
                            col = t.col
                        }; 
                    .)
.
        
Imperative_factor<out ProtoCore.AST.ImperativeAST.ImperativeNode node>      
                    (. node = null; .)
=   
    (
        ( IF (IsNumber())
            Imperative_num<out node>                        
        )
    )    
    |
    (
        Imperative_Char<out node>
    )
    |
    (
        Imperative_String<out node>
    )
    |
    (
        literal_true            
        (. 
            node = new ProtoCore.AST.ImperativeAST.BooleanNode(true);
            NodeUtils.SetNodeLocation(node, t); 
        .)
    )
    |
    (
        literal_false           
        (. 
            node = new ProtoCore.AST.ImperativeAST.BooleanNode(false); 
            NodeUtils.SetNodeLocation(node, t); 
        .)
    )   
    |
    (
        literal_null            
        (. 
            node = new ProtoCore.AST.ImperativeAST.NullNode(); 
            NodeUtils.SetNodeLocation(node, t); 
        .)
    )
    |
    (
        Imperative_IdentifierList<out node>
    )
    |   
    (
        Imperative_unaryexpr<out node>
    )
.

Imperative_functioncall<out ProtoCore.AST.ImperativeAST.ImperativeNode node>    
=                               
    ident                           (. ProtoCore.AST.ImperativeAST.IdentifierNode function = new ProtoCore.AST.ImperativeAST.IdentifierNode() { Value = t.val, Name = t.val }; .)
                                    (. NodeUtils.SetNodeLocation(function, t); .)
                                    (. List<ProtoCore.AST.ImperativeAST.ImperativeNode> arglist = new List<ProtoCore.AST.ImperativeAST.ImperativeNode>(); .)
    '(' 
        [
                                    (. ProtoCore.AST.ImperativeAST.ImperativeNode argNode; .)
            Imperative_expr<out argNode>        (. arglist.Add(argNode); .)         
            { 
                ',' 
                Imperative_expr<out argNode>    (. arglist.Add(argNode); .)     
            }
        ] 
    ')' 
                                    (.
                                        ProtoCore.AST.ImperativeAST.FunctionCallNode funcNode = new ProtoCore.AST.ImperativeAST.FunctionCallNode(); 
                                        funcNode.Function = function;
                                        funcNode.FormalArguments = arglist;
                                        NodeUtils.SetNodeStartLocation(funcNode, function);
                                        NodeUtils.SetNodeEndLocation(funcNode, t);
                                        node = funcNode; 
                                    .)
.

Imperative_Ident<out ProtoCore.AST.ImperativeAST.ImperativeNode node> 
=               
    ident       (. 
                    if (!disableKwCheck && IsKeyWord(t.val, false, false))
                    {
                        errors.SemErr(t.line, t.col, String.Format(Resources.keywordCantBeUsedAsIdentifier, t.val));
                    }
                    node = BuildImperativeIdentifier(t.val, ProtoCore.PrimitiveType.Var);
                    NodeUtils.SetNodeLocation(node, t);
                .)
.

Imperative_NameReference<ref ProtoCore.AST.ImperativeAST.ImperativeNode node> 
= 
                                    (.
                                        ProtoCore.AST.ImperativeAST.ArrayNameNode nameNode = null;
                                        ProtoCore.AST.ImperativeAST.GroupExpressionNode groupExprNode = null;
										ProtoCore.AST.ImperativeAST.ArrayNameNode qualifierNode = node as AST.ImperativeAST.ArrayNameNode;
                                    .)
    (
        (
            '('
            Imperative_expr<out node>
            ')'
                                    (.
                                        if (node is ProtoCore.AST.ImperativeAST.ArrayNameNode)
                                        {
                                            nameNode = node as ProtoCore.AST.ImperativeAST.ArrayNameNode;
                                        }
                                        else
                                        {
                                            groupExprNode = new ProtoCore.AST.ImperativeAST.GroupExpressionNode();
                                            groupExprNode.Expression = node;
                                            nameNode = groupExprNode; 
                                        }
                                    .)
        )
        |
        IF(IsFunctionCall())
        (
            Imperative_functioncall<out node>
                                    (.
                                        nameNode = node as ProtoCore.AST.ImperativeAST.ArrayNameNode;
                                    .)
        )
        |
        (
            Imperative_Ident<out node>  
                                    (.
                                        nameNode = node as ProtoCore.AST.ImperativeAST.ArrayNameNode;
                                    .)
        )
        |
		IF(IsDictionaryExpression())
        (
            Imperative_DictionaryExpression<out node>
                                    (.
                                        nameNode = node as ProtoCore.AST.ImperativeAST.ArrayNameNode;
                                    .)
        )
        |
        (
            Imperative_ExprList<out node>
                                    (.
                                        nameNode = node as ProtoCore.AST.ImperativeAST.ArrayNameNode;
                                    .)
        )
    )

    [
		(. ProtoCore.AST.ImperativeAST.ArrayNode array = null; .)
        openbracket                  
        [                        
		                            (. 
                                        bool tmpIsLeft = isLeft; 
                                        isLeft = false;
                                    .)
            Imperative_expr<out node>   
                                    (. 
										if (tmpIsLeft) {
											// if "foo[bar]" is on the lhs, it is interpreted as an array initialization expression
											array = new ProtoCore.AST.ImperativeAST.ArrayNode
											{
												Expr = node,
												Type = nameNode.ArrayDimensions
											};

											NodeUtils.SetNodeLocation(array, t);
											nameNode.ArrayDimensions = array;
										} else {
											if (qualifierNode != null)
											{
												ProtoCore.AST.ImperativeAST.IdentifierListNode inode = new ProtoCore.AST.ImperativeAST.IdentifierListNode();
												inode.LeftNode = qualifierNode;
												inode.Optr = Operator.dot;
												inode.RightNode = nameNode;
												NodeUtils.SetNodeLocation(inode, inode.LeftNode, inode.RightNode);
												nameNode = inode;
											}

											// if "foo[bar]" is on the rhs, it is interpreted as an lookup in an array or dictionary
											nameNode = ProtoCore.AST.ImperativeAST.AstFactory.BuildIndexExpression(nameNode, node) as ProtoCore.AST.ImperativeAST.ArrayNameNode;
										}

										isLeft = tmpIsLeft; 
                                    .)
        ]
        closebracket 
        { 
		                        (. 
                                    bool tmpIsLeft = isLeft; 
                                    isLeft = false;
                                .) 
            openbracket
            [
                Imperative_expr<out node>

				                (. 
									if (tmpIsLeft) {
										var array2 = new ProtoCore.AST.ImperativeAST.ArrayNode
										{
											Expr = node,
											Type = nameNode.ArrayDimensions
										};

										NodeUtils.SetNodeLocation(array2, t);
										array.Type = array2;
										array = array2;
									} else {
										nameNode = ProtoCore.AST.ImperativeAST.AstFactory.BuildIndexExpression(nameNode, node) as ProtoCore.AST.ImperativeAST.ArrayNameNode;
									}

									// TODO(pboyer) this looks incorrect, probably wrong in associative code, too
									isLeft = tmpIsLeft; 
                                .)
            ]
            closebracket
        }                   
                                (.

                                    if (groupExprNode != null)
                                    {
                                        var expr = groupExprNode.Expression;
                                        if (expr is ProtoCore.AST.ImperativeAST.RangeExprNode)
                                        {    
                                            var rangeExprNode = expr as ProtoCore.AST.ImperativeAST.RangeExprNode; 
                                            if (rangeExprNode.ArrayDimensions == null)
                                            {
                                                rangeExprNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                            }
                                            else 
                                            {
                                                rangeExprNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                            }
                                            groupExprNode.ArrayDimensions = null;
                                        }
                                        else if (expr is ProtoCore.AST.ImperativeAST.ExprListNode)
                                        {    
                                            var exprListNode = expr as ProtoCore.AST.ImperativeAST.ExprListNode; 
                                            if (exprListNode.ArrayDimensions == null)
                                            {
                                                exprListNode.ArrayDimensions = groupExprNode.ArrayDimensions;
                                            }
                                            else 
                                            {
                                                exprListNode.ArrayDimensions.Type = groupExprNode.ArrayDimensions; 
                                            }
                                            groupExprNode.ArrayDimensions = null;
                                        }
                                    }
                                .)
    ]
                                (.
                                    if (groupExprNode != null && groupExprNode.ArrayDimensions == null)
                                    {
                                        node = groupExprNode.Expression;
                                    }
                                    else
                                    {
                                        node = nameNode;
                                    }
                                .)
.

Imperative_DictionaryExpression<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
'{'                                     (. var dictBuilder = new ProtoCore.AST.ImperativeAST.DictionaryExpressionBuilder(); .)
                                        (. dictBuilder.SetNodeStartLocation(t); .)
    [
		(
			textstring	(. var str = new ProtoCore.AST.ImperativeAST.StringNode {Value = t.val.Trim('"')}; .)  
						(. dictBuilder.AddKey(str); .) 
		) 
		|
		(
			ident		(. var ident = new ProtoCore.AST.ImperativeAST.IdentifierNode(t.val); .)
						(. NodeUtils.SetNodeLocation(ident, t); .)
						(. dictBuilder.AddKey(ident); .)
		)
	]
	':'                     
    Imperative_expr<out node>            (. dictBuilder.AddValue(node); .)
    {
        ','
		[
			(
				textstring	(. var str = new ProtoCore.AST.ImperativeAST.StringNode { Value = t.val.Trim('"') }; .)
							(. dictBuilder.AddKey(str); .)  
			)
			|
			(
				ident		(. var ident = new ProtoCore.AST.ImperativeAST.IdentifierNode(t.val); .)
							(. NodeUtils.SetNodeLocation(ident, t); .)
							(. dictBuilder.AddKey(ident); .)
			) 
		]
		':'                     
		Imperative_expr<out node>       (. dictBuilder.SetNodeEndLocation(t); .)
										(. dictBuilder.AddValue(node); .)
    }
                                        
    
'}'                                     (. dictBuilder.SetNodeEndLocation(t); .)
                                        (. node = dictBuilder.ToFunctionCall(); .)
.

Imperative_ExprList<out ProtoCore.AST.ImperativeAST.ImperativeNode node>
=
        '{'                         (.
                                        ProtoCore.AST.ImperativeAST.ExprListNode exprlist = new ProtoCore.AST.ImperativeAST.ExprListNode();
                                        NodeUtils.SetNodeStartLocation(exprlist, t);
                                    .)
            [
                                    
                Imperative_expr<out node>          (. exprlist.Exprs.Add(node); .)
                {
                    ','
                    Imperative_expr<out node>      (. exprlist.Exprs.Add(node); .)
                }
         
            ]
        '}'                         (.
                                        NodeUtils.SetNodeEndLocation(exprlist, t);
                                        node = exprlist;
                                    .)
.

Imperative_num<out ProtoCore.AST.ImperativeAST.ImperativeNode node>         
    (.  
        node = null; 
        int sign = 1;
        int line = ProtoCore.DSASM.Constants.kInvalidIndex; int col = ProtoCore.DSASM.Constants.kInvalidIndex;
    .)                      
=
    [
        '-' 
        (. 
            sign = -1;
            line = t.line; 
            col = t.col; 
        .)
    ]
    (
        number  
        (.  
            Int64 value;
            if (Int64.TryParse(t.val, System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.ImperativeAST.IntNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.ImperativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex != line)
            {
                node.line = line; node.col = col; 
            }
            else
            {
                NodeUtils.SetNodeLocation(node, t); 
            }
        .)
        | 
        float   
        (.  
            double value;
            if (Double.TryParse(t.val, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out value))
            {
                node = new ProtoCore.AST.ImperativeAST.DoubleNode(value * sign);
            }
            else
            {
                node = new ProtoCore.AST.ImperativeAST.NullNode();
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex != line){
                node.line = line; node.col = col; }
            else{
                NodeUtils.SetNodeLocation(node, t); }
        .)
    )
.

Imperative_mulop<out Operator op>       
            (. op = Operator.none; .)   
=                       
    '*'     (. op = Operator.mul; .)
    | 
    '/'     (. op = Operator.div; .)
    |
    '%'     (. op = Operator.mod; .)
.

Imperative_bitop<out Operator op>       
            (. op = Operator.none; .)   
=                       
    '&'     (. op = Operator.bitwiseand; .)
    | 
    '|'     (. op = Operator.bitwiseor; .)
    |
    '^'     (. op = Operator.bitwisexor; .)
.

Imperative_logicalop<out Operator op>       
            (. op = Operator.none; .)   
=                       
    "&&"        (. op = Operator.and; .)
    | 
    "||"        (. op = Operator.or; .)
.

Imperative_addop<out Operator op>       
            (. op = Operator.none; .)   
=                           
    '+'     (. op = Operator.add; .)
    |   
    '-'     (. op = Operator.sub; .)
.

Imperative_relop<out Operator op>   
            (. op = Operator.none; .)   
 =          

    greaterthan (. op = Operator.gt; .)
    | 
    lessthan    (. op = Operator.lt; .)
    | 
    greaterequal    (. op = Operator.ge; .)
    | 
    lessequal   (. op = Operator.le; .)
    | 
    equal   (. op = Operator.eq; .)
    | 
    notequal    (. op = Operator.nq; .)
.

Imperative_negop<out UnaryOperator op>
=
    '-'     (. op = UnaryOperator.Neg; .)
.

Imperative_unaryop<out UnaryOperator op>        
            (. op = UnaryOperator.None; .)  
=   
    (                     
        '!'     (. op = UnaryOperator.Not; .)
                
                (. #if ENABLE_BIT_OP       .)
        |   
        '~'     (. op = UnaryOperator.Negate; .)
                (. #endif                     .)
    )
.

Imperative_rangeAmountOperator<out bool hasAmountOperator>
=
    (. hasAmountOperator = false; .)
(
    '#'
    (. hasAmountOperator = true; .)
)
.

Imperative_rangeStepOperator<out RangeStepOperator op>
                        (. op = RangeStepOperator.StepSize; .)
= 
    [
        '#'             (. op = RangeStepOperator.Number; .)
        | '~'           (. op = RangeStepOperator.ApproximateSize; .)
    ]
.

END DesignScriptParser.