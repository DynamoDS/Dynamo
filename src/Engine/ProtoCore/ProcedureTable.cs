using System;
using System.Collections.Generic;
using System.Linq;
using ProtoCore.AssociativeGraph;
using ProtoCore.AST.AssociativeAST;

namespace ProtoCore.DSASM
{
    // Option class for tracking down a specific ProcedureNode
    internal class ProcedureMatchOptions
    {
        internal string FunctionName; // Find only functions with this name
        internal List<Type> ParameterTypes = null; // Check against parameter types.
        internal bool? IsStatic = null; // Check static-ness when searching through functions.
        internal bool? IsConstructor = null; // Check only constructors when searching through functions.
        internal bool ExcludeAutoGeneratedThisProc = false; // Exclude functions with AutoGeneratedThisProc set as true.
        internal bool ExactMatchWithNumArgs = true; // The number of Parameters must match exact number of arguments. Default args will not be used.
        internal bool ExactMatchWithArgTypes = true; // Function argument types must match exactly with ParamterTypes.

        // If callback returns false, then the current ProcedureNode is filtered out. If true, then matching continues for the current candidate
        internal Func<ProcedureNode, bool> FilterCallback = new Func<ProcedureNode, bool>(x => true); 
    }

    public enum ProcedureDistance
    {
        // TODO Jun: Corecion score may have to be expanded depending on specific types
        CoerceScore = 10,
        CoerceDoubleToIntScore = 5,
        CoerceIntToDoubleScore = 30,
        CoerceBaseClass = 40,
        ExactMatchScore = 50,
        NotMatchScore = 0,
        ExactMatchDistance = 0,
        MaxDistance = Int32.MaxValue,
        InvalidDistance = -1
    }

    public struct ArgumentInfo
    {
        public string Name { get; set; }
        public bool IsDefault
        {
            get
            {
                return DefaultExpression != null;
            }
        }
        public AST.Node DefaultExpression;
        public ExternalAttributes Attributes;
    }

    [System.Diagnostics.DebuggerDisplay("{Name}, ID={ID}, ClassID={ClassID}")]
    public class ProcedureNode
    {
        /// <summary>
        /// Name of the procedure
        /// </summary>
        public string Name                         
        {
            get;set;
        }
        /// <summary>
        /// First instruction of the procedure
        /// </summary>
        public int PC
        {
            get; set;
        }                              
        /// <summary>
        /// Number of local variables
        /// </summary>
        public int LocalCount
        {
            get; set;
        }
        /// <summary>
        /// List of arguments required by the procedure
        /// </summary>
        public List<Type> ArgumentTypes
        {
            get; set;
        }

        /// <summary>
        /// List of arguments' information (default value) 
        /// </summary>
        public List<ArgumentInfo> ArgumentInfos
        {
            get; set;
        }
        /// <summary>
        /// Procedure return data type
        /// </summary>
        public Type ReturnType
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a constructor or not
        /// </summary>
        public bool IsConstructor
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a static function or not
        /// </summary>
        public bool IsStatic
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure at the runtime executable tables
        /// </summary>
        public int RuntimeIndex
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure in its procedure table
        /// </summary>
        public int ID
        {
            get; set;
        } 
        /// <summary>
        /// Index of the class that the procedure belongs to
        /// </summary>
        public int ClassID
        {
            get; set;
        } 
        /// <summary>
        /// The hash of the function given the name and argument type string
        /// </summary>
        public int HashID
        {
            get; set;
        } 
        public CompilerDefinitions.AccessModifier AccessModifier
        {
            get; set;
        }
		
        public bool IsExternal
        {
            get; set;
        }
        public bool IsAssocOperator
        {
            get; set;
        }
        public bool IsAutoGenerated
        {
            get; set;
        }
        public bool IsAutoGeneratedThisProc
        {
            get; set;
        }
        public bool IsActive
        {
            get; set;
        }
        public MethodAttributes MethodAttribute
        {
            get; set;
        }
        public bool IsVarArg
        {
            get; set;
        }
        public List<int> ChildCodeBlocks
        {
            get; set;
        }
        /// <summary>
        /// The list of graphnodes that this function owns
        /// </summary>
        public List<GraphNode> GraphNodeList
        {
            get; private set;
        }

        public ProcedureNode()
        {
            ID = DSASM.Constants.kInvalidIndex;
            ClassID = DSASM.Constants.kInvalidIndex;
            ArgumentTypes = new List<Type>();
            ArgumentInfos = new List<ArgumentInfo>();
            IsConstructor = false;
            IsStatic = false;
            AccessModifier = CompilerDefinitions.AccessModifier.Public;
            IsAutoGenerated = false;
            IsAutoGeneratedThisProc = false;
            IsActive = true;
            ChildCodeBlocks = new List<int>();

            GraphNodeList = new List<GraphNode>();
        }


        public ProcedureNode(ProcedureNode rhs)
        {
            Name = rhs.Name;
            PC = rhs.PC;
            LocalCount = rhs.LocalCount;
            ReturnType = rhs.ReturnType;
            RuntimeIndex = rhs.RuntimeIndex;
            IsExternal = rhs.IsExternal;
            IsAssocOperator = rhs.IsAssocOperator;
            IsVarArg = rhs.IsVarArg;

            ID = rhs.ID;
            ClassID = rhs.ClassID;
            ArgumentTypes = new List<Type>(rhs.ArgumentTypes);
            ArgumentInfos = new List<ArgumentInfo>(rhs.ArgumentInfos);
            IsConstructor = rhs.IsConstructor;
            IsStatic = rhs.IsStatic;
            AccessModifier = rhs.AccessModifier;
            IsAutoGenerated = rhs.IsAutoGenerated;
            IsAutoGeneratedThisProc = rhs.IsAutoGeneratedThisProc;
            IsActive = rhs.IsActive;
            ChildCodeBlocks = new List<int>(rhs.ChildCodeBlocks);

            // Runtime properties are initialized
            GraphNodeList = new List<GraphNode>();
        }

        public override bool Equals(object obj)
        {
            var rhs = obj as ProcedureNode;
            if (rhs == null)
            {
                return false;
            }

            return ID == rhs.ID && 
                   ClassID == rhs.ClassID && 
                   LocalCount == rhs.LocalCount && 
                   Name.Equals(rhs.Name);
        }
    }

    public class ProcedureTable
    {
        /// <summary>
        /// The index of this procedure table in the executable's procedure
        /// table list.
        /// </summary>
        public int RuntimeIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// All procedure nodes defined in this procedure table.
        /// </summary>
        public List<ProcedureNode> Procedures
        {
            get;
            private set;
        }
        
        /// <summary>
        /// Create an empty procedure table.
        /// </summary>
        /// <param name="runtimeindex"></param>
        public ProcedureTable(int runtimeindex)
        {
            RuntimeIndex = runtimeindex;
            Procedures = new List<ProcedureNode>();
        }

        public ProcedureTable(ProcedureTable rhs)
        {
            this.RuntimeIndex = rhs.RuntimeIndex;
            this.Procedures = new List<ProcedureNode>();
            for (int n = 0; n < rhs.Procedures.Count; ++n)
            {
                Procedures.Add(new ProcedureNode(rhs.Procedures[n]));
            }
        }

        public int Append(ProcedureNode node)
        {
            GetFunctionBySignature(new ProcedureMatchOptions() { 
                    FunctionName = node.Name, 
                    ParameterTypes = node.ArgumentTypes, 
                    IsStatic = node.IsStatic }, 
                out ProcedureNode existingProcNode);
            if (existingProcNode == null)
            {
                Procedures.Add(node);
                node.ID = Procedures.Count - 1;
                return node.ID;
            }
            else if (!existingProcNode.IsActive)
            {
                node.ID = existingProcNode.ID;
                Procedures[node.ID] = node;
                return node.ID;
            }
            else
            {
                return Constants.kInvalidIndex;
            }
        }

        /// <summary>
        /// Returns function with specified name. 
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsByName(string name)
        {
            return Procedures.Where(p => p.Name.Equals(name));
        }

        /// <summary>
        /// Returns getter function for given property name.
        /// Ex: for X property of Point, this method returns get_X(Point p).
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public ProcedureNode GetPropertyGetterByName(string name)
        {
            var getterMethodName = Constants.kGetterPrefix + name;
            return Procedures.FirstOrDefault(p => p.Name == getterMethodName &&
                                                  p.IsStatic && p.ArgumentTypes.Count == 1);
        }

        /// <summary>
        /// Returns all functions with specified name and the number of argument.
        ///
        /// It also returns function that has default arguments but the total 
        /// parameter number is larger that the specified argument number.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="argumentNumber"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsByNameAndArgumentNumber(string name, int argumentNumber)
        {
            return GetFunctionsByName(name).Where(p =>
            {
                int defaultArgumentNumber = p.ArgumentInfos.Count(x => x.IsDefault);
                int parameterNumber = p.ArgumentTypes.Count;
                return (argumentNumber <= parameterNumber) &&
                       (argumentNumber - parameterNumber <= defaultArgumentNumber);
            }).OrderBy(p => p.ArgumentTypes.Count - argumentNumber);
        }

        [Obsolete("This method will be removed in Dynamo 3.0.")]
        public int IndexOf(string name, List<ProtoCore.Type> argTypeList, bool isStaticOrConstructor = false)
        {
            ProcedureMatchOptions opts = new ProcedureMatchOptions() {
                FunctionName = name,
                ParameterTypes = argTypeList,
                ExcludeAutoGeneratedThisProc = true,
                ExactMatchWithNumArgs = false,
                ExactMatchWithArgTypes = false,
                FilterCallback = x => !isStaticOrConstructor || (x.IsStatic || x.IsConstructor)
            };
            return GetFunctionBySignature(opts, out ProcedureNode _);
        }

        /// <summary>
        /// Get function by its signature.
        /// </summary>
        /// <param name="functionName"></param>
        /// <param name="parameterTypes"></param>
        /// <returns></returns>
        [Obsolete("This method will be removed in Dynamo 3.0.")]
        public ProcedureNode GetFunctionBySignature(string functionName, List<Type> parameterTypes)
        {
            GetFunctionBySignature(new ProcedureMatchOptions() 
            { 
                FunctionName = functionName, 
                ParameterTypes = parameterTypes 
            }, out ProcedureNode output);
            return output;
        }

        /// <summary>
        /// Get function by its signature.
        /// </summary>
        /// <param name="opts">Matching options</param>
        /// <param name="outputProcNode">Output procedure node. Null if nothing is found</param>
        /// <returns>Index of the ProcedureNode in the Procedures list. Returns -1 If nothing is found</returns>
        internal int GetFunctionBySignature(ProcedureMatchOptions opts, out ProcedureNode outputProcNode)
        {
            int outputProcNodeIndex = Constants.kInvalidIndex;
            outputProcNode = null;

            // how many default parameters are used
            int smallestDefaultArgNum = int.MaxValue;
            for (int ii = 0; ii < Procedures.Count; ++ii)
            {
                var f = Procedures[ii];
                
                if (opts.FilterCallback(f) == false)
                {
                    continue;
                }

                if ((opts.FunctionName != f.Name) ||
                    (opts.ExcludeAutoGeneratedThisProc && f.IsAutoGeneratedThisProc) ||
                    (opts.IsStatic != null) && (opts.IsStatic != f.IsStatic) ||
                    (opts.IsConstructor != null) && (opts.IsConstructor != f.IsConstructor))
                {
                    goto NotMatch;
                }

                if (!f.IsActive) goto NotMatch;

                if (opts.ParameterTypes != null)
                {
                    var argNum = f.ArgumentTypes.Count;
                    var paramNum = opts.ParameterTypes.Count;

                    if (opts.ExactMatchWithNumArgs && (argNum != paramNum))
                    {
                        goto NotMatch;
                    }

                    if (opts.ExactMatchWithArgTypes)
                    {
                        for (int k = 0; k < paramNum; k++)
                        {
                            if (f.ArgumentTypes[k].Name != opts.ParameterTypes[k].Name || f.ArgumentTypes[k].UID != opts.ParameterTypes[k].UID)
                            {
                                goto NotMatch;
                            }
                        }
                    }

                    int defaultArgs = f.ArgumentInfos.Count(X => X.DefaultExpression != null);
                    if ((argNum < paramNum) || (defaultArgs < argNum - paramNum))
                    {
                        // The current procedure has either:
                        // too less arguments that we are looking for.
                        // or
                        // too many arguments(even with defaults) than we are looking for
                        goto NotMatch;
                    }

                    // Look for the function with the least amount of default arguments
                    var num = argNum - paramNum;
                    if (num <= smallestDefaultArgNum)
                    {
                        smallestDefaultArgNum = num;

                        outputProcNodeIndex = ii;
                        outputProcNode = Procedures[ii];
                    }

                    if (smallestDefaultArgNum == 0)
                    {
                        break;
                    }
                } 
                else
                {
                    outputProcNodeIndex = ii;
                    outputProcNode = Procedures[ii];

                    break;
                }

                NotMatch:
                ;
            }
            return outputProcNodeIndex;
        }
    }
}
