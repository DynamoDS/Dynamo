using System;
using System.Collections.Generic;
using System.Linq;
using ProtoCore.AssociativeGraph;
using ProtoCore.AST.AssociativeAST;

namespace ProtoCore.DSASM
{
    public enum ProcedureDistance
    {
        // TODO Jun: Corecion score may have to be expanded depending on specific types
        CoerceScore = 10,
        CoerceDoubleToIntScore = 5,
        CoerceIntToDoubleScore = 30,
        CoerceBaseClass = 40,
        ExactMatchScore = 50,
        NotMatchScore = 0,
        ExactMatchDistance = 0,
        MaxDistance = Int32.MaxValue,
        InvalidDistance = -1
    }

    public struct ArgumentInfo
    {
        public string Name { get; set; }
        public bool IsDefault
        {
            get
            {
                return DefaultExpression != null;
            }
        }
        public AST.Node DefaultExpression;
        public ExternalAttributes Attributes;
    }

    [System.Diagnostics.DebuggerDisplay("{Name}, ID={ID}, ClassID={ClassID}")]
    public class ProcedureNode
    {
        /// <summary>
        /// Name of the procedure
        /// </summary>
        public string Name                         
        {
            get;set;
        }
        /// <summary>
        /// First instruction of the procedure
        /// </summary>
        public int PC
        {
            get; set;
        }                              
        /// <summary>
        /// Number of local variables
        /// </summary>
        public int LocalCount
        {
            get; set;
        }
        /// <summary>
        /// List of arguments required by the procedure
        /// </summary>
        public List<Type> ArgumentTypes
        {
            get; set;
        }

        /// <summary>
        /// Number of non default argument
        /// </summary>
        public int NonDefaultArgumentCount
        {
            get
            {
                return ArgumentTypes.Count - ArgumentInfos.Count(a => a.IsDefault);
            }
        }

        /// <summary>
        /// List of arguments' information (default value) 
        /// </summary>
        public List<ArgumentInfo> ArgumentInfos
        {
            get; set;
        }
        /// <summary>
        /// Procedure return data type
        /// </summary>
        public Type ReturnType
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a constructor or not
        /// </summary>
        public bool IsConstructor
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a static function or not
        /// </summary>
        public bool IsStatic
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure at the runtime executable tables
        /// </summary>
        public int RuntimeIndex
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure in its procedure table
        /// </summary>
        public int ID
        {
            get; set;
        } 
        /// <summary>
        /// Index of the class that the procedure belongs to
        /// </summary>
        public int ClassID
        {
            get; set;
        } 
        /// <summary>
        /// The hash of the function given the name and argument type string
        /// </summary>
        public int HashID
        {
            get; set;
        } 
        public CompilerDefinitions.AccessModifier AccessModifier
        {
            get; set;
        }
		public List<AttributeEntry> Attributes
        {
            get; set;
        }		
        public bool IsExternal
        {
            get; set;
        }
        public bool IsAssocOperator
        {
            get; set;
        }
        public bool IsAutoGenerated
        {
            get; set;
        }
        public bool IsAutoGeneratedThisProc
        {
            get; set;
        }
        public bool IsActive
        {
            get; set;
        }
        public MethodAttributes MethodAttribute
        {
            get; set;
        }
        public bool IsVarArg
        {
            get; set;
        }
        public List<int> ChildCodeBlocks
        {
            get; set;
        }
        public Stack<UpdateNodeRef> UpdatedGlobalVariables
        {
            get; set;
        }
        public Stack<UpdateNodeRef> UpdatedProperties
        {
            get; set;
        }
        public Dictionary<string, List<UpdateNodeRef>> UpdatedArgumentProperties
        {
            get; set;
        }
        /// <summary>
        /// The list of graphnodes that this function owns
        /// </summary>
        public List<GraphNode> GraphNodeList
        {
            get; private set;
        }

        public ProcedureNode()
        {
            ID = DSASM.Constants.kInvalidIndex;
            ClassID = DSASM.Constants.kInvalidIndex;
            ArgumentTypes = new List<Type>();
            ArgumentInfos = new List<ArgumentInfo>();
            IsConstructor = false;
            IsStatic = false;
            AccessModifier = CompilerDefinitions.AccessModifier.Public;
            IsAutoGenerated = false;
            IsAutoGeneratedThisProc = false;
            IsActive = true;
            ChildCodeBlocks = new List<int>();

            UpdatedGlobalVariables = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedProperties = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedArgumentProperties = new Dictionary<string, List<AssociativeGraph.UpdateNodeRef>>();
            GraphNodeList = new List<GraphNode>();
        }


        public ProcedureNode(ProcedureNode rhs)
        {
            Name = rhs.Name;
            PC = rhs.PC;
            LocalCount = rhs.LocalCount;
            ReturnType = rhs.ReturnType;
            RuntimeIndex = rhs.RuntimeIndex;
            IsExternal = rhs.IsExternal;
            IsAssocOperator = rhs.IsAssocOperator;
            IsVarArg = rhs.IsVarArg;

            ID = rhs.ID;
            ClassID = rhs.ClassID;
            ArgumentTypes = new List<Type>(rhs.ArgumentTypes);
            ArgumentInfos = new List<ArgumentInfo>(rhs.ArgumentInfos);
            IsConstructor = rhs.IsConstructor;
            IsStatic = rhs.IsStatic;
            AccessModifier = rhs.AccessModifier;
            IsAutoGenerated = rhs.IsAutoGenerated;
            IsAutoGeneratedThisProc = rhs.IsAutoGeneratedThisProc;
            IsActive = rhs.IsActive;
            ChildCodeBlocks = new List<int>(rhs.ChildCodeBlocks);

            // Runtime properties are initialized
            UpdatedGlobalVariables = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedProperties = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedArgumentProperties = new Dictionary<string, List<AssociativeGraph.UpdateNodeRef>>();
            GraphNodeList = new List<GraphNode>();
        }

        public override bool Equals(object obj)
        {
            var rhs = obj as ProcedureNode;
            if (rhs == null)
            {
                return false;
            }

            return ID == rhs.ID && 
                   ClassID == rhs.ClassID && 
                   LocalCount == rhs.LocalCount && 
                   Name.Equals(rhs.Name);
        }

        /// <summary>
        /// Return true if two procedure nodes have same signature.
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Matches(string name, List<ProtoCore.Type> argumentTypes)
        {
            if (argumentTypes == null)
                throw new ArgumentNullException("argumentTypes");

            return Name == name && ArgumentTypes.SequenceEqual(argumentTypes);
        }
    }

    public class ProcedureTable
    {
        /// <summary>
        /// The index of this procedure table in the executable's procedure
        /// table list.
        /// </summary>
        public int RuntimeIndex
        {
            get;
            private set;
        }

        /// <summary>
        /// All procedure nodes defined in this procedure table.
        /// </summary>
        public List<ProcedureNode> Procedures
        {
            get;
            private set;
        }
        
        /// <summary>
        /// Create an empty procedure table.
        /// </summary>
        /// <param name="runtimeindex"></param>
        public ProcedureTable(int runtimeindex)
        {
            RuntimeIndex = runtimeindex;
            Procedures = new List<ProcedureNode>();
        }

        public ProcedureTable(ProcedureTable rhs)
        {
            this.RuntimeIndex = rhs.RuntimeIndex;
            this.Procedures = new List<ProcedureNode>();
            for (int n = 0; n < rhs.Procedures.Count; ++n)
            {
                Procedures.Add(new ProcedureNode(rhs.Procedures[n]));
            }
        }

        public int Append(ProcedureNode node)
        {
            var procNode = GetFunctionBySignature(node.Name, node.ArgumentTypes);
            if (procNode == null)
            {
                Procedures.Add(node);
                node.ID = Procedures.Count - 1;
                return node.ID;
            }
            else if (!procNode.IsActive)
            {
                node.ID = procNode.ID;
                Procedures[node.ID] = node;
                return node.ID;
            }
            else
            {
                return Constants.kInvalidIndex;
            }
        }

        /// <summary>
        /// Return function with specified name. 
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsByName(string name)
        {
            return Procedures.Where(p => p.Name.Equals(name));
        }

        /// <summary>
        /// Return all functions with specified name and the number of argument.
        ///
        /// It also returns function that has default arguments but the total 
        /// parameter number is larger that the specified argument number.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="argumentNumber"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsByNameAndArgumentNumber(string name, int argumentNumber)
        {
            return GetFunctionsByName(name).Where(p =>
            {
                int defaultArgumentNumber = p.ArgumentInfos.Count(x => x.IsDefault);
                int parameterNumber = p.ArgumentTypes.Count;
                return (argumentNumber <= parameterNumber) &&
                       (argumentNumber - parameterNumber <= defaultArgumentNumber);
            }).OrderBy(p => p.ArgumentTypes.Count - argumentNumber);
        }

        /// <summary>
        /// Return function with specified signature.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        public ProcedureNode GetFunctionBySignature(string name, List<Type> args)
        {
            return Procedures.FirstOrDefault(p => p.Matches(name, args));
        }

        // TODO: To be deleted.
        public int IndexOf(string name, List<ProtoCore.Type> argTypeList, bool isStaticOrConstructor = false)
        {
            int currentProcedure = ProtoCore.DSASM.Constants.kInvalidIndex;
            bool functionPointerCheck = argTypeList == null;

            if (functionPointerCheck) // check for function pointer
            {
                for (int n = 0; n < Procedures.Count; ++n)
                {
                    if (name == Procedures[n].Name)
                    {
                        currentProcedure = n;
                        break;
                    }
                }
                return currentProcedure;
            }

            // how many default parameters are used
            int defaultParamNum = Int32.MaxValue;

            for (int n = 0; n < Procedures.Count; ++n)
            {
                var proc = Procedures[n];
                if (proc.IsAutoGeneratedThisProc)
                    continue;

                var argNum = proc.ArgumentTypes.Count;
                var paramNum = argTypeList.Count;
                int defaultArgNum = proc.ArgumentInfos.Count(X => X.DefaultExpression != null);

                if (name.Equals(proc.Name) && (argNum >= paramNum) && (argNum - paramNum <= defaultArgNum))
                {
                    if (!isStaticOrConstructor ||
                        (isStaticOrConstructor && (proc.IsStatic || proc.IsConstructor)))
                    {
                        var num = argNum - paramNum;
                        if (num < defaultParamNum)
                        {
                            defaultParamNum = num;
                            currentProcedure = n;
                        }

                        if (defaultParamNum == 0)
                        {
                            break;
                        }
                    }
                }
            }
            return currentProcedure;
        }
    }
}
