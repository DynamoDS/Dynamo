using System;
using System.Collections.Generic;
using System.Linq;
using ProtoCore.AssociativeGraph;
using ProtoCore.AST.AssociativeAST;

namespace ProtoCore.DSASM
{
    public enum ProcedureDistance
    {
        // TODO Jun: Corecion score may have to be expanded depending on specific types
        kCoerceScore = 10,
        kCoerceDoubleToIntScore = 5,
        kCoerceIntToDoubleScore = 30,
        kCoerceBaseClass = 40,
        kExactMatchScore = 50,
        kNotMatchScore = 0,
        kExactMatchDistance = 0,
        kMaxDistance = Int32.MaxValue,
        kInvalidDistance = -1
    }

    public struct ArgumentInfo
    {
        public string Name { get; set; }
        public bool IsDefault
        {
            get
            {
                return DefaultExpression != null;
            }
        }
        public AST.Node DefaultExpression;
        public ExternalAttributes Attributes;
    }

    [System.Diagnostics.DebuggerDisplay("{name}, procId={procId}, classScope={classScope}")]
    public class ProcedureNode
    {
        /// <summary>
        /// Name of the procedure
        /// </summary>
        public string Name                         
        {
            get;set;
        }
        /// <summary>
        /// First instruction of the procedure
        /// </summary>
        public int PC
        {
            get; set;
        }                              
        /// <summary>
        /// Number of local variables
        /// </summary>
        public int LocalCount
        {
            get; set;
        }
        /// <summary>
        /// List of arguments required by the procedure
        /// </summary>
        public List<Type> ArgumentTypes
        {
            get; set;
        }
        /// <summary>
        /// List of arguments' information (default value) 
        /// </summary>
        public List<ArgumentInfo> ArgumentInfos
        {
            get; set;
        }
        /// <summary>
        /// Procedure return data type
        /// </summary>
        public Type ReturnType
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a constructor or not
        /// </summary>
        public bool IsConstructor
        {
            get; set;
        }
        /// <summary>
        /// Flag whether procedure is a static function or not
        /// </summary>
        public bool IsStatic
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure at the runtime executable tables
        /// </summary>
        public int RuntimeIndex
        {
            get; set;
        } 
        /// <summary>
        /// Index of the procedure in its procedure table
        /// </summary>
        public int ID
        {
            get; set;
        } 
        /// <summary>
        /// Index of the class that the procedure belongs to
        /// </summary>
        public int ClassID
        {
            get; set;
        } 
        /// <summary>
        /// The hash of the function given the name and argument type string
        /// </summary>
        public int HashID
        {
            get; set;
        } 
        public CompilerDefinitions.AccessModifier AccessModifier
        {
            get; set;
        }
		public List<AttributeEntry> Attributes
        {
            get; set;
        }		
        public bool IsExternal
        {
            get; set;
        }
        public bool IsAssocOperator
        {
            get; set;
        }
        public bool IsAutoGenerated
        {
            get; set;
        }
        public bool IsAutoGeneratedThisProc
        {
            get; set;
        }
        public bool IsActive
        {
            get; set;
        }
        public MethodAttributes MethodAttribute
        {
            get; set;
        }
        public bool IsVarArg
        {
            get; set;
        }
        public List<int> ChildCodeBlocks
        {
            get; set;
        }
        public Stack<UpdateNodeRef> UpdatedGlobalVariables
        {
            get; set;
        }
        public Stack<UpdateNodeRef> UpdatedProperties
        {
            get; set;
        }
        public Dictionary<string, List<UpdateNodeRef>> UpdatedArgumentProperties
        {
            get; set;
        }
        public Dictionary<string, List<UpdateNode>> UpdatedArgumentArrays
        {
            get; set;
        }
        /// <summary>
        /// The list of graphnodes that this function owns
        /// </summary>
        public List<GraphNode> GraphNodeList
        {
            get; private set;
        }

        public ProcedureNode()
        {
            ID = DSASM.Constants.kInvalidIndex;
            ClassID = DSASM.Constants.kInvalidIndex;
            ArgumentTypes = new List<Type>();
            ArgumentInfos = new List<ArgumentInfo>();
            IsConstructor = false;
            IsStatic = false;
            AccessModifier = CompilerDefinitions.AccessModifier.kPublic;
            IsAutoGenerated = false;
            IsAutoGeneratedThisProc = false;
            IsActive = true;
            ChildCodeBlocks = new List<int>();

            UpdatedGlobalVariables = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedProperties = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedArgumentProperties = new Dictionary<string, List<AssociativeGraph.UpdateNodeRef>>();
            UpdatedArgumentArrays = new Dictionary<string, List<AssociativeGraph.UpdateNode>>();
            GraphNodeList = new List<GraphNode>();
        }


        public ProcedureNode(ProcedureNode rhs)
        {
            Name = rhs.Name;
            PC = rhs.PC;
            LocalCount = rhs.LocalCount;
            ReturnType = rhs.ReturnType;
            RuntimeIndex = rhs.RuntimeIndex;
            IsExternal = rhs.IsExternal;
            IsAssocOperator = rhs.IsAssocOperator;
            IsVarArg = rhs.IsVarArg;

            ID = rhs.ID;
            ClassID = rhs.ClassID;
            ArgumentTypes = new List<Type>(rhs.ArgumentTypes);
            ArgumentInfos = new List<ArgumentInfo>(rhs.ArgumentInfos);
            IsConstructor = rhs.IsConstructor;
            IsStatic = rhs.IsStatic;
            AccessModifier = rhs.AccessModifier;
            IsAutoGenerated = rhs.IsAutoGenerated;
            IsAutoGeneratedThisProc = rhs.IsAutoGeneratedThisProc;
            IsActive = rhs.IsActive;
            ChildCodeBlocks = new List<int>(rhs.ChildCodeBlocks);

            // Runtime properties are initialized
            UpdatedGlobalVariables = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedProperties = new Stack<AssociativeGraph.UpdateNodeRef>();
            UpdatedArgumentProperties = new Dictionary<string, List<AssociativeGraph.UpdateNodeRef>>();
            UpdatedArgumentArrays = new Dictionary<string, List<AssociativeGraph.UpdateNode>>();
            GraphNodeList = new List<GraphNode>();
        }

        public override bool Equals(object obj)
        {
            var rhs = obj as ProcedureNode;
            if (rhs == null)
            {
                return false;
            }

            return ID == rhs.ID && 
                   ClassID == rhs.ClassID && 
                   LocalCount == rhs.LocalCount && 
                   Name.Equals(rhs.Name);
        }
    }

    public class ProcedureTable
    {
        public int runtimeIndex { get; private set; }
        public List<ProcedureNode> procList { get; set; }
        
        public ProcedureTable(int runtimeindex)
        {
            runtimeIndex = runtimeindex;
            procList = new List<ProcedureNode>();
        }

        public ProcedureTable(ProcedureTable rhs)
        {
            this.runtimeIndex = rhs.runtimeIndex;
            this.procList = new List<ProcedureNode>();
            for (int n = 0; n < rhs.procList.Count; ++n)
            {
                procList.Add(new ProcedureNode(rhs.procList[n]));
            }
        }

        public int Append(ProcedureNode node)
        {
            int index = IndexOfExact(node.Name, node.ArgumentTypes, node.IsAutoGeneratedThisProc);
            if (Constants.kInvalidIndex == index)
            {
                procList.Add(node);
                node.ID = procList.Count - 1;
                return node.ID;
            }
            else
            {
                var procNode = procList[index];
                if (!procNode.IsActive)
                {
                    procList[index] = node;
                    node.ID = index;
                    return node.ID;
                }
            }
            return ProtoCore.DSASM.Constants.kInvalidIndex;
        }

        /// <summary>
        /// Return all functions whose names are 'name'
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsBy(string name)
        {
            return procList.Where(p => p.Name.Equals(name));
        }

        /// <summary>
        /// Return all functions whose names are 'name' and the number of
        /// parameters are 'argumentNumber'
        /// </summary>
        /// <param name="name"></param>
        /// <param name="argumentNumber"></param>
        /// <returns></returns>
        public IEnumerable<ProcedureNode> GetFunctionsBy(string name, int argumentNumber)
        {
            return procList.Where(p =>
            {
                int defaultArgumentNumber = p.ArgumentInfos.Count(X => X.DefaultExpression != null);
                int parameterNumber = p.ArgumentTypes.Count;
                return p.Name.Equals(name) &&
                       (argumentNumber <= parameterNumber) &&
                       (argumentNumber - parameterNumber <= defaultArgumentNumber);
            }).OrderBy(p => p.ArgumentTypes.Count - argumentNumber);
        }
        
        public ProcedureNode GetFirst(string name, int argCount)
        {
            ProcedureNode procReturn = null;
            for (int n = 0; n < procList.Count; ++n)
            {
                if (name == procList[n].Name && argCount == procList[n].ArgumentTypes.Count)
                {
                    procReturn = procList[n];
                    break;
                }
            }
            return procReturn;
        }

        public ProcedureNode GetFirstStatic(string name)
        {
            ProcedureNode procReturn = null;
            for (int n = 0; n < procList.Count; ++n)
            {
                if (name == procList[n].Name && procList[n].IsStatic)
                {
                    procReturn = procList[n];
                    break;
                }
            }
            return procReturn;
        }

        public int IndexOf(string name, List<ProtoCore.Type> argTypeList, bool isStaticOrConstructor = false)
        {
            int currentProcedure = ProtoCore.DSASM.Constants.kInvalidIndex;
            bool functionPointerCheck = argTypeList == null;

            if (functionPointerCheck) // check for function pointer
            {
                for (int n = 0; n < procList.Count; ++n)
                {
                    if (name == procList[n].Name)
                    {
                        currentProcedure = n;
                        break;
                    }
                }
                return currentProcedure;
            }

            // how many default parameters are used
            int defaultParamNum = Int32.MaxValue;

            for (int n = 0; n < procList.Count; ++n)
            {
                var proc = procList[n];
                if (proc.IsAutoGeneratedThisProc)
                    continue;

                var argNum = proc.ArgumentTypes.Count;
                var paramNum = argTypeList.Count;
                int defaultArgNum = proc.ArgumentInfos.Count(X => X.DefaultExpression != null);

                if (name.Equals(proc.Name) && (argNum >= paramNum) && (argNum - paramNum <= defaultArgNum))
                {
                    if (!isStaticOrConstructor ||
                        (isStaticOrConstructor && (proc.IsStatic || proc.IsConstructor)))
                    {
                        var num = argNum - paramNum;
                        if (num < defaultParamNum)
                        {
                            defaultParamNum = num;
                            currentProcedure = n;
                        }

                        if (defaultParamNum == 0)
                        {
                            break;
                        }
                    }
                }
            }
            return currentProcedure;
        }

        public int IndexOfExact(string name, List<ProtoCore.Type> args, bool isAutoGeneratedThisProc)
        {
            // This functions attempts to find an exact match and return its index
            // Iterate through all defined functions
            for (int n = 0; n < procList.Count; ++n)
            {
                if (name == procList[n].Name && 
                    args.Count == procList[n].ArgumentTypes.Count &&
                    procList[n].IsAutoGeneratedThisProc == isAutoGeneratedThisProc)
                {
                    bool isMatch = true;
                    for (int i = 0; i < args.Count; ++i)
                    {
                        if ((procList[n].ArgumentTypes[i].UID != args[i].UID) ||
                            (procList[n].ArgumentTypes[i].IsIndexable != args[i].IsIndexable) ||
                            (procList[n].ArgumentTypes[i].rank != args[i].rank))
                        {
                            isMatch = false;
                            break;
                        }
                    }

                    if (isMatch)
                    {
                        return n;
                    }
                }
            }
            return ProtoCore.DSASM.Constants.kInvalidIndex;
        }

        public int IndexOfFirst(string name)
        {
            for (int n = 0; n < procList.Count; ++n)
            {
                if (name == procList[n].Name)
                {
                    return n;
                }
            }
            return ProtoCore.DSASM.Constants.kInvalidIndex;
        }

        public int IndexOfHash(int hash)
        {
            for (int n = 0; n < procList.Count; ++n)
            {
                if (hash == procList[n].HashID)
                {
                    return n;
                }
            }
            return ProtoCore.DSASM.Constants.kInvalidIndex;
        }

        /// <summary>
        /// This sets the procedure node to be inactive by modifiying its name
        /// </summary>
        /// <param name="name"></param>
        /// <param name="args"></param>
        public void SetInactive(int index)
        {
            if (index < 0 || index >= procList.Count)
                throw new ArgumentOutOfRangeException();
            procList[index].IsActive = false;
        }
    }
}
