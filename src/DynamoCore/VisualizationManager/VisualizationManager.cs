using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows.Media.Media3D;
using System.Linq;
using Autodesk.LibG;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Selection;
using Dynamo.Services;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;
using Newtonsoft.Json;
using Octree.OctreeSearch;
using Octree.Tools.Point;
using Double = System.Double;
using String = System.String;
using Dynamo.DSEngine;
using Dynamo.Nodes;

//testing to see if github integration works.

namespace Dynamo
{
    public delegate void VisualizationCompleteEventHandler(object sender, EventArgs e);

    public delegate void ResultsReadyHandler(object sender, VisualizationEventArgs e);

    public delegate void VisualizerDelegate(NodeModel node, object geom, RenderDescription target, Octree.OctreeSearch.Octree octree);

    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public abstract class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, RenderDescription> visualizations 
            = new Dictionary<string, RenderDescription>();

        private Dictionary<Type, VisualizerDelegate> visualizers 
            = new Dictionary<Type, VisualizerDelegate>(); 

        private string _alternateContextName = "Host";
        private bool _drawToAlternateContext = true;
        private object myLock = new object();
        protected bool isUpdating = false;
        private Octree.OctreeSearch.Octree octree;
        private bool updatingPaused = false;

        #endregion

        #region public properties

        /// <summary>
        /// Flag allows us to pause visualization updates.
        /// </summary>
        public bool UpdatingPaused
        {
            get { return updatingPaused; }
            set
            {
                if (!value && updatingPaused)
                {
                    OnVisualizationUpdateComplete(this, EventArgs.Empty);
                }

                updatingPaused = value;
            }
        }

        /// <summary>
        /// A dictionary of objects to be stored for visualization.
        /// </summary>
        public Dictionary<string, RenderDescription> Visualizations
        {
            get
            {
                lock (myLock)
                {
                    return visualizations; 
                }
            }
            set
            {
                lock (myLock)
                {
                    visualizations = value;
                }
            }
        }

        public Dictionary<Type, VisualizerDelegate> Visualizers
        {
            get { return visualizers; }
            set { visualizers = value; }
        }

        /// <summary>
        /// Is another context available for drawing?
        /// This property can be queried indirectly by the view to enable or disable
        /// UI functionality based on whether an alternate drawing context is available.
        /// </summary>
        public bool AlternateDrawingContextAvailable { get; set; }

        /// <summary>
        /// Should we draw to the alternate context if it is available?
        /// </summary>
        public bool DrawToAlternateContext
        {
            get { return _drawToAlternateContext; }
            set
            {
                if (value == false)
                {
                    //if the present value has us drawing to the alternate
                    //context and we would like to stop doing so, we need 
                    //to trigger an event requesting alternate contexts
                    //to drop their visualizations
                    if (_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnRequestAlternateContextClear(this, EventArgs.Empty);
                    }
                }
                else
                {
                    //we would like to reenable drawing to an alternate context.
                    //trigger the standard visualization complete event
                    if (!_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnVisualizationUpdateComplete(this, EventArgs.Empty);
                    }
                }
            }
        }

        /// <summary>
        /// Can be used to expose a name of the alternate context for use in the UI.
        /// </summary>
        public string AlternateContextName
        {
            get { return _alternateContextName; }
            set { _alternateContextName = value; }
        }

        public Octree.OctreeSearch.Octree Octree
        {
            get { return octree; }
            set { octree = value; }
        }

        #endregion

        #region events

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event VisualizationCompleteEventHandler VisualizationUpdateComplete;

        /// <summary>
        /// An event triggered when want any alternate drawing contexts to be cleared.
        /// </summary>
        public event EventHandler RequestAlternateContextClear;

        /// <summary>
        /// An event triggered when there are results to visualize
        /// </summary>
        public event ResultsReadyHandler ResultsReadyToVisualize;

        #endregion

        protected VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.ConnectorDeleted += DynamoModel_ConnectorDeleted;
            dynSettings.Controller.EvaluationCompleted += Controller_EvaluationCompleted;
            dynSettings.Controller.RequestsRedraw += Controller_RequestsRedraw;
            DynamoSelection.Instance.Selection.CollectionChanged += Selection_CollectionChanged;
            dynSettings.Controller.DynamoModel.ModelCleared += DynamoModel_ModelCleared;
            dynSettings.Controller.DynamoModel.CleaningUp += DynamoModel_CleaningUp;
            
            dynSettings.Controller.DynamoModel.NodeDeleted += DynamoModel_NodeDeleted;

            Visualizers.Add(typeof(GraphicItem), VisualizationManagerASM.DrawLibGGraphicItem);
#if USE_DSENGINE
            Visualizers.Add(typeof(Autodesk.DesignScript.Interfaces.IGraphicItem), VisualizationManagerDSGeometry.DrawDesignScriptGraphicItem);
#endif
            octree = new Octree.OctreeSearch.Octree(10000,-10000,10000,-10000,10000,-10000,10000000);
        }

        void DynamoModel_NodeDeleted(NodeModel node)
        {
            UpdateVisualizations();
        }

        void DynamoModel_CleaningUp(object sender, EventArgs e)
        {
            ClearVisualizations();
        }

        void DynamoModel_ModelCleared(object sender, EventArgs e)
        {
            ClearVisualizations();
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        void Selection_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            int movedItems = 0;

            //When the selection changes we move renderables from collection
            //to another. For example, if items are added, we take the visualizations
            //from the normal collections and we add them to the selected visualization.
            //When an item is removed from the selection, we put it back in the normal collection

            //process removals - any node which has a visualization, is not in the selection collection
            //and has some geometry in the selection visualization collections
            var toRemove = Visualizations.Where(x => x.Value.SelectedPoints.Count > 0 ||
                                                     x.Value.SelectedLines.Count > 0 ||
                                                     x.Value.SelectedMeshes.Count > 0)
                                         .Where(
                                             x =>
                                             !DynamoSelection.Instance.Selection.Select(
                                                 y => (y as ModelBase).GUID.ToString()).Contains(x.Key)).Select(x=>x.Value);
            foreach (var viz in toRemove)
            {
                viz.Points.AddRange(viz.SelectedPoints);
                viz.SelectedPoints.Clear();
                viz.Lines.AddRange(viz.SelectedLines);
                viz.SelectedLines.Clear();
                viz.Meshes.AddRange(viz.SelectedMeshes);
                viz.SelectedMeshes.Clear();

                movedItems++;
            }

            if (e.NewItems != null)
            {
                foreach (object item in e.NewItems)
                {
                    var node = item as NodeModel;
                    if (node == null)
                        continue;

                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        //move points, lines, and meshes to selection visuals
                        var viz = Visualizations[node.GUID.ToString()];
                        viz.SelectedPoints.AddRange(viz.Points);
                        viz.Points.Clear();
                        viz.SelectedLines.AddRange(viz.Lines);
                        viz.Lines.Clear();
                        viz.SelectedMeshes.AddRange(viz.Meshes);
                        viz.Meshes.Clear();

                        movedItems++;
                    }
                } 
            }
            
            //don't trigger an update if the changes in the selection
            //had no effect on the current visualizations
            //don't trigger an update either if the paused flag is set
            if (movedItems > 0 && !updatingPaused)
            {
                OnVisualizationUpdateComplete(this, EventArgs.Empty);
            }
                
        }

        /// <summary>
        /// Handler for the controller's RequestRedraw event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_RequestsRedraw(object sender, EventArgs e)
        {
            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the controller's EvaluationCompleted event.
        /// Requests and update to all active visualizations which are marked for update.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_EvaluationCompleted(object sender, EventArgs e)
        {
            //if there are no watches and background preview is
            //not showing, then don't update visualizations

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event. Clears the visualization for
        /// the node at the 'end' of the connector.
        /// </summary>
        /// <param name="connector"></param>
        void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            if (Visualizations.ContainsKey(connector.End.Owner.GUID.ToString()))
            {
                Visualizations.Remove(connector.End.Owner.GUID.ToString());

                //tell the watches that they require re-binding.
                //OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
                OnVisualizationUpdateComplete(this, EventArgs.Empty);
            }  
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void node_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsVisible" ||
                e.PropertyName == "IsUpstreamVisible")
            {
                UpdateVisualizations();
            }
            if (e.PropertyName == "State")
            {
                var node = sender as NodeModel;
                if (node.State == ElementState.ERROR)
                {
                    //dump the visualization
                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        Visualizations[node.GUID.ToString()].Clear();
                    }
                }
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearRenderables()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Clear());
        }

        /// <summary>
        /// Clears all visualization entries from dictionary. If you only want to clear the renderable objects
        /// use ClearRenderables.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Clear();
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            if (isUpdating)
                return;

            isUpdating = true;
            var worker = new BackgroundWorker();
            worker.DoWork += VisualizationUpdateThread;

            if(dynSettings.Controller.Testing)
                VisualizationUpdateThread(null,null);
            else
                worker.RunWorkerAsync();
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node then sends
        /// a message that a visualization is ready
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public void RenderUpstream(NodeModel node)
        {
            var rd = new RenderDescription();

            //send back just what the node needs
            var watch = new Stopwatch();
            watch.Start();

            if (node == null)
            {
                //send back everything
                rd = AggregateRenderDescriptions();
                
                StripDuplicates(rd);

                OnResultsReadyToVisualize(this, new VisualizationEventArgs(rd, string.Empty));
            }
            else
            {
                //send back renderables for the branch
                var drawables = GetUpstreamDrawableIds(node.Inputs);

                var ids = from viz in dynSettings.Controller.VisualizationManager.Visualizations
                          where drawables.Contains(viz.Key)
                          select viz;

                var keyValuePairs = ids as KeyValuePair<string, RenderDescription>[] ?? ids.ToArray();

                var pts = keyValuePairs.SelectMany(x => x.Value.Points);
                var lines = keyValuePairs.SelectMany(x => x.Value.Lines);
                var meshes = keyValuePairs.SelectMany(x => x.Value.Meshes);
                var xs = keyValuePairs.SelectMany(x => x.Value.XAxisPoints);
                var ys = keyValuePairs.SelectMany(x => x.Value.YAxisPoints);
                var zs = keyValuePairs.SelectMany(x => x.Value.ZAxisPoints);
                var pts_sel = keyValuePairs.SelectMany(x => x.Value.SelectedPoints);
                var lines_sel = keyValuePairs.SelectMany(x => x.Value.SelectedLines);
                var mesh_sel = keyValuePairs.SelectMany(x => x.Value.SelectedMeshes);

                rd.Points.AddRange(pts);
                rd.Lines.AddRange(lines);
                rd.Meshes.AddRange(meshes);
                rd.XAxisPoints.AddRange(xs);
                rd.YAxisPoints.AddRange(ys);
                rd.ZAxisPoints.AddRange(zs);
                rd.SelectedPoints.AddRange(pts_sel);
                rd.SelectedLines.AddRange(lines_sel);
                rd.SelectedMeshes.AddRange(mesh_sel);
                
                StripDuplicates(rd);

                OnResultsReadyToVisualize(this, new VisualizationEventArgs(rd, node.GUID.ToString()));
            }

            watch.Stop();
            Debug.WriteLine(String.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            //LogVisualizationUpdateData(rd, watch.Elapsed.ToString());
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private List<string> GetUpstreamDrawableIds(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<string>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;

                if(node.OldValue != null)
                    drawables.Add(node.GUID.ToString());

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamDrawableIds(node.Inputs));

            }

            return drawables;
        }

        /// <summary>
        /// A utility method for merging multiple meshes into one.
        /// </summary>
        /// <param name="meshes"></param>
        /// <returns></returns>
        public static MeshGeometry3D MergeMeshes(ThreadSafeList<MeshGeometry3D> meshes)
        {
            if (meshes.Count == 0)
                return null;

            int offset = 0;

            var builder = new MeshBuilder();

            foreach (MeshGeometry3D m in meshes)
            {
                foreach (var pos in m.Positions)
                {
                    builder.Positions.Add(pos);
                }
                foreach (var index in m.TriangleIndices)
                {
                    builder.TriangleIndices.Add(index + offset);
                }
                foreach (var norm in m.Normals)
                {
                    builder.Normals.Add(norm);
                }
                foreach (var tc in m.TextureCoordinates)
                {
                    builder.TextureCoordinates.Add(tc);
                }

                offset += m.Positions.Count;
            }

            return builder.ToMesh(false);
        }

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnVisualizationUpdateComplete(object sender, EventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        /// <summary>
        /// Called when we would like to request the clearing of any alternate drawing contexts.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnRequestAlternateContextClear(object sender, EventArgs e)
        {
            if (RequestAlternateContextClear != null)
                RequestAlternateContextClear(sender, e);
        }

        /// <summary>
        /// Helper method to get the total numbers of current renderables.
        /// </summary>
        /// <param name="pointCount"></param>
        /// <param name="lineCount"></param>
        /// <param name="meshCount"></param>
        /// <param name="xCount"></param>
        /// <param name="yCount"></param>
        /// <param name="zCount"></param>
        public void GetRenderableCounts(
            out int pointCount, out int lineCount, out int meshCount, out int xCount, out int yCount, out int zCount)
        {
            var points = Visualizations.SelectMany(x => x.Value.Points);
            var lines = Visualizations.SelectMany(x => x.Value.Lines);
            var meshes = Visualizations.SelectMany(x => x.Value.Meshes);
            var xs = Visualizations.SelectMany(x => x.Value.XAxisPoints);
            var ys = Visualizations.SelectMany(x => x.Value.YAxisPoints);
            var zs = Visualizations.SelectMany(x => x.Value.ZAxisPoints);

            pointCount = points.Count();
            lineCount = lines.Count();
            meshCount = meshes.Count();
            xCount = xs.Count();
            yCount = ys.Count();
            zCount = zs.Count();
        }
    
        public RenderDescription AggregateRenderDescriptions()
        {
            var descriptions = Visualizations.Values;

            var rd = new RenderDescription
                {
                    Points = descriptions.SelectMany(x => x.Points).ToThreadSafeList(),
                    Lines = descriptions.SelectMany(x => x.Lines).ToThreadSafeList(),
                    SelectedPoints = descriptions.SelectMany(x => x.SelectedPoints).ToThreadSafeList(),
                    SelectedLines = descriptions.SelectMany(x => x.SelectedLines).ToThreadSafeList(),
                    XAxisPoints = descriptions.SelectMany(x => x.XAxisPoints).ToThreadSafeList(),
                    YAxisPoints = descriptions.SelectMany(x => x.YAxisPoints).ToThreadSafeList(),
                    ZAxisPoints = descriptions.SelectMany(x => x.ZAxisPoints).ToThreadSafeList(),
                    Meshes = descriptions.SelectMany(x => x.Meshes).ToThreadSafeList(),
                    SelectedMeshes = descriptions.SelectMany(x => x.SelectedMeshes).ToThreadSafeList()
                };

            return rd;
        }

        /// <summary>
        /// Log visualization update timing and geometry data.
        /// </summary>
        /// <param name="rd">The aggregated render description for the model.</param>
        /// <param name="ellapsedTime">The ellapsed time of visualization as a string.</param>
        protected void LogVisualizationUpdateData(RenderDescription rd, string ellapsedTime)
        {
            var renderDict = new Dictionary<string, object>();
            renderDict["points"] = rd.Points.Count;
            renderDict["line_segments"] = rd.Lines.Count / 2;
            renderDict["mesh_facets"] = rd.Meshes.Any()
                                            ? rd.Meshes.Select(x => x.TriangleIndices.Count / 3).Aggregate((a, b) => a + b)
                                            : 0;
            renderDict["time"] = ellapsedTime;
            renderDict["manager_type"] = this.GetType().ToString();

            var renderData = JsonConvert.SerializeObject(renderDict);

            InstrumentationLogger.LogInfo("Perf-Latency-RenderGeometryGeneration", renderData);

            //Debug.WriteLine(renderData);
        }

        internal void VisualizeGeometry(NodeModel node, object geom, RenderDescription rd)
        {
            var t = geom.GetType();

            var viz = Visualizers.FirstOrDefault(x => x.Key == t || x.Key.IsAssignableFrom(t));

            //draw what's in the container
            if (viz.Value != null)
            {
                viz.Value.Invoke(node, geom, rd, octree);
            }
        }

        /// <summary>
        /// The visualization thread logic. Can be overriden in child classes.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="args"></param>
        protected virtual void VisualizationUpdateThread(object s, DoWorkEventArgs args)
        {
            try
            {
                var sw = new Stopwatch();
                sw.Start();

                octree.Clear();

                //get a dictionary of all nodes with drawable objects
                var drawable_dict = GetAllDrawablesInModel();
                
                //cleanup visualizations that no longer have drawables
                var drawableKeys = drawable_dict.Select(x => x.Key.GUID.ToString());
                var toCleanup = Visualizations.Where(x => !drawableKeys.Contains(x.Key)).ToList();
                toCleanup.ForEach(x=>Visualizations.Remove(x.Key));

                Debug.WriteLine(string.Format("{0} drawables have been removed.", toCleanup.Count));

                //add visualizations for nodes that have none
                var toAdd = drawable_dict.Where(x => !Visualizations.ContainsKey(x.Key.GUID.ToString())).ToList();
                toAdd.ForEach(RegisterNodeForVisualization);
                Debug.WriteLine(string.Format("{0} drawables have been added.", toAdd.Count));

                foreach (var drawable in drawable_dict)
                {
                    var node = drawable.Key as NodeModel;

                    var rd = Visualizations[node.GUID.ToString()];
                    rd.Clear();

                    if (node.IsVisible)
                    {
                        drawable.Value.ForEach(x => VisualizeGeometry(node, x, rd));
                    }
                }

                sw.Stop();
                Debug.WriteLine(String.Format("{0} elapsed for generating visualizations.", sw.Elapsed));

                //notify the UI of visualization completion
                OnVisualizationUpdateComplete(this, EventArgs.Empty);
            }
            catch (Exception e)
            {
                DynamoLogger.Instance.Log(e);
            }
            finally
            {
                isUpdating = false;
            }
        }

        /// <summary>
        /// Strips all duplicates from a render description.
        /// </summary>
        /// <param name="rd">A render description</param>
        private void StripDuplicates(RenderDescription rd)
        {
            var sw = new Stopwatch();
            sw.Start();

            Debug.WriteLine(string.Format("{0} line segments before stripping", rd.Lines.Count/2));

            var comp = new Point3DEqualityComparer();

            //POINTS
            var strippedPoints = rd.Points.Distinct(comp).ToList();

            //SELECTED POINTS
            var strippedSelPoints = rd.SelectedPoints.Distinct(comp).ToList();

            //LINES
            var strippedLines = StripLines(rd.Lines.ToList());

            //SELECTED LINES
            var strippedSelLines = StripLines(rd.SelectedLines.ToList());

            rd.Points.Clear();
            rd.SelectedPoints.Clear();
            rd.Lines.Clear();
            rd.SelectedLines.Clear();

            rd.Points.AddRange(strippedPoints);
            rd.SelectedPoints.AddRange(strippedSelPoints);
            rd.Lines.AddRange(strippedLines);
            rd.SelectedLines.AddRange(strippedSelLines);

            Debug.WriteLine(string.Format("{0} line segments after stripping", rd.Lines.Count / 2));

            sw.Stop();
            Debug.WriteLine(string.Format("{0} elapsed for stripping duplicate geometry.", sw.Elapsed));
        }

        private static IEnumerable<Point3D> StripLines(List<Point3D> lines)
        {
            var tupSet = new HashSet<Tuple<Point3D, Point3D>>();
            var tupComp = new Point3DTupleEqualityComparer();

            for (int i = 0; i < lines.Count; i += 2)
            {
                var lineSelTup = new Tuple<Point3D, Point3D>(lines[i], lines[i + 1]);
                if(!tupSet.Contains(lineSelTup, tupComp))
                    tupSet.Add(lineSelTup);
            }
            var strippedSelLines = new List<Point3D>();
            foreach (var t in tupSet)
            {
                strippedSelLines.Add(t.Item1);
                strippedSelLines.Add(t.Item2);
            }
            return strippedSelLines;
        }

        /// <summary>
        /// Adds a visualization to the dictionary and adds a handler for node property changes.
        /// </summary>
        /// <param name="kvp"></param>
        private void RegisterNodeForVisualization(KeyValuePair<NodeModel,List<object>> kvp)
        {
            Visualizations.Add(kvp.Key.GUID.ToString(), new RenderDescription());
            kvp.Key.PropertyChanged += node_PropertyChanged;
        }

        public void LookupSelectedElement(double x, double y, double z)
        {
            var id = octree.GetNode(x, y, z);

            if (id == null)
                return;

            var node = dynSettings.Controller.DynamoModel.Nodes.FirstOrDefault(n => n.GUID.ToString() == id.ToString());
            if (node != null && !DynamoSelection.Instance.Selection.Contains(node))
            {
                DynamoSelection.Instance.ClearSelection();
                DynamoSelection.Instance.Selection.Add(node);
            }
        }

        public void OnResultsReadyToVisualize(object sender, VisualizationEventArgs e)
        {
            if (ResultsReadyToVisualize != null)
                ResultsReadyToVisualize(sender, e);
        }

        #region utility methods

        /// <summary>
        /// Get a dictionary of all objects in the model which have visualizers associated with them,
        /// keyed by node. Filters the 
        /// </summary>
        /// <returns></returns>
        public static Dictionary<NodeModel,List<object>> GetAllDrawablesInModel()
        {
#if USE_DSENGINE
            Dictionary<NodeModel, List<object>> drawables = new Dictionary<NodeModel, List<object>>();
            foreach (var node in dynSettings.Controller.DynamoModel.Nodes)
            {
                if (node is DSFunction)
                {
                    string varName = node.AstIdentifier.Name;
                    var graphItems = EngineController.Instance.GetGraphicItems(varName);
                    if (graphItems != null)
                    {
                        List<object> drawableItems = graphItems.ConvertAll(item => (object)item);
                        drawables.Add(node, drawableItems);
                    }
                }
            }
            return drawables;
#else
            //get a list of tuples node,drawables
            var nodeTuples = dynSettings.Controller.DynamoModel.Nodes
                                        .Where(x => x.OldValue != null)
                                        .Where(
                                            x =>
                                            x.OldValue.IsList ||
                                            x.OldValue.GetType() == typeof (FScheme.Value.Container))
                                        .Where(x => x.GetType().Name != "Watch3D" && x.GetType().Name != "Watch")
                                        .Select(x => new Tuple<NodeModel, List<object>>(x, GetDrawablesFromNode(x)));

            //convert the tuple list to a dictionary, only adding
            //the lists which have items.
            var drawables = nodeTuples.Where(x=>x.Item2.Count>0).ToDictionary(tuple => tuple.Item1, tuple => tuple.Item2);

            return drawables;
#endif
        }

        /// <summary>
        /// Get all objects from a given node which have visualizers associated with them.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<object> GetDrawablesFromNode(NodeModel node)
        {
            return GetDrawableFromValue(node.OldValue);
        }

        /// <summary>
        /// Get all nodes in model that have values for which there are visualizers associated.
        /// </summary>
        /// <returns></returns>
        public static List<NodeModel> GetDrawableNodesInModel()
        {
            var nodes = dynSettings.Controller.DynamoModel.Nodes
                                   .Where(x => x.OldValue != null);

            return nodes.Where(x => GetDrawablesFromNode(x).Count > 0).ToList();
        }

        /// <summary>
        /// Returns whether a node has output which has an associated visualizer.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static bool IsNodeDrawable(NodeModel node)
        {
            return GetDrawablesFromNode(node).Count > 0;
        }

        /// <summary>
        /// Returns the objects from a Value type which have associated visualizers.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static List<object> GetDrawableFromValue(FScheme.Value value)
        {
            
            var drawables = new List<object>();

            if (value == null)
            {
                return drawables;
            }

            var viz = dynSettings.Controller.VisualizationManager;

            if (value.IsList)
            {
                foreach (var val_inner in ((FScheme.Value.List)value).Item)
                {
                    drawables.AddRange(GetDrawableFromValue(val_inner));
                }
                return drawables;
            }

            var container = value as FScheme.Value.Container;
            if (container == null)
                return drawables;

            var obj = ((FScheme.Value.Container)container).Item;

            if (obj != null)
            {
                var t = obj.GetType();
                var visualizer = viz.Visualizers.FirstOrDefault(x => x.Key == t || x.Key.IsAssignableFrom(t));

                if (visualizer.Value != null)
                {
                    drawables.Add(obj);
                }
            }

            return drawables;
        }

        public static NodeModel FindNodeWithDrawable(object drawable)
        {
            return GetDrawableNodesInModel().FirstOrDefault(x => GetDrawableFromValue(x.OldValue).Contains(drawable));
        }

        #endregion
    }

    public class VisualizationEventArgs : EventArgs
    {
        /// <summary>
        /// The render description.
        /// </summary>
        public RenderDescription Description { get; internal set; }

        /// <summary>
        /// The id of the view for which the description belongs.
        /// </summary>
        public string Id { get; internal set; }

        public VisualizationEventArgs(RenderDescription description, string viewId)
        {
            Description = description;
            Id = viewId;
        }
    }

    class Point3DTupleEqualityComparer : IEqualityComparer<Tuple<Point3D, Point3D>>
    {
        public bool Equals(Tuple<Point3D, Point3D> x, Tuple<Point3D, Point3D> y)
        {
            var comp = new Point3DEqualityComparer();

            //if a1 and b1 are equal and a2 and b2 are equal or
            //a1 and b2 are equal and a2 and b1 are equal
            if ((comp.Equals(x.Item1, y.Item1) && comp.Equals(x.Item2, y.Item2)) ||
                (comp.Equals(x.Item1, y.Item2) && comp.Equals(x.Item2, y.Item1)))
            {
                return true;
            }

            return false;
        }

        public int GetHashCode(Tuple<Point3D, Point3D> obj)
        {
            double hCode = obj.Item1.X + obj.Item1.Y + obj.Item1.Z + obj.Item2.X + obj.Item2.Y + obj.Item2.Z;
            return hCode.GetHashCode();
        }
    }

    class Point3DEqualityComparer : IEqualityComparer<Point3D>
    {
        private const double epsilon = 0.0001;

        public bool Equals(Point3D x, Point3D y)
        {
            if (Math.Abs(x.X - y.X) < epsilon &&
                Math.Abs(x.Y - y.Y) < epsilon &&
                Math.Abs(x.Z - y.Z) < epsilon)
            {
                return true;
            }

            return false;
        }

        public int GetHashCode(Point3D obj)
        {
            double hCode = obj.X + obj.Y + obj.Z;
            return hCode.GetHashCode();
        }
    }
}
