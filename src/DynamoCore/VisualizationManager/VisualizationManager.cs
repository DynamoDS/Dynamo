using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows.Media.Media3D;
using System.Linq;
using Autodesk.LibG;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Selection;
using Dynamo.Services;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;
using Newtonsoft.Json;
using String = System.String;

//testing to see if github integration works.

namespace Dynamo
{
    public delegate void VisualizationCompleteEventHandler(object sender, VisualizationEventArgs e);

    public delegate void VisualizerDelegate(NodeModel node, object geom, RenderDescription target);

    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public abstract class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, RenderDescription> visualizations 
            = new Dictionary<string, RenderDescription>();

        private Dictionary<Type, VisualizerDelegate> visualizers 
            = new Dictionary<Type, VisualizerDelegate>(); 

        private string _alternateContextName = "Host";
        private bool _drawToAlternateContext = true;
        private object myLock = new object();
        protected bool isUpdating = false;

        #endregion

        #region public properties

        /// <summary>
        /// A dictionary of objects to be stored for visualization.
        /// </summary>
        public Dictionary<string, RenderDescription> Visualizations
        {
            get
            {
                lock (myLock)
                {
                    return visualizations; 
                }
            }
            set
            {
                lock (myLock)
                {
                    visualizations = value;
                }
            }
        }

        public Dictionary<Type, VisualizerDelegate> Visualizers
        {
            get { return visualizers; }
            set { visualizers = value; }
        }

        /// <summary>
        /// Is another context available for drawing?
        /// This property can be queried indirectly by the view to enable or disable
        /// UI functionality based on whether an alternate drawing context is available.
        /// </summary>
        public bool AlternateDrawingContextAvailable { get; set; }

        /// <summary>
        /// Should we draw to the alternate context if it is available?
        /// </summary>
        public bool DrawToAlternateContext
        {
            get { return _drawToAlternateContext; }
            set
            {
                if (value == false)
                {
                    //if the present value has us drawing to the alternate
                    //context and we would like to stop doing so, we need 
                    //to trigger an event requesting alternate contexts
                    //to drop their visualizations
                    if (_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnRequestAlternateContextClear(this, EventArgs.Empty);
                    }
                }
                else
                {
                    //we would like to reenable drawing to an alternate context.
                    //trigger the standard visualization complete event
                    if (!_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
                    }
                }
            }
        }

        /// <summary>
        /// Can be used to expose a name of the alternate context for use in the UI.
        /// </summary>
        public string AlternateContextName
        {
            get { return _alternateContextName; }
            set { _alternateContextName = value; }
        }

        #endregion

        #region events

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event VisualizationCompleteEventHandler VisualizationUpdateComplete;

        /// <summary>
        /// An event triggered when want any alternate drawing contexts to be cleared.
        /// </summary>
        public event EventHandler RequestAlternateContextClear;

        #endregion

        protected VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.NodeAdded += new NodeHandler(DynamoModel_NodeAdded);
            dynSettings.Controller.DynamoModel.NodeDeleted += new NodeHandler(DynamoModel_NodeDeleted);
            dynSettings.Controller.DynamoModel.ConnectorDeleted += new ConnectorHandler(DynamoModel_ConnectorDeleted);
            dynSettings.Controller.EvaluationCompleted += new EventHandler(Controller_EvaluationCompleted);
            dynSettings.Controller.RequestsRedraw += new EventHandler(Controller_RequestsRedraw);
            DynamoSelection.Instance.Selection.CollectionChanged += new NotifyCollectionChangedEventHandler(Selection_CollectionChanged);
            dynSettings.Controller.DynamoModel.ModelCleared += new EventHandler(DynamoModel_ModelCleared);
            dynSettings.Controller.DynamoModel.CleaningUp += new CleanupHandler(DynamoModel_CleaningUp);

            Visualizers.Add(typeof(GraphicItem), VisualizationManagerASM.DrawLibGGraphicItem);
        }

        void DynamoModel_CleaningUp(object sender, EventArgs e)
        {
            ClearVisualizations();
        }

        void DynamoModel_ModelCleared(object sender, EventArgs e)
        {
            ClearVisualizations();
            OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
        }

        void Selection_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            int movedItems = 0;

            //When the selection changes we move renderables from collection
            //to another. For example, if items are added, we take the visualizations
            //from the normal collections and we add them to the selected visualization.
            //When an item is removed from the selection, we put it back in the normal collection

            //process removals - any node which has a visualization, is not in the selection collection
            //and has some geometry in the selection visualization collections
            var toRemove = Visualizations.Where(x => x.Value.SelectedPoints.Count > 0 ||
                                                     x.Value.SelectedLines.Count > 0 ||
                                                     x.Value.SelectedMeshes.Count > 0)
                                         .Where(
                                             x =>
                                             !DynamoSelection.Instance.Selection.Select(
                                                 y => (y as NodeModel).GUID.ToString()).Contains(x.Key)).Select(x=>x.Value);
            foreach (var viz in toRemove)
            {
                viz.Points.AddRange(viz.SelectedPoints);
                viz.SelectedPoints.Clear();
                viz.Lines.AddRange(viz.SelectedLines);
                viz.SelectedLines.Clear();
                viz.Meshes.AddRange(viz.SelectedMeshes);
                viz.SelectedMeshes.Clear();

                movedItems++;
            }

            if (e.NewItems != null)
            {
                foreach (object item in e.NewItems)
                {
                    var node = item as NodeModel;
                    if (node == null)
                        continue;

                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        //move points, lines, and meshes to selection visuals
                        var viz = Visualizations[node.GUID.ToString()];
                        viz.SelectedPoints.AddRange(viz.Points);
                        viz.Points.Clear();
                        viz.SelectedLines.AddRange(viz.Lines);
                        viz.Lines.Clear();
                        viz.SelectedMeshes.AddRange(viz.Meshes);
                        viz.Meshes.Clear();

                        movedItems++;
                    }
                } 
            }
            
            //don't trigger an update if the changes in the selection
            //had no effect on the current visualizations
            if(movedItems > 0)
                OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
        }

        /// <summary>
        /// Handler for the controller's RequestRedraw event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_RequestsRedraw(object sender, EventArgs e)
        {
            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the controller's EvaluationCompleted event.
        /// Requests and update to all active visualizations which are marked for update.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_EvaluationCompleted(object sender, EventArgs e)
        {
            //if there are no watches and background preview is
            //not showing, then don't update visualizations

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event. Clears the visualization for
        /// the node at the 'end' of the connector.
        /// </summary>
        /// <param name="connector"></param>
        void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            if (Visualizations.ContainsKey(connector.End.Owner.GUID.ToString()))
            {
                Visualizations.Remove(connector.End.Owner.GUID.ToString());

                //tell the watches that they require re-binding.
                OnVisualizationUpdateComplete(this, new VisualizationEventArgs(AggregateRenderDescriptions()));
            }  
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event. Unregisters a node from visualization.
        /// Triggers an update to the visualizations after un-registering a node
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeDeleted(NodeModel node)
        {
            UnregisterFromVisualization(node);
        }

        /// <summary>
        /// Handler for the model's NodeAdded event. Registers a node for visualization.
        /// Triggers an update to the visualizations after registering a node.
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeAdded(NodeModel node)
        {
            RegisterForVisualization(node);
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void node_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsVisible" ||
                e.PropertyName == "IsUpstreamVisible")
            {
                UpdateVisualizations();
            }
            if (e.PropertyName == "State")
            {
                var node = sender as NodeModel;
                if (node.State == ElementState.ERROR)
                {
                    //dump the visualization
                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        Visualizations[node.GUID.ToString()].Clear();
                    }
                }
            }
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Add(node.GUID.ToString(), new RenderDescription());
            }

            node.PropertyChanged += node_PropertyChanged;
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearRenderables()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Clear());
        }

        /// <summary>
        /// Clears all visualization entries from dictionary. If you only want to clear the renderable objects
        /// use ClearRenderables.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Clear();
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            if (isUpdating)
                return;

            isUpdating = true;
            var worker = new BackgroundWorker();
            worker.DoWork += VisualizationUpdateThread;

            if(dynSettings.Controller.Testing)
                VisualizationUpdateThread(null,null);
            else
                worker.RunWorkerAsync();
        }

        /// <summary>
        /// When a node enters it's evaluation, it is flagged for requiring update.
        /// We dump the geometry collection and the render descption.
        /// This ensures that, if the node errors, it will render nothing.
        /// </summary>
        /// <param name="node">The node whose visualization will be updated.</param>
        public void MarkForUpdate(NodeModel node)
        {
            //re-register the node if this call is coming from a place
            //where the node got dropped from visualization but then
            //was re-added
            if(!visualizations.ContainsKey(node.GUID.ToString()))
                RegisterForVisualization(node);

            var v = Visualizations[node.GUID.ToString()];
            
            //clear the gometry collection and the render description
            //the geometry collection will be filled during update.
            v.Clear();
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node.
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public RenderDescription RenderUpstream(NodeModel node)
        {
            var watch = new Stopwatch();
            watch.Start();

            var drawables = GetUpstreamDrawableIds(node.Inputs);
            
            var ids = from viz in dynSettings.Controller.VisualizationManager.Visualizations
                      where drawables.Contains(viz.Key)
                      select viz;

            var rd = new RenderDescription();

            var keyValuePairs = ids as KeyValuePair<string, RenderDescription>[] ?? ids.ToArray();

            var pts = keyValuePairs.SelectMany(x => x.Value.Points);
            var lines = keyValuePairs.SelectMany(x => x.Value.Lines);
            var meshes = keyValuePairs.SelectMany(x => x.Value.Meshes);
            var xs = keyValuePairs.SelectMany(x => x.Value.XAxisPoints);
            var ys = keyValuePairs.SelectMany(x => x.Value.YAxisPoints);
            var zs = keyValuePairs.SelectMany(x => x.Value.ZAxisPoints);
            var pts_sel = keyValuePairs.SelectMany(x => x.Value.SelectedPoints);
            var lines_sel = keyValuePairs.SelectMany(x => x.Value.SelectedLines);
            var mesh_sel = keyValuePairs.SelectMany(x => x.Value.SelectedMeshes);

            rd.Points.AddRange(pts);
            rd.Lines.AddRange(lines);
            rd.Meshes.AddRange(meshes);
            rd.XAxisPoints.AddRange(xs);
            rd.YAxisPoints.AddRange(ys);
            rd.ZAxisPoints.AddRange(zs);
            rd.SelectedPoints.AddRange(pts_sel);
            rd.SelectedLines.AddRange(lines_sel);
            rd.SelectedMeshes.AddRange(mesh_sel);

            watch.Stop();
            Debug.WriteLine(String.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            return rd;
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private List<string> GetUpstreamDrawableIds(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<string>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;

                if(node.OldValue != null)
                    drawables.Add(node.GUID.ToString());

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamDrawableIds(node.Inputs));
            }

            return drawables;
        }

        /// <summary>
        /// A utility method for merging multiple meshes into one.
        /// </summary>
        /// <param name="meshes"></param>
        /// <returns></returns>
        public static MeshGeometry3D MergeMeshes(ThreadSafeList<MeshGeometry3D> meshes)
        {
            if (meshes.Count == 0)
                return null;

            int offset = 0;

            var builder = new MeshBuilder();

            foreach (MeshGeometry3D m in meshes)
            {
                foreach (var pos in m.Positions)
                {
                    builder.Positions.Add(pos);
                }
                foreach (var index in m.TriangleIndices)
                {
                    builder.TriangleIndices.Add(index + offset);
                }
                foreach (var norm in m.Normals)
                {
                    builder.Normals.Add(norm);
                }
                foreach (var tc in m.TextureCoordinates)
                {
                    builder.TextureCoordinates.Add(tc);
                }

                offset += m.Positions.Count;
            }

            return builder.ToMesh(false);
        }

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnVisualizationUpdateComplete(object sender, VisualizationEventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        /// <summary>
        /// Called when we would like to request the clearing of any alternate drawing contexts.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnRequestAlternateContextClear(object sender, EventArgs e)
        {
            if (RequestAlternateContextClear != null)
                RequestAlternateContextClear(sender, e);
        }

        /// <summary>
        /// Helper method to get the total numbers of current renderables.
        /// </summary>
        /// <param name="pointCount"></param>
        /// <param name="lineCount"></param>
        /// <param name="meshCount"></param>
        /// <param name="xCount"></param>
        /// <param name="yCount"></param>
        /// <param name="zCount"></param>
        public void GetRenderableCounts(
            out int pointCount, out int lineCount, out int meshCount, out int xCount, out int yCount, out int zCount)
        {
            var points = Visualizations.SelectMany(x => x.Value.Points);
            var lines = Visualizations.SelectMany(x => x.Value.Lines);
            var meshes = Visualizations.SelectMany(x => x.Value.Meshes);
            var xs = Visualizations.SelectMany(x => x.Value.XAxisPoints);
            var ys = Visualizations.SelectMany(x => x.Value.YAxisPoints);
            var zs = Visualizations.SelectMany(x => x.Value.ZAxisPoints);

            pointCount = points.Count();
            lineCount = lines.Count();
            meshCount = meshes.Count();
            xCount = xs.Count();
            yCount = ys.Count();
            zCount = zs.Count();
        }
    
        public RenderDescription AggregateRenderDescriptions()
        {
            var descriptions = Visualizations.Values;

            var rd = new RenderDescription
                {
                    Points = descriptions.SelectMany(x => x.Points).ToThreadSafeList(),
                    Lines = descriptions.SelectMany(x => x.Lines).ToThreadSafeList(),
                    SelectedPoints = descriptions.SelectMany(x => x.SelectedPoints).ToThreadSafeList(),
                    SelectedLines = descriptions.SelectMany(x => x.SelectedLines).ToThreadSafeList(),
                    XAxisPoints = descriptions.SelectMany(x => x.XAxisPoints).ToThreadSafeList(),
                    YAxisPoints = descriptions.SelectMany(x => x.YAxisPoints).ToThreadSafeList(),
                    ZAxisPoints = descriptions.SelectMany(x => x.ZAxisPoints).ToThreadSafeList(),
                    Meshes = descriptions.SelectMany(x => x.Meshes).ToThreadSafeList(),
                    SelectedMeshes = descriptions.SelectMany(x => x.SelectedMeshes).ToThreadSafeList()
                };

            return rd;
        }

        /// <summary>
        /// Log visualization update timing and geometry data.
        /// </summary>
        /// <param name="rd">The aggregated render description for the model.</param>
        /// <param name="ellapsedTime">The ellapsed time of visualization as a string.</param>
        protected void LogVisualizationUpdateData(RenderDescription rd, string ellapsedTime)
        {
            var renderDict = new Dictionary<string, object>();
            renderDict["points"] = rd.Points.Count;
            renderDict["line_segments"] = rd.Lines.Count / 2;
            renderDict["mesh_facets"] = rd.Meshes.Any()
                                            ? rd.Meshes.Select(x => x.TriangleIndices.Count / 3).Aggregate((a, b) => a + b)
                                            : 0;
            renderDict["time"] = ellapsedTime;
            renderDict["manager_type"] = this.GetType().ToString();

            var renderData = JsonConvert.SerializeObject(renderDict);

            InstrumentationLogger.LogInfo("Perf-Latency-RenderGeometryGeneration", renderData);

            //Debug.WriteLine(renderData);
        }

        internal void VisualizeGeometry(NodeModel node, object geom, RenderDescription rd)
        {
            var t = geom.GetType();

            var viz = Visualizers.FirstOrDefault(x => x.Key == t || x.Key.IsAssignableFrom(t));

            //draw what's in the container
            if (viz.Value != null)
            {
                viz.Value.Invoke(node, geom, rd);
            }
        }

        /// <summary>
        /// The visualization thread logic. Can be overriden in child classes.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="args"></param>
        protected virtual void VisualizationUpdateThread(object s, DoWorkEventArgs args)
        {
            var drawable_dict = GetAllDrawablesInModel();

            Debug.WriteLine(String.Format("{0} visualizations to update", drawable_dict.Count()));
            //Debug.WriteLine(String.Format("Updating visualizations on thread {0}.", Thread.CurrentThread.ManagedThreadId));

            var sw = new Stopwatch();
            sw.Start();

            foreach (var drawable in drawable_dict)
            {
                var node = drawable.Key as NodeModel;

                if (!visualizations.ContainsKey(node.GUID.ToString()))
                    continue;

                var rd = Visualizations[node.GUID.ToString()];
                rd.Clear();

                if (node.IsVisible)
                {
                    drawable.Value.ForEach(x=>VisualizeGeometry(node, x, rd));
                }   
            }

            sw.Stop();
            Debug.WriteLine(String.Format("{0} elapsed for generating visualizations.", sw.Elapsed));

            //generate an aggregated render description to send to the UI
            var aggRd = AggregateRenderDescriptions();

            LogVisualizationUpdateData(aggRd, sw.Elapsed.ToString());

            //notify the UI of visualization completion
            OnVisualizationUpdateComplete(this, new VisualizationEventArgs(aggRd));

            isUpdating = false;
        }

        #region utility methods

        /// <summary>
        /// Get a dictionary of all objects in the model which have visualizers associated with them,
        /// keyed by node. Filters the 
        /// </summary>
        /// <returns></returns>
        public static Dictionary<NodeModel,List<object>> GetAllDrawablesInModel()
        {
            //get a list of tuples node,drawables
            var nodeTuples = dynSettings.Controller.DynamoModel.Nodes
                                        .Where(x => x.OldValue != null)
                                        .Where(
                                            x =>
                                            x.OldValue.IsList ||
                                            x.OldValue.GetType() == typeof (FScheme.Value.Container))
                                        .Where(x => x.GetType().Name != "Watch3D" && x.GetType().Name != "Watch")
                                        .Select(x => new Tuple<NodeModel, List<object>>(x, GetDrawablesFromNode(x)));

            //convert the tuple list to a dictionary, only adding
            //the lists which have items.
            var drawables = nodeTuples.Where(x=>x.Item2.Count>0).ToDictionary(tuple => tuple.Item1, tuple => tuple.Item2);

            return drawables;
        }

        /// <summary>
        /// Get all objects from a given node which have visualizers associated with them.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<object> GetDrawablesFromNode(NodeModel node)
        {
            return GetDrawableFromValue(node.OldValue);
        }

        /// <summary>
        /// Get all nodes in model that have values for which there are visualizers associated.
        /// </summary>
        /// <returns></returns>
        public static List<NodeModel> GetDrawableNodesInModel()
        {
            var nodes = dynSettings.Controller.DynamoModel.Nodes
                                   .Where(x => x.OldValue != null);

            return nodes.Where(x => GetDrawablesFromNode(x).Count > 0).ToList();
        }

        /// <summary>
        /// Returns whether a node has output which has an associated visualizer.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static bool IsNodeDrawable(NodeModel node)
        {
            return GetDrawablesFromNode(node).Count > 0;
        }

        /// <summary>
        /// Returns the objects from a Value type which have associated visualizers.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static List<object> GetDrawableFromValue(FScheme.Value value)
        {
            var drawables = new List<object>();

            var viz = dynSettings.Controller.VisualizationManager;

            if (value.IsList)
            {
                foreach (var val_inner in ((FScheme.Value.List)value).Item)
                {
                    drawables.AddRange(GetDrawableFromValue(val_inner));
                }
                return drawables;
            }

            var container = value as FScheme.Value.Container;
            if (container == null)
                return drawables;

            var obj = ((FScheme.Value.Container)container).Item;

            if (obj != null)
            {
                var t = obj.GetType();
                var visualizer = viz.Visualizers.FirstOrDefault(x => x.Key == t || x.Key.IsAssignableFrom(t));

                if (visualizer.Value != null)
                {
                    drawables.Add(obj);
                }
            }

            return drawables;
        }

        public static NodeModel FindNodeWithDrawable(object drawable)
        {
            return GetDrawableNodesInModel().FirstOrDefault(x => GetDrawableFromValue(x.OldValue).Contains(drawable));
        }

        #endregion
    }

    public class VisualizationEventArgs : EventArgs
    {
        public RenderDescription Description { get; internal set; }
        public VisualizationEventArgs(RenderDescription description)
        {
            Description = description;
        }
    }
}
