using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Linq;
using Autodesk.DesignScript.Interfaces;
using Dynamo.Models;
using Dynamo.Selection;
using Dynamo.Utilities;
using Microsoft.Practices.Prism.ViewModel;
using Dynamo.DSEngine;

namespace Dynamo
{
    public delegate void VisualizationCompleteEventHandler(object sender, EventArgs e);

    public delegate void ResultsReadyHandler(object sender, VisualizationEventArgs e);

    public delegate void VisualizerDelegate(NodeModel node, object geom, string tag, RenderDescription target, Octree.OctreeSearch.Octree octree);

    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject
    {
        #region private members

        private string _alternateContextName = "Host";
        private bool _drawToAlternateContext = true;
        protected bool isUpdating = false;
        private Octree.OctreeSearch.Octree octree;
        private bool updatingPaused = false;
        private DynamoController _controller;
        private List<RenderPackage> _currentTaggedPackages = new List<RenderPackage>();

        #endregion

        #region public properties

        /// <summary>
        /// Flag allows us to pause visualization updates.
        /// </summary>
        public bool UpdatingPaused
        {
            get { return updatingPaused; }
            set
            {
                if (updatingPaused && value == false)
                {
                    //OnVisualizationUpdateComplete(this, EventArgs.Empty);
                    UpdateRenderPackages();
                }
                Debug.WriteLine("Updating paused = " + value.ToString());
                updatingPaused = value;
            }
        }

        /// <summary>
        /// Is another context available for drawing?
        /// This property can be queried indirectly by the view to enable or disable
        /// UI functionality based on whether an alternate drawing context is available.
        /// </summary>
        public bool AlternateDrawingContextAvailable { get; set; }

        /// <summary>
        /// Should we draw to the alternate context if it is available?
        /// </summary>
        public bool DrawToAlternateContext
        {
            get { return _drawToAlternateContext; }
            set
            {
                if (value == false)
                {
                    //if the present value has us drawing to the alternate
                    //context and we would like to stop doing so, we need 
                    //to trigger an event requesting alternate contexts
                    //to drop their visualizations
                    if (_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnRequestAlternateContextClear(this, EventArgs.Empty);
                    }
                }
                else
                {
                    //we would like to reenable drawing to an alternate context.
                    //trigger the standard visualization complete event
                    if (!_drawToAlternateContext)
                    {
                        _drawToAlternateContext = value;
                        OnVisualizationUpdateComplete(this, EventArgs.Empty);
                    }
                }
            }
        }

        /// <summary>
        /// Can be used to expose a name of the alternate context for use in the UI.
        /// </summary>
        public string AlternateContextName
        {
            get { return _alternateContextName; }
            set { _alternateContextName = value; }
        }

        public Octree.OctreeSearch.Octree Octree
        {
            get { return octree; }
            set { octree = value; }
        }

        #endregion

        #region events

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event VisualizationCompleteEventHandler VisualizationUpdateComplete;

        /// <summary>
        /// An event triggered when want any alternate drawing contexts to be cleared.
        /// </summary>
        public event EventHandler RequestAlternateContextClear;

        /// <summary>
        /// An event triggered when there are results to visualize
        /// </summary>
        public event ResultsReadyHandler ResultsReadyToVisualize;

        #endregion

        public VisualizationManager(DynamoController controller)
        {
            _controller = controller;

            _controller.EvaluationCompleted += Update;
            _controller.RequestsRedraw += Update;
            _controller.DynamoModel.ModelCleared += Clear;
            _controller.DynamoModel.CleaningUp += Clear;

            _controller.DynamoModel.ConnectorDeleted += DynamoModel_ConnectorDeleted;

            DynamoSelection.Instance.Selection.CollectionChanged += SelectionChanged;

            _controller.DynamoModel.NodeAdded += NodeAdded;
            _controller.DynamoModel.NodeDeleted += NodeDeleted;

            octree = new Octree.OctreeSearch.Octree(10000,-10000,10000,-10000,10000,-10000,10000000);
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event.
        /// </summary>
        /// <param name="node"></param>
        void NodeDeleted(NodeModel node)
        {
            node.PropertyChanged -= NodePropertyChanged;
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        /// <summary>
        /// Handler for the model's NodeAdded event.
        /// Registers for property changed events on the node.
        /// </summary>
        /// <param name="node"></param>
        void NodeAdded(NodeModel node)
        {
            node.PropertyChanged += NodePropertyChanged;
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void NodePropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsVisible" ||
                e.PropertyName == "IsUpstreamVisible" ||
                e.PropertyName == "DisplayLabels")
            {
                UpdateRenderPackages();
            }
        }
        
        void SelectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Reset)
                return;

            if (updatingPaused || dynSettings.Controller == null)
                return;

            var changes = new List<ISelectable>();

            // Any node that has a visualizations but is
            // no longer in the selection 
            changes.AddRange(dynSettings.Controller.DynamoModel.Nodes
                .Where(x => x.RenderPackages.Count > 0)
                .Where(x => !DynamoSelection.Instance.Selection.Contains(x)));

            if (e.NewItems != null && e.NewItems.Cast<ISelectable>().Any())
            {
                changes.AddRange(e.NewItems.Cast<ISelectable>());
            }

            UpdateRenderPackages(
            changes.Any() ?
            changes.Where(sel => sel is NodeModel).Cast<NodeModel>() :
            null);
        }

        /// <summary>
        /// Handler for the controller's RequestRedraw event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Update(object sender, EventArgs e)
        {
            UpdateRenderPackages();
        }

        void Clear(object sender, EventArgs e)
        {
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event.
        /// </summary>
        /// <param name="connector"></param>
        void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            //we are given the connector that was deleted
            //if it's end node still exists, clear the package for 
            //the node and trigger an update.
            if(connector.End != null)
                connector.End.Owner.RenderPackages.ForEach(x=>x.Clear());

            //tell the watches that they require re-binding.
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        /// <summary>
        /// Finds all nodes marked as upated in the graph and calls their,
        /// update methods in paralell.
        /// </summary>
        private void UpdateRenderPackages(IEnumerable<NodeModel> toUpdate = null)
        {
            if (_controller == null)
                return;

            if (isUpdating)
                return;

            isUpdating = true;
            var worker = new BackgroundWorker();

            worker.DoWork += UpdateRenderPackagesThread;

            if (DynamoController.IsTestMode)
                UpdateRenderPackagesThread(null, new DoWorkEventArgs(toUpdate));
            else
                worker.RunWorkerAsync(toUpdate);   
        }

        void UpdateRenderPackagesThread(object sender, DoWorkEventArgs e)
        {
            try
            {
                //If the the event arguments contains a list of nodes,
                //then update those nodes, otherwise process any nodes
                //that are marked for updating.

                var toUpdate = e.Argument as IEnumerable<NodeModel> ??
                               _controller.DynamoModel.Nodes.Where(node => node.IsUpdated || node.RequiresRecalc);

                var nodeModels = toUpdate as IList<NodeModel> ?? toUpdate.ToList();
                if (!nodeModels.Any())
                    return;

                nodeModels.ToList().ForEach(x => x.UpdateRenderPackage());

                //Setup the octree. An optimization would defer this operation until
                //a short while after update operations are complete to avoid
                //to many rebuilds of this index while building dynamically.
                if(!DynamoController.IsTestMode)
                    SetupOctree(nodeModels);

                //Debug.WriteLine(string.Format("Visualization updating {0} objects", toUpdate.Count()));
                OnVisualizationUpdateComplete(this, EventArgs.Empty);

            }
            catch (Exception ex)
            {
                DynamoLogger.Instance.Log(ex);
            }
            finally
            {
                isUpdating = false;
            }
        }

        /// <summary>
        /// Setup a spatial index for triangle vertex locations to 
        /// be used in selection operations.
        /// </summary>
        /// <param name="toUpdate"></param>
        private void SetupOctree(IEnumerable<NodeModel> toUpdate)
        {
            octree.Clear();
            foreach (var node in toUpdate)
            {
                var packages = node.RenderPackages;
                foreach (var p in packages)
                {
                    for (int i = 0; i < p.TriangleVertices.Count - 3; i += 3)
                    {
                        var a = p.TriangleVertices[i];
                        var b = p.TriangleVertices[i + 1];
                        var c = p.TriangleVertices[i + 2];
                        octree.AddNode(a, b, c, node.GUID.ToString());
                    }
                }
            }
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node then sends
        /// a message that a visualization is ready
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public void AggregateUpstreamRenderPackages(NodeModel node)
        {
            IEnumerable<IRenderPackage> packages; 

            //send back just what the node needs
            var watch = new Stopwatch();
            watch.Start();

            if (node == null)
            {
                //send back everything
                packages =
                    _controller.DynamoModel.Nodes.SelectMany(x=>x.RenderPackages);

                if (packages.Any())
                {
                    // if there are packages, send any that aren't empty
                    OnResultsReadyToVisualize(this,
                        new VisualizationEventArgs(
                            packages.Where(x => ((RenderPackage) x).IsNotEmpty()).Cast<RenderPackage>(), string.Empty));
                }
                else
                {
                    // if there are no packages, still trigger an update
                    // so the view gets redrawn
                    OnResultsReadyToVisualize(this,
                        new VisualizationEventArgs(packages.Cast<RenderPackage>(), string.Empty));
                }
                    
            }
            else
            {
                //send back renderables for the branch
                packages = GetUpstreamPackages(node.Inputs);
                if (packages.Any())
                    OnResultsReadyToVisualize(this, new VisualizationEventArgs(packages.Where(x => ((RenderPackage)x).IsNotEmpty()).Cast<RenderPackage>(), node.GUID.ToString()));
            }

            watch.Stop();
            //Debug.WriteLine(String.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            //LogVisualizationUpdateData(rd, watch.Elapsed.ToString());
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private IEnumerable<IRenderPackage> GetUpstreamPackages(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var packages = new List<IRenderPackage>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;

                //We no longer depend on OldValue, as long as the given node has
                //registered it's render description with Visualization manager
                //we will be able to visualize the given node. -Sharad
                if(node != null)
                    packages.AddRange(node.RenderPackages);

                if (node.IsUpstreamVisible)
                    packages.AddRange(GetUpstreamPackages(node.Inputs));
            }

            return packages;
        }

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnVisualizationUpdateComplete(object sender, EventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        /// <summary>
        /// Called when we would like to request the clearing of any alternate drawing contexts.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnRequestAlternateContextClear(object sender, EventArgs e)
        {
            if (RequestAlternateContextClear != null)
                RequestAlternateContextClear(sender, e);
        }

        /// <summary>
        /// Log visualization update timing and geometry data.
        /// </summary>
        /// <param name="rd">The aggregated render description for the model.</param>
        /// <param name="ellapsedTime">The ellapsed time of visualization as a string.</param>
        //protected void LogVisualizationUpdateData(RenderDescription rd, string ellapsedTime)
        //{
        //    var renderDict = new Dictionary<string, object>();
        //    renderDict["points"] = rd.Points.Count;
        //    renderDict["line_segments"] = rd.Lines.Count / 2;
        //    renderDict["mesh_facets"] = rd.Meshes.Any()
        //                                    ? rd.Meshes.Select(x => x.TriangleIndices.Count / 3).Aggregate((a, b) => a + b)
        //                                    : 0;
        //    renderDict["time"] = ellapsedTime;
        //    renderDict["manager_type"] = this.GetType().ToString();

        //    var renderData = JsonConvert.SerializeObject(renderDict);

        //    InstrumentationLogger.LogInfo("Perf-Latency-RenderGeometryGeneration", renderData);

        //    //Debug.WriteLine(renderData);
        //}

        /// <summary>
        /// Lookup a node from a location selected on geometry in the scene.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        public void LookupSelectedElement(double x, double y, double z)
        {
            var id = octree.GetNode(x, y, z);

            if (id == null)
                return;

            var node = _controller.DynamoModel.Nodes.FirstOrDefault(n => n.GUID.ToString() == id.ToString());
            if (node != null && !DynamoSelection.Instance.Selection.Contains(node))
            {
                DynamoSelection.Instance.ClearSelection();
                DynamoSelection.Instance.Selection.Add(node);
            }
        }

        /// <summary>
        /// Display a label for one or several render packages 
        /// based on the paths of those render packages.
        /// </summary>
        /// <param name="path"></param>
        public void TagRenderPackageForPath(string path)
        {
            var packages =
                dynSettings.Controller.DynamoModel.Nodes.SelectMany(x => x.RenderPackages)
                    .Where(x => x.Tag == path || x.Tag.Contains(path + ":"))
                    .Cast<RenderPackage>();

            if (packages.Any())
            {
                //clear any labels that might have been drawn on this
                //package already and add the one we want
                if (_currentTaggedPackages.Any())
                {
                    _currentTaggedPackages.ForEach(x=>x.DisplayLabels = false);
                    _currentTaggedPackages.Clear();
                }

                packages.ToList().ForEach(x => x.DisplayLabels = true);
                _currentTaggedPackages.AddRange(packages);

                //send back everything
                var allPackages =
                    _controller.DynamoModel.Nodes.SelectMany(x => x.RenderPackages)
                        .Where(x => ((RenderPackage) x).IsNotEmpty())
                        .Cast<RenderPackage>();

                OnResultsReadyToVisualize(this,
                        new VisualizationEventArgs(
                            allPackages, string.Empty));
            }
        }

        public void OnResultsReadyToVisualize(object sender, VisualizationEventArgs e)
        {
            if (ResultsReadyToVisualize != null)
                ResultsReadyToVisualize(sender, e);
        }

        #region utility methods

        /// <summary>
        /// Returns the objects from a Value type which have associated visualizers 
        /// along with a string tag representing the array index of the value, i.e. [0][5][3]
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        //public static Dictionary<string,object> GetDrawableFromValue(List<int> chain, FScheme.Value value)
        //{
        //    //var drawables = new List<object>();
        //    var drawables = new Dictionary<string, object>();

        //    if (value == null)
        //    {
        //        return drawables;
        //    }

        //    var viz = dynSettings.Controller.VisualizationManager;

        //    if (value.IsList)
        //    {
        //        int count = 0;
        //        foreach (var val_inner in ((FScheme.Value.List)value).Item)
        //        {
        //            var subChain = new List<int>(chain);
        //            subChain.Add(count);
        //            var innerDrawables = GetDrawableFromValue(subChain, val_inner);
        //            innerDrawables.ToList().ForEach(x=>drawables.Add(x.Key, x.Value));

        //            count++;
        //        }
        //        return drawables;
        //    }

        //    var container = value as FScheme.Value.Container;
        //    if (container == null)
        //        return drawables;

        //    var obj = ((FScheme.Value.Container)container).Item;

        //    if (obj != null)
        //    {
        //        var t = obj.GetType();
        //        var visualizer = viz.Visualizers.FirstOrDefault(x => x.Key == t || x.Key.IsAssignableFrom(t));

        //        if (visualizer.Value != null)
        //        {
        //            drawables.Add(TagFromList(chain),obj);
        //        }
        //    }

        //    return drawables;
        //}

        /// <summary>
        /// Build a string tag from a list of ints. i.e "1,2,3,4"
        /// </summary>
        /// <param name="tags"></param>
        /// <returns></returns>
        private static string TagFromList(List<int> tags)
        {
            var sb = new StringBuilder();
            tags.ForEach(x => sb.Append(string.Format("{0},", x)));
            if(sb.Length > 1)
                sb.Remove(sb.Length - 1, 1);    //remove the last ,
            return sb.ToString();
        }

        #endregion
    }

    public class VisualizationEventArgs : EventArgs
    {
        /// <summary>
        /// A list of render packages corresponding to 
        /// a branch or a whole graph.
        /// </summary>
        public IEnumerable<RenderPackage> Packages { get; internal set; }

        /// <summary>
        /// The id of the view for which the description belongs.
        /// </summary>
        public string Id { get; internal set; }

        public VisualizationEventArgs(IEnumerable<RenderPackage> description, string viewId)
        {
            Packages = description;
            Id = viewId;
        }
    }
}
