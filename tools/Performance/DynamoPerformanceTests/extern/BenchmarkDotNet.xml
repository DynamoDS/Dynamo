<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BenchmarkDotNet</name>
    </assembly>
    <members>
        <member name="M:BenchmarkDotNet.Analysers.OutliersAnalyser.GetMessage(System.Double[],System.Double[],System.Double[],System.Double[],System.Globalization.CultureInfo)">
            <summary>
            Returns a nice message which can be displayed in the summary.
            </summary>
            <param name="actualOutliers">Actual outliers which were removed from the statistics</param>
            <param name="allOutliers">All outliers which present in the distribution (lower and upper)</param>
            <param name="lowerOutliers">All lower outliers</param>
            <param name="upperOutliers">All upper outliers</param>
            <param name="cultureInfo">CultureInfo</param>
            <returns>The message</returns>
        </member>
        <member name="M:BenchmarkDotNet.Analysers.ZeroMeasurementHelper.CheckZeroMeasurementOneSample(System.Double[],System.Double)">
            <summary>
            Checks distribution against Zero Measurement hypothesis in case of known threshold
            </summary>
            <returns>True if measurement is ZeroMeasurement</returns>
        </member>
        <member name="M:BenchmarkDotNet.Analysers.ZeroMeasurementHelper.CheckZeroMeasurementTwoSamples(System.Double[],System.Double[],Perfolizer.Mathematics.Thresholds.Threshold)">
            <summary>
            Checks distribution against Zero Measurement hypothesis in case of two samples
            </summary>
            <returns>True if measurement is ZeroMeasurement</returns>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MValueColumnAttribute">
            <summary>
            Prints mvalue.
            See http://www.brendangregg.com/FrequencyTrails/modes.html
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.NamespaceColumnAttribute">
            <summary>
            Add a column with the target method namespace.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute.#ctor(System.Int32,BenchmarkDotNet.Diagnosers.DisassemblySyntax,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[])">
            <param name="maxDepth">Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0.</param>
            <param name="syntax">The disassembly syntax. MASM is the default.</param>
            <param name="printSource">C#|F#|VB source code will be printed. False by default.</param>
            <param name="printInstructionAddresses">Print instruction addresses. False by default</param>
            <param name="exportGithubMarkdown">Exports to GitHub markdown. True by default.</param>
            <param name="exportHtml">Exports to HTML with clickable links. False by default.</param>
            <param name="exportCombinedDisassemblyReport">Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table).</param>
            <param name="exportDiff">Exports a diff of the assembly code to the Github markdown format. False by default.</param>
            <param name="filters">Glob patterns applied to full method signatures by the the disassembler.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute.#ctor(System.Boolean,System.Runtime.InteropServices.Architecture[])">
            <param name="allowed">if set to true, the architectures are enabled, if set to false, disabled</param>
            <param name="architectures">the architecture(s) for which the filter should be applied</param>
        </member>
        <member name="F:BenchmarkDotNet.Attributes.OS.Browser">
            <summary>
            WebAssembly
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute.#ctor(System.Boolean,BenchmarkDotNet.Attributes.OS[])">
            <param name="allowed">if set to true, the OSes belonging to platforms are enabled, if set to false, disabled</param>
            <param name="platforms">the platform(s) for which the filter should be applied</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.DryJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            defines a new Dry Job that targets specified Framework
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.DryJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker,BenchmarkDotNet.Environments.Jit,BenchmarkDotNet.Environments.Platform)">
            <summary>
            defines a new Dry Job that targets specified Framework, JIT and Platform
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
            <param name="jit">Jit to test.</param>
            <param name="platform">Platform to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.LongRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            defines a new LongRun Job that targets specified Framework
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.LongRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker,BenchmarkDotNet.Environments.Jit,BenchmarkDotNet.Environments.Platform)">
            <summary>
            defines a new LongRun Job that targets specified Framework, JIT and Platform
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
            <param name="jit">Jit to test.</param>
            <param name="platform">Platform to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.MediumRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            defines a new MediumRun Job that targets specified Framework
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.MediumRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker,BenchmarkDotNet.Environments.Jit,BenchmarkDotNet.Environments.Platform)">
            <summary>
            defines a new MediumRun Job that targets specified Framework, JIT and Platform
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
            <param name="jit">Jit to test.</param>
            <param name="platform">Platform to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.ShortRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            defines a new ShortRun Job that targets specified Framework
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.ShortRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker,BenchmarkDotNet.Environments.Jit,BenchmarkDotNet.Environments.Platform)">
            <summary>
            defines a new ShortRun Job that targets specified Framework, JIT and Platform
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
            <param name="jit">Jit to test.</param>
            <param name="platform">Platform to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            defines a new VeryLongRun Job that targets specified Framework
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.#ctor(BenchmarkDotNet.Jobs.RuntimeMoniker,BenchmarkDotNet.Environments.Jit,BenchmarkDotNet.Environments.Platform)">
            <summary>
            defines a new VeryLongRun Job that targets specified Framework, JIT and Platform
            </summary>
            <param name="runtimeMoniker">Target Framework to test.</param>
            <param name="jit">Jit to test.</param>
            <param name="platform">Platform to test.</param>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute">
            <summary>
            determines if all auto-generated files should be kept or removed after running the benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute.#ctor(System.Boolean)">
            <param name="displayGenColumns">Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default.</param>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.EvaluateOverheadAttribute">
            <summary>
            Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result.
            True by default, very important for nano-benchmarks.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.GcConcurrentAttribute">
            <summary>
            Specifies whether the common language runtime runs garbage collection on a separate thread.
            <value>false: Does not run garbage collection concurrently.</value>
            <value>true: Runs garbage collection concurrently. This is the default.</value>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.GcForceAttribute">
            <summary>
            Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation
            <value>false: Does not force garbage collection.</value>
            <value>true: Forces full garbage collection after each benchmark invocation. This is the default.</value>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.GcServerAttribute">
            <summary>
            Specifies whether the common language runtime runs server garbage collection.
            <value>false: Does not run server garbage collection. This is the default.</value>
            <value>true: Runs server garbage collection.</value>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.InnerIterationCountAttribute">
            <summary>
            Invocation count in a single iteration.
            Does exactly the same as InvocationCountAttribute, added to make porting from xunit-performance to BenchmarkDotNet easier
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.InvocationCountAttribute">
            <summary>
            Invocation count in a single iteration.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.IterationTime"/> will be ignored.
            If specified, it must be a multiple of <see cref="P:BenchmarkDotNet.Jobs.RunMode.UnrollFactor"/>.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.IterationCountAttribute">
            <summary>
            How many target iterations should be performed
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MinIterationCount"/> will be ignored.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MaxIterationCount"/> will be ignored.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.IterationTimeAttribute">
            <summary>
            Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            Doesn't have a default value.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxRelativeError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MaxIterationCountAttribute">
            <summary>
            Maximum count of target iterations that should be performed
            The default value is 100
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/>  is not going to work</remarks>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            The default value is 0.02.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxAbsoluteError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MaxWarmupCountAttribute">
            <summary>
            Maximum count of warmup iterations that should be performed
            The default value is 50
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.MaxWarmupCountAttribute.#ctor(System.Int32,System.Boolean)">
            <param name="maxWarmupCount">Maximum count of warmup iterations that should be performed. The default value is 50</param>
            <param name="forceAutoWarmup">if set to true, will overwrite WarmupCount of the global config</param>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MemoryRandomizationAttribute">
            <summary>
            specifies whether Engine should allocate some random-sized memory between iterations
            <remarks>it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration</remarks>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MinInvokeCountAttribute">
            <summary>
            Minimum count of benchmark invocations per iteration.
            The default value is 4.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MinIterationCountAttribute">
            <summary>
            Minimum count of target iterations that should be performed.
            The default value is 15.
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/> is not going to work.</remarks>
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MinIterationTimeAttribute">
            <summary>
            Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.MinWarmupCountAttribute">
            <summary>
            Minimum count of warmup iterations that should be performed
            The default value is 6
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.MinWarmupCountAttribute.#ctor(System.Int32,System.Boolean)">
            <param name="minWarmupCount">Minimum count of warmup iterations that should be performed. The default value is 6</param>
            <param name="forceAutoWarmup">if set to true, will overwrite WarmupCount in the global config</param>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.OutliersAttribute">
            <summary>
            Specifies which outliers should be removed from the distribution
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.ProcessCountAttribute">
            <summary>
            How many times we should launch process with target benchmark.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.RunOncePerIterationAttribute">
            <summary>
            Run the benchmark exactly once per iteration.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.WarmupCountAttribute">
            <summary>
            How many warmup iterations should be performed.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute.#ctor(System.Boolean,System.Int32)">
            <param name="performExtraBenchmarksRun">When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default.</param>
            <param name="timeoutInSeconds">How long should we wait for the perfcollect script to finish processing the trace. 300s by default.</param>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute">
            <summary>
            determines if running should be stop after first error
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute">
            <summary>
            Enable unicode support in console logger
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Characteristics.IResolver">
            <summary>
            An entity which can resolve default values of <see cref="T:BenchmarkDotNet.Characteristics.Characteristic`1"/>.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Code.ArrayParam`1.ForPrimitives(`0[])">
            <summary>
            for types where calling .ToString() will be enough to re-create them in auto-generated source code file (integers, strings and other primitives)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Code.ArrayParam`1.ForComplexTypes(`0[],System.Func{`0,System.String})">
            <summary>
            for types where calling .ToString() will be NOT enough to re-create them in auto-generated source code file
            </summary>
            <param name="array">the array</param>
            <param name="toSourceCode">method which transforms an item of type T to it's C# representation
            example: point => $"new Point2d({point.X}, {point.Y})"
            </param>
        </member>
        <member name="M:BenchmarkDotNet.Code.CodeGenerator.GetNativeAotSwitch(BenchmarkDotNet.Running.BuildPartition)">
            <summary>
            for NativeAOT we can't use reflection to load type and run a method, so we simply generate a switch for all types..
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Code.GenericTaskDeclarationsProvider">
            <summary>
            declarations provider for <see cref="T:System.Threading.Tasks.Task`1" /> and <see cref="T:System.Threading.Tasks.ValueTask`1" />
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Code.IParam.Value">
            <summary>
            value of the parameter object for benchmark
            used internally (e.g. by the InProcessToolchain)
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Code.IParam.DisplayText">
            <summary>
            used to display the value (e.g. in summary in Params column)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Code.IParam.ToSourceCode">
            <summary>
            this source code is used to create parameter for benchmark
            in C# source code file
            example: $"new Point2D({Value.X}, {Value.Y})"
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.Id">
            <summary>
            An unique identifier of the column.
            <remarks>If there are several columns with the same Id, only one of them will be shown in the summary.</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.ColumnName">
            <summary>
            Display column title in the summary.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Columns.IColumn.GetValue(BenchmarkDotNet.Reports.Summary,BenchmarkDotNet.Running.BenchmarkCase)">
            <summary>
            Value in this column formatted using the default style.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Columns.IColumn.GetValue(BenchmarkDotNet.Reports.Summary,BenchmarkDotNet.Running.BenchmarkCase,BenchmarkDotNet.Reports.SummaryStyle)">
            <summary>
            Value in this column formatted using the specified style.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.PriorityInCategory">
            <summary>
            Defines order of column in the same category.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.IsNumeric">
            <summary>
            Defines if the column's value represents a number
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.UnitType">
            <summary>
            Defines how to format column's value
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Columns.IColumn.Legend">
            <summary>
            Column description.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Columns.StatisticColumn.MValue">
            <summary>
            See http://www.brendangregg.com/FrequencyTrails/modes.html
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.KeepBenchmarkFiles(BenchmarkDotNet.Configs.IConfig,System.Boolean)">
            <summary>
            determines if all auto-generated files should be kept or removed after running the benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.DontOverwriteResults(BenchmarkDotNet.Configs.IConfig,System.Boolean)">
            <summary>
            determines if the exported result files should not be overwritten (be default they are overwritten)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.StopOnFirstError(BenchmarkDotNet.Configs.IConfig,System.Boolean)">
            <summary>
            determines if benchmarking should be stopped after the first error (by default it's not)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.With(BenchmarkDotNet.Configs.IConfig,BenchmarkDotNet.Configs.ConfigOptions)">
            <summary>
            sets given options for the config
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.WithOption(BenchmarkDotNet.Configs.IConfig,BenchmarkDotNet.Configs.ConfigOptions,System.Boolean)">
            <summary>
            sets given option to provided value
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ConfigExtensions.WithOptions(BenchmarkDotNet.Configs.IConfig,BenchmarkDotNet.Configs.ConfigOptions)">
            <summary>
            sets given options for the config
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.Default">
            <summary>
            no custom settings
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.KeepBenchmarkFiles">
            <summary>
            determines if all auto-generated files should be kept after running the benchmarks (be default they are removed)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.JoinSummary">
            <summary>
            determines if all benchmarks results should be joined into a single summary (by default we have a summary per type)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.StopOnFirstError">
            <summary>
            determines if benchmarking should be stopped after the first error (by default it's not)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.DisableOptimizationsValidator">
            <summary>
            determines if "mandatory" optimizations validator should be entirely turned off
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.DontOverwriteResults">
            <summary>
            determines if the exported result files should not be overwritten (be default they are overwritten)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.DisableLogFile">
            <summary>
            Determines if the log file should be disabled.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.LogBuildOutput">
            <summary>
            Determines whether build output should be logged.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.GenerateMSBuildBinLog">
            <summary>
            Determines whether to generate msbuild binlogs
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.ApplesToApples">
            <summary>
            Performs apples-to-apples comparison for provided benchmarks and jobs. Experimental, will change in the near future!
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Configs.ConfigOptions.Resume">
            <summary>
            Continue the execution if the last run was stopped.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Configs.DebugInProcessConfig">
            <summary>
            config which allows to debug benchmarks running it in the same process
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Configs.DebugBuildConfig">
            <summary>
            config which allows to build benchmarks in Debug
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Configs.IConfig.ArtifactsPath">
            <summary>
            the default value is "./BenchmarkDotNet.Artifacts"
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Configs.IConfig.Options">
            <summary>
            a set of custom flags that can enable/disable various settings
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Configs.IConfig.BuildTimeout">
            <summary>
            the auto-generated project build timeout
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Configs.IConfig.ConfigAnalysisConclusion">
            <summary>
            Collect any errors or warnings when composing the configuration
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Configs.ImmutableConfigBuilder">
            <summary>
            this class is responsible for config that has no duplicates, does all of the internal hacks and is ready to run
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ImmutableConfigBuilder.Create(BenchmarkDotNet.Configs.IConfig)">
            <summary>
            removes duplicates and applies all extra logic required to make the config a final one
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ImmutableConfigBuilder.GetRunnableJobs(System.Collections.Generic.IEnumerable{BenchmarkDotNet.Jobs.Job})">
            <summary>
            returns a set of unique jobs that are ready to run
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ManualConfig.CreateEmpty">
            <summary>
            Creates a completely EMPTY config with no predefined settings.
            </summary>
            <remarks>You should most probably use the <see cref="M:BenchmarkDotNet.Configs.ManualConfig.CreateMinimumViable"></see> method instead.</remarks>
        </member>
        <member name="M:BenchmarkDotNet.Configs.ManualConfig.CreateMinimumViable">
            <summary>
            Creates a minimum viable config with predefined columns provider and console logger.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.ConsoleArguments.ConfigParser.GetCoreRunToolchainDisplayName(System.Collections.Generic.IReadOnlyList{System.IO.FileInfo},System.IO.FileInfo)">
             <summary>
             we have a limited amount of space when printing the output to the console, so we try to keep things small and simple
            
             for following paths:
              C:\Projects\coreclr_upstream\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\CoreRun.exe
              C:\Projects\coreclr_upstream\bin\tests\Windows_NT.x64.Release\Tests\Core_Root_beforeMyChanges\CoreRun.exe
            
             we get:
            
             \Core_Root\CoreRun.exe
             \Core_Root_beforeMyChanges\CoreRun.exe
             </summary>
        </member>
        <member name="F:BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.Disabled">
            <summary>
            Do not print any of the available full benchmark names.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.Flat">
            <summary>
            Prints flat list of the available benchmark names.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.Tree">
            <summary>
            Prints tree of the available full benchmark names.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.EventPipeProfile.CpuSampling">
            <summary>
            Useful for tracking CPU usage and general .NET runtime information.
            This is the default option if no profile or providers are specified.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.EventPipeProfile.GcVerbose">
            <summary>
            Tracks GC collections and samples object allocations.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.EventPipeProfile.GcCollect">
            <summary>
            Tracks GC collections only at very low overhead.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.EventPipeProfile.Jit">
            <summary>
            Logging when Just in time (JIT) compilation occurs.
            Logging of the internal workings of the Just In Time compiler. This is fairly verbose.
            It details decisions about interesting optimization (like inlining and tail call)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Diagnosers.EventPipeProfiler.#ctor(BenchmarkDotNet.Diagnosers.EventPipeProfile,System.Collections.Generic.IReadOnlyCollection{Microsoft.Diagnostics.NETCore.Client.EventPipeProvider},System.Boolean)">
            <summary>
            Creates a new instance of EventPipeProfiler
            </summary>
            <param name="profile">A named pre-defined set of provider configurations that allows common tracing scenarios to be specified succinctly.</param>
            <param name="providers">A list of EventPipe providers to be enabled.</param>
            <param name="performExtraBenchmarksRun">if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default.</param>
        </member>
        <member name="M:BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig.#ctor(System.Boolean)">
            <param name="displayGenColumns">Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default.</param>
        </member>
        <member name="M:BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig.#ctor(System.Boolean,System.Int32)">
            <param name="performExtraBenchmarksRun">When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default.</param>
            <param name="timeoutInSeconds">How long should we wait for the perfcollect script to finish processing the trace. 300s by default.</param>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.RunMode.None">
            <summary>
            given diagnoser should not be executed for given benchmark
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.RunMode.ExtraRun">
            <summary>
            needs extra run of the benchmark
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.RunMode.NoOverhead">
            <summary>
            no overhead, can be executed without extra run
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.RunMode.SeparateLogic">
            <summary>
            implements some separate logic, that can be executed at any time
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig.#ctor(System.Int32,BenchmarkDotNet.Diagnosers.DisassemblySyntax,System.String[],Iced.Intel.FormatterOptions,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <param name="maxDepth">Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0.</param>
            <param name="filters">Glob patterns applied to full method signatures by the the disassembler.</param>
            <param name="syntax">The disassembly syntax. MASM is the default.</param>
            <param name="formatterOptions">Code formatter options. If not provided, the recommended settings will be used.</param>
            <param name="printSource">C#|F#|VB source code will be printed. False by default.</param>
            <param name="printInstructionAddresses">Print instruction addresses. False by default</param>
            <param name="exportGithubMarkdown">Exports to GitHub markdown. True by default.</param>
            <param name="exportHtml">Exports to HTML with clickable links. False by default.</param>
            <param name="exportCombinedDisassemblyReport">Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table).</param>
            <param name="exportDiff">Exports a diff of the assembly code to the Github markdown format. False by default.</param>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.DisassemblySyntax.Masm">
            <summary>
            Indicates a disassembler should use MASM syntax for generated assembly code
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.DisassemblySyntax.Intel">
            <summary>
            Indicates a disassembler should use Intel syntax for generated assembly code.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Diagnosers.DisassemblySyntax.Att">
            <summary>
            Indicates a disassembler should use AT&amp;T syntax for generated assembly code.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.ConsumerExtensions.Consume(System.Collections.IEnumerable,BenchmarkDotNet.Engines.Consumer)">
            <summary>
            executes and consumes given <see cref="T:System.Collections.IEnumerable"/>
            <remarks>By using non-generic <see cref="T:System.Collections.IEnumerable"/> you pay for boxing. Use generic <see cref="T:System.Collections.Generic.IEnumerable`1"/> if you can.</remarks>
            </summary>
            <param name="enumerable">non-generic <see cref="T:System.Collections.IEnumerable"/></param>
            <param name="consumer">instance of <see cref="T:BenchmarkDotNet.Engines.Consumer"/>. Create it on your own once, store it in the field and just pass here</param>
        </member>
        <member name="M:BenchmarkDotNet.Engines.ConsumerExtensions.Consume(System.Linq.IQueryable,BenchmarkDotNet.Engines.Consumer)">
            <summary>
            executes and consumes given <see cref="T:System.Linq.IQueryable"/>
            <remarks>By using non-generic <see cref="T:System.Linq.IQueryable"/> you pay for boxing. Use generic <see cref="T:System.Linq.IQueryable`1"/> if you can.</remarks>
            </summary>
            <param name="queryable">non-generic <see cref="T:System.Linq.IQueryable"/></param>
            <param name="consumer">instance of <see cref="T:BenchmarkDotNet.Engines.Consumer"/>. Create it on your own once, store it in the field and just pass here</param>
        </member>
        <member name="M:BenchmarkDotNet.Engines.ConsumerExtensions.Consume``1(System.Collections.Generic.IEnumerable{``0},BenchmarkDotNet.Engines.Consumer)">
            <summary>
            executes and consumes given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="enumerable">generic <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="consumer">instance of <see cref="T:BenchmarkDotNet.Engines.Consumer"/>. Create it on your own once, store it in the field and just pass here</param>
        </member>
        <member name="M:BenchmarkDotNet.Engines.ConsumerExtensions.Consume``1(System.Linq.IQueryable{``0},BenchmarkDotNet.Engines.Consumer)">
            <summary>
            executes and consumes given <see cref="T:System.Linq.IQueryable`1"/>
            </summary>
            <param name="queryable">generic <see cref="T:System.Linq.IQueryable`1"/></param>
            <param name="consumer">instance of <see cref="T:BenchmarkDotNet.Engines.Consumer"/>. Create it on your own once, store it in the field and just pass here</param>
        </member>
        <member name="M:BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing``1(``0)">
            <summary>
            This method can't get inlined, so any value send to it
            will not get eliminated by the dead code elimination
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing``1(``0@)">
            <summary>
            This method can't get inlined, so any value send to it
            will not get eliminated by the dead code elimination
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly``1(``0@)">
            <summary>
            This method can't get inlined, so any value send to it
            will not get eliminated by the dead code elimination
            it's not called KeepAliveWithoutBoxing because compiler would not be able to diff `ref` and `in`
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.EngineFactory.Jit(BenchmarkDotNet.Engines.Engine,System.Int32,System.Int32,System.Int32)">
            <returns>the time it took to run the benchmark</returns>
        </member>
        <member name="M:BenchmarkDotNet.Engines.EnginePilotStage.Run">
            <returns>Perfect invocation count</returns>
        </member>
        <member name="M:BenchmarkDotNet.Engines.EnginePilotStage.RunAuto">
            <summary>
            A case where we don't have specific iteration time.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.EnginePilotStage.RunSpecific">
            <summary>
            A case where we have specific iteration time.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Engines.GcStats.AllocatedBytes">
            <summary>
            Total per all runs
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.GcStats.GetTotalAllocatedBytes(System.Boolean)">
            <summary>
            returns total allocated bytes (not per operation)
            </summary>
            <param name="excludeAllocationQuantumSideEffects">Allocation quantum can affecting some of our nano-benchmarks in non-deterministic way.
            when this parameter is set to true and the number of all allocated bytes is less or equal AQ, we ignore AQ and put 0 to the results</param>
            <returns></returns>
        </member>
        <member name="M:BenchmarkDotNet.Engines.GcStats.CalculateAllocationQuantumSize">
            <summary>
            code copied from https://github.com/rsdn/CodeJam/blob/71a6542b6e5c52ea8dd92c601adad11e62796a98/PerfTests/src/%5BL4_Configuration%5D/Metrics/%5BMetricValuesProvider%5D/GcMetricValuesProvider.cs#L63-L89
            </summary>
            <returns></returns>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.BeforeProcessStart">
            <summary>
            before we start the benchmarking process
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.BeforeAnythingElse">
            <summary>
            before jitting, warmup
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.BeforeActualRun">
            <summary>
            after globalSetup, warmup and pilot but before the main run
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.AfterActualRun">
            <summary>
            after main run, but before global Cleanup
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.AfterAll">
            <summary>
            after all (the last thing the benchmarking engine does is to fire this signal)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.SeparateLogic">
            <summary>
            used to run some code independent to the benchmarked process
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.HostSignal.AfterProcessExit">
            <summary>
            after the benchmarking process exits
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.IterationStage.Pilot">
            <summary>
            <seealso href="https://en.wikipedia.org/wiki/Pilot_experiment"/>
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.RunStrategy.Throughput">
            <summary>
            Throughput mode.
            Perfect for microbenchmarking.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.RunStrategy.ColdStart">
            <summary>
            A mode without overhead evaluating and warmup, with single invocation.
            Perfect for startup time evaluation.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Engines.RunStrategy.Monitoring">
            <summary>
            A mode without overhead evaluating, with several target iterations.
            Perfect for macrobenchmarks without a steady state with high variance.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Engines.AutoWarmupStoppingCriteria">
            <summary>
            Automatically choose the best number of iterations during the warmup stage.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.AutoWarmupStoppingCriteria.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            The idea of the implementation is simple: if measurements monotonously decrease or increase, the steady state is not achieved;
            we should continue the warmup stage. The evaluation method counts "fluctuations"
            (3 consecutive measurements A,B,C where (A&gt;B AND B&lt;C) OR (A&lt;B AND B&gt;C)) until the required amount of flotations is observed.
            </summary>
            <param name="minIterationCount">
            The minimum number of iterations.
            We are always going to do at least <paramref name="minIterationCount"/> iterations regardless of fluctuations.
            </param>
            <param name="maxIterationCount">
            The maximum number of iterations.
            We are always going to do at most <paramref name="maxIterationCount"/> iterations regardless of fluctuations.
            </param>
            <param name="minFluctuationCount">
            The required number of fluctuations.
            If the required number of fluctuations is achieved but the number of iterations less than <paramref name="minIterationCount"/>,
            we need more iterations.
            If the required number of fluctuations is not achieved but the number of iterations equal to <paramref name="maxIterationCount"/>,
            we should stop the iterations.
            </param>
        </member>
        <member name="T:BenchmarkDotNet.Engines.FixedStoppingCriteria">
            <summary>
            Stopping criteria which require a specific amount of iterations.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Engines.IStoppingCriteria">
            <summary>
            A stopping criteria checks when it's time to terminate iteration in the current stage.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Engines.IStoppingCriteria.Evaluate(System.Collections.Generic.IReadOnlyList{BenchmarkDotNet.Reports.Measurement})">
            <summary>
            Checks do we have enough iterations
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Engines.IStoppingCriteria.Title">
            <summary>
            Title which can be used in logs and diagnostics methods
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Engines.IStoppingCriteria.MaxIterationCount">
            <summary>
            The maximum possible count of iterations.
            Engine needs this value for setting the maximum capacity of the returned list of measurements.
            The correct capacity helps to avoid infrastructure allocations during benchmarking.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Engines.IStoppingCriteria.Warnings">
            <summary>
            An array of user-friendly warnings which notify about incorrect parameters.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.FallbackLogger">
            <summary>
            Logger to use when there's no config available.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.OsVersion">
            <summary>
            Could be expensive
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.CpuInfo">
            <summary>
            is expensive to call (1s)
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.DotNetSdkVersion">
            <summary>
            .NET Core SDK version
            <remarks>It's expensive to call (creates new process by calling `dotnet --version`)</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.IsMonoInstalled">
            <summary>
            checks if Mono is installed
            <remarks>It's expensive to call (creates new process by calling `mono --version`)</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.HostEnvironmentInfo.ChronometerFrequency">
            <summary>
            The frequency of the timer as the number of ticks per second.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Environments.HostEnvironmentInfo.GetInformation">
            <summary>
            Return string representation of CPU and environment configuration including BenchmarkDotNet, OS and .NET version
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Jit.Default">
            <summary>
            Default
            <remarks>By default</remarks>
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Jit.LegacyJit">
            <summary>
            LegacyJIT
            <remarks>Supported only for Full Framework</remarks>
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Jit.RyuJit">
            <summary>
            RyuJIT
            <remarks>Full Framework or CoreCLR</remarks>
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Jit.Llvm">
            <summary>
            LLVM
            <remarks>Supported only for Mono</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Environments.OsBrandStringHelper.Prettify(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Transform an operation system name and version to a nice form for summary.
            </summary>
            <param name="osName">Original operation system name</param>
            <param name="osVersion">Original operation system version</param>
            <param name="windowsUbr">UBR (Update Build Revision), the revision number of Windows version (if available)</param>
            <returns>Prettified operation system title</returns>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.AnyCpu">
            <summary>
            AnyCPU
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.X86">
            <summary>
            x86
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.X64">
            <summary>
            x64
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.Arm">
            <summary>
            ARM
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.Arm64">
            <summary>
            ARM64
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.Wasm">
            <summary>
            Wasm
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.S390x">
            <summary>
            S390x
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.LoongArch64">
            <summary>
            LOONGARCH64
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.Armv6">
            <summary>
            A 32-bit ARMv6 processor architecture.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.Platform.Ppc64le">
            <summary>
            A PowerPC 64-bit (little-endian) processor architecture.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Environments.ProcessorBrandStringHelper.Prettify(BenchmarkDotNet.Portability.Cpu.CpuInfo,System.Boolean)">
            <summary>
            Transform a processor brand string to a nice form for summary.
            </summary>
            <param name="cpuInfo">The CPU information</param>
            <param name="includeMaxFrequency">Whether to include determined max frequency information</param>
            <returns>Prettified version</returns>
        </member>
        <member name="M:BenchmarkDotNet.Environments.ProcessorBrandStringHelper.GetBrandStyledActualFrequency(System.Nullable{Perfolizer.Horology.Frequency})">
            <summary>
            Presents actual processor's frequency into brand string format
            </summary>
            <param name="frequency"></param>
        </member>
        <member name="M:BenchmarkDotNet.Environments.ProcessorBrandStringHelper.ParseMicroarchitecture(System.String)">
            <summary>
            Parse a processor name and tries to return a microarchitecture name.
            Works only for well-known microarchitectures.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Environments.ClrRuntime.CreateForLocalFullNetFrameworkBuild(System.String)">
            <param name="version">YOU PROBABLY DON'T NEED IT, but if you are a .NET Runtime developer..
            please set it to particular .NET Runtime version if you want to benchmark it.
            BenchmarkDotNet in going to pass `COMPLUS_Version` env var to the process for you.
            </param>
        </member>
        <member name="M:BenchmarkDotNet.Environments.CoreRuntime.CreateForNewVersion(System.String,System.String)">
            <summary>
            use this method if you want to target .NET version not supported by current version of BenchmarkDotNet. Example: .NET 10
            </summary>
            <param name="msBuildMoniker">msbuild moniker, example: net10.0</param>
            <param name="displayName">display name used by BDN to print the results</param>
            <returns>new runtime information</returns>
        </member>
        <member name="M:BenchmarkDotNet.Environments.MonoAotLLVMRuntime.#ctor(System.IO.FileInfo,BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode,System.String,System.String)">
            <summary>
            creates new instance of MonoAotLLVMRuntime
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.NativeAotRuntime.Net60">
            <summary>
            NativeAOT compiled as net6.0
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.NativeAotRuntime.Net70">
            <summary>
            NativeAOT compiled as net7.0
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.NativeAotRuntime.Net80">
            <summary>
            NativeAOT compiled as net8.0
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Environments.NativeAotRuntime.Net90">
            <summary>
            NativeAOT compiled as net9.0
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.Runtime.Name">
            <summary>
            Display name
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.Runtime.RuntimeMoniker">
            <summary>
            Target Framework Moniker
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Environments.Runtime.MsBuildMoniker">
            <summary>
            MsBuild Target Framework Moniker, example: net462, netcoreapp2.1
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Environments.WasmRuntime.#ctor(System.String,System.String,System.String,System.String,System.Boolean,System.String,BenchmarkDotNet.Jobs.RuntimeMoniker)">
            <summary>
            creates new instance of WasmRuntime
            </summary>
            <param name="javaScriptEngine">Full path to a java script engine used to run the benchmarks. "v8" by default</param>
            <param name="javaScriptEngineArguments">Arguments for the javascript engine. "--expose_wasm" by default</param>
            <param name="msBuildMoniker">moniker, default: "net5.0"</param>
            <param name="displayName">default: "Wasm"</param>
            <param name="aot">Specifies whether AOT or Interpreter (default) project should be generated.</param>
            <param name="wasmDataDir">Specifies a wasm data directory surfaced as $(WasmDataDir) for the project</param>
            <param name="moniker">Runtime moniker</param>
        </member>
        <member name="F:BenchmarkDotNet.Exporters.Csv.CsvSeparator.Comma">
            <summary>
            ',' will be used as the CSV separator.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Exporters.Csv.CsvSeparator.Semicolon">
            <summary>
            ';' will be used as the CSV separator.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Exporters.Csv.CsvSeparator.CurrentCulture">
             <summary>
            
             </summary>
        </member>
        <member name="M:BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions.ToRealSeparator(BenchmarkDotNet.Exporters.Csv.CsvSeparator)">
            <summary>
            Return a string which represent real CSV separator which can be used as plain text.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Exporters.IExporterDependencies">
            <summary>
            This is an internal interface, it allows Exporters to specify that
            they depends on another Exporter (see RPlotExporter for example)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Exporters.InstructionPointerExporter.SumHardwareCountersStatsOfBenchmarkedCode(BenchmarkDotNet.Disassemblers.DisassemblyResult,BenchmarkDotNet.Diagnosers.PmcStats)">
            <summary>
            there might be some hardware counter events not belonging to the benchmarked code (for example CLR or BenchmarkDotNet's Engine)
            to calculate the % per IP we need to know the total per benchmark, not per process
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Exporters.Xml.GcStats">
            <summary>
            This type is used to ensure that the allocated bytes are persisted in the XML
            report when serialized, as the original <see cref="T:BenchmarkDotNet.Engines.GcStats"/> type does
            not contain a property for the value so the report would otherwise lack it.
            See https://github.com/dotnet/BenchmarkDotNet/pull/1919 for more details.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.CommonExtensions.GetColumnTitle(BenchmarkDotNet.Columns.IColumn,BenchmarkDotNet.Reports.SummaryStyle)">
            <summary>
            Gets column title formatted using the specified style
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.Hashing.MurmurHash(System.UInt32,System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Implements the murmur hash 3 algorithm, using a mock UTF-8 encoding.
            The UTF-8 conversion ignores the possibilities of unicode planes other than the 0th.
            That is, it simply converts char values to one, two, or three bytes according to
            the following rules:
            * 0x0000 to 0x007F : 0xxxxxxx
            * 0x0080 to 0x07FF : 110xxxxx 10xxxxxx
            * 0x0800 to 0xFFFF : 1110xxxx 10xxxxxx 10xxxxxx
            NOTE: This MUST match the StringBuilder version below.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.Hashing.MurmurRound(System.UInt32,System.UInt32)">
            <summary>
            Combines the given hash value with a uint value, using the murmur hash 3 algorithm.
            Make certain to also use <see cref="M:BenchmarkDotNet.Extensions.Hashing.MixHash(System.UInt32)"/> on the final hashed value, if you
            depend upon having distinct bits.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.Hashing.MixHash(System.UInt32)">
            <summary>
            The final mixing ritual for the Murmur3 hashing algorithm. Most users of
            <see cref="M:BenchmarkDotNet.Extensions.Hashing.MurmurRound(System.UInt32,System.UInt32)"/> will want to close their progressive building of
            a hash with a call to this method.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.PathFeatures.AreAllLongPathsAvailable">
            <summary>
            Returns true if you can use long paths, including long DOS style paths (e.g. over 260 without \\?\).
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.PathFeatures.AreLongPathsBlocked">
            <summary>
            Returns true if > MAX_PATH (260) character paths are blocked.
            Note that this doesn't reflect that you can actually use long paths without device syntax when on Windows.
            Use AreAllLongPathsAvailable() to see that you can use long DOS style paths if on Windows.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.ReflectionExtensions.GetCorrectCSharpTypeName(System.Type,System.Boolean,System.Boolean)">
            <summary>
            returns type name which can be used in generated C# code
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.ReflectionExtensions.GetDisplayName(System.Type)">
            <summary>
            returns simple, human friendly display name
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.ReflectionExtensions.GetDisplayName(System.Reflection.TypeInfo)">
            <summary>
            returns simple, human friendly display name
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.EscapeSpecialCharacters(System.String,System.Boolean)">
            <summary>
            Escapes UNICODE control characters
            </summary>
            <param name="str">string to escape</param>
            <param name="quote">True to put (double) quotes around the string literal</param>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.EscapeSpecialCharacter(System.Char,System.Boolean)">
            <summary>
            Escapes UNICODE control character
            </summary>
            <param name="c">char to escape</param>
            <param name="quote">True to put (single) quotes around the character literal.</param>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.AsValidFileName(System.String)">
            <summary>
            replaces all invalid file name chars with their number representation
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.HtmlEncode(System.String)">
            <summary>
            Returns an HTML encoded string
            </summary>
            <param name="s">string to encode</param>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.GetBaseName(System.String,System.String)">
            <summary>
            Returns file base name
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.AppendArgument(System.Text.StringBuilder,System.String)">
            <summary>
            Standardizes the whitespace before/after arguments so that all arguments are separated by a single space
            </summary>
            <param name="stringBuilder">The string builder that will hold the arguments</param>
            <param name="argument">The argument to append to this string builder</param>
            <returns>The string builder with the arguments added</returns>
        </member>
        <member name="M:BenchmarkDotNet.Extensions.StringAndTextExtensions.AppendArgument(System.Text.StringBuilder,System.Object)">
            <summary>
            Standardizes the whitespace before/after arguments so that all arguments are separated by a single space
            </summary>
            <param name="stringBuilder">The string builder that will hold the arguments</param>
            <param name="argument">The argument to append to this string builder</param>
            <returns>The string builder with the arguments added</returns>
        </member>
        <member name="T:BenchmarkDotNet.Filters.AllCategoriesFilter">
            <summary>
            Filter benchmarks which have all the target categories
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Filters.AnyCategoriesFilter">
            <summary>
            Filter benchmarks which have any of the target categories
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Filters.AttributesFilter">
            <summary>
            filters benchmarks by provided attribute names
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Filters.GlobFilter">
            <summary>
            filters benchmarks by provided glob patterns
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Helpers.AsciiHelper.Mu">
            <summary>
            The 'μ' symbol
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Helpers.ExternalToolsHelper.MacSystemProfilerData">
            <summary>
            Output of the `system_profiler SPSoftwareDataType` command.
            MacOSX only.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Helpers.ProcessHelper.RunAndReadOutput(System.String,System.String,BenchmarkDotNet.Loggers.ILogger)">
            <summary>
            Run external process and return the console output.
            In the case of any exception, null will be returned.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Helpers.UserInteractionHelper.EscapeCommandExample(System.String)">
             <summary>
             If you are going to show a command example which should be typed by user in a terminal,
             all asterisk symbols ('*') should be escaped with the help of quotes
             (read more here: <a href="https://www.shellscript.sh/escape.html">https://www.shellscript.sh/escape.html</a>).
            
             This method escapes such characters on non-Windows platforms.
            
             </summary>
             <remarks>
             See also:
               <a href="https://github.com/dotnet/BenchmarkDotNet/issues/842">#842</a>,
               <a href="https://github.com/dotnet/BenchmarkDotNet/issues/1147">#1147</a>
             </remarks>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxRelativeError">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            The default value is 0.02.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxAbsoluteError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxAbsoluteError">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            Doesn't have a default value.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxRelativeError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.MinIterationTime">
            <summary>
            Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.MinInvokeCount">
            <summary>
            Minimum count of benchmark invocations per iteration.
            The default value is 4.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.EvaluateOverhead">
            <summary>
            Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result.
            True by default, very important for nano-benchmarks.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.AccuracyMode.OutlierMode">
            <summary>
            Specifies which outliers should be removed from the distribution.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Jobs.MonoArgument">
            <summary>
            Argument passed directly to mono when executing benchmarks (mono [options])
            example: new MonoArgument("--gc=sgen")
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Jobs.MsBuildArgument">
            <summary>
            Argument passed to dotnet cli when restoring and building the project
            example: new MsBuildArgument("/p:MyCustomSetting=123")
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.Platform">
            <summary>
            Platform (x86 or x64)
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.Jit">
            <summary>
            JIT (Just-In-Time compiler)
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.Runtime">
            <summary>
            Runtime
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.Affinity">
            <summary>
            ProcessorAffinity for the benchmark process.
            See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.Gc">
            <summary>
            GcMode
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.PowerPlanMode">
            <summary>
            Power Plan Mode
            </summary>
            <remarks>Supported only on Windows.</remarks>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.EnvironmentMode.LargeAddressAware">
            <summary>
            Specifies that benchmark can handle addresses larger than 2 gigabytes.
            <value>false: Benchmark uses the default (64-bit: enabled; 32-bit:disabled). This is the default.</value>
            <value>true: Explicitly specify that benchmark can handle addresses larger than 2 gigabytes.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.EnvironmentMode.SetEnvironmentVariable(BenchmarkDotNet.Jobs.EnvironmentVariable)">
            <summary>
            Adds the specified <paramref name="variable"/> to <see cref="P:BenchmarkDotNet.Jobs.EnvironmentMode.EnvironmentVariables"/>.
            If <see cref="P:BenchmarkDotNet.Jobs.EnvironmentMode.EnvironmentVariables"/> already contains a variable with the same key,
            it will be overriden.
            </summary>
            <param name="variable">The new environment variable which should be added to <see cref="P:BenchmarkDotNet.Jobs.EnvironmentMode.EnvironmentVariables"/></param>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.Server">
            <summary>
            Specifies whether the common language runtime runs server garbage collection.
            <value>false: Does not run server garbage collection. This is the default.</value>
            <value>true: Runs server garbage collection.</value>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.Concurrent">
            <summary>
            Specifies whether the common language runtime runs garbage collection on a separate thread.
            <value>false: Does not run garbage collection concurrently.</value>
            <value>true: Runs garbage collection concurrently. This is the default.</value>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.CpuGroups">
            <summary>
            Specifies whether garbage collection supports multiple CPU groups.
            <value>false: Garbage collection does not support multiple CPU groups. This is the default.</value>
            <value>true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled.</value>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.Force">
            <summary>
            Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation
            <value>false: Does not force garbage collection.</value>
            <value>true: Forces full garbage collection after each benchmark invocation. This is the default.</value>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.AllowVeryLargeObjects">
            <summary>
            On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size.
            <value>false: Arrays greater than 2 GB in total size are not enabled. This is the default.</value>
            <value>true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms.</value>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.RetainVm">
            <summary>
            Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS
            <remarks>The default is false</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.NoAffinitize">
            <summary>
            specify true to disable hard affinity of Server GC threads to CPUs
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.HeapAffinitizeMask">
            <summary>
            process mask, see <see href="https://support.microsoft.com/en-us/help/4014604/may-2017-description-of-the-quality-rollup-for-the-net-framework-4-6-4">MSDN</see> for more.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.GcMode.HeapCount">
            <summary>
             specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on,
             ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine;
             otherwise this is the # of logical CPUs you affinitized your process to.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithServer(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            Specifies whether the common language runtime runs server garbage collection.
            <value>false: Does not run server garbage collection. This is the default.</value>
            <value>true: Runs server garbage collection.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithConcurrent(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            Specifies whether the common language runtime runs garbage collection on a separate thread.
            <value>false: Does not run garbage collection concurrently.</value>
            <value>true: Runs garbage collection concurrently. This is the default.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithCpuGroups(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            Specifies whether garbage collection supports multiple CPU groups.
            <value>false: Garbage collection does not support multiple CPU groups. This is the default.</value>
            <value>true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithForce(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation
            <value>false: Does not force garbage collection.</value>
            <value>true: Forces full garbage collection after each benchmark invocation. This is the default.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithAllowVeryLargeObjects(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size.
            <value>false: Arrays greater than 2 GB in total size are not enabled. This is the default.</value>
            <value>true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithRetainVm(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS
            <remarks>The default is false</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithHeapCount(BenchmarkDotNet.Jobs.GcMode,System.Int32)">
            <summary>
             specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on,
             ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine;
             otherwise this is the # of logical CPUs you affinitized your process to.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithNoAffinitize(BenchmarkDotNet.Jobs.GcMode,System.Boolean)">
            <summary>
            specify true to disable hard affinity of Server GC threads to CPUs
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.GcModeExtensions.WithHeapAffinitizeMask(BenchmarkDotNet.Jobs.GcMode,System.Int32)">
            <summary>
            process mask, see <see href="https://support.microsoft.com/en-us/help/4014604/may-2017-description-of-the-quality-rollup-for-the-net-framework-4-6-4">MSDN</see> for more.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.InfrastructureMode.EngineFactory">
            <summary>
            this type will be used in the auto-generated program to create engine in separate process
            <remarks>it must have parameterless constructor</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithAffinity(BenchmarkDotNet.Jobs.Job,System.IntPtr)">
            <summary>
            ProcessorAffinity for the benchmark process.
            See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcServer(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies whether the common language runtime runs server garbage collection.
            <value>false: Does not run server garbage collection. This is the default.</value>
            <value>true: Runs server garbage collection.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcConcurrent(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies whether the common language runtime runs garbage collection on a separate thread.
            <value>false: Does not run garbage collection concurrently.</value>
            <value>true: Runs garbage collection concurrently. This is the default.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcCpuGroups(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies whether garbage collection supports multiple CPU groups.
            <value>false: Garbage collection does not support multiple CPU groups. This is the default.</value>
            <value>true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcForce(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation
            <value>false: Does not force garbage collection.</value>
            <value>true: Forces full garbage collection after each benchmark invocation. This is the default.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcAllowVeryLargeObjects(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size.
            <value>false: Arrays greater than 2 GB in total size are not enabled. This is the default.</value>
            <value>true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms.</value>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithLargeAddressAware(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies that benchmark can handle addresses larger than 2 gigabytes.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithGcRetainVm(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS
            <remarks>The default is false</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithHeapCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
             specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on,
             ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine;
             otherwise this is the # of logical CPUs you affinitized your process to.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithNoAffinitize(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            specify true to disable hard affinity of Server GC threads to CPUs
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithHeapAffinitizeMask(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            process mask, see <see href="https://support.microsoft.com/en-us/help/4014604/may-2017-description-of-the-quality-rollup-for-the-net-framework-4-6-4">MSDN</see> for more.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.With(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Engines.RunStrategy)">
            <summary>
            Available values: Throughput, ColdStart and Monitoring.
                Throughput: default strategy which allows to get good precision level.
                ColdStart: should be used only for measuring cold start of the application or testing purpose.
                Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithStrategy(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Engines.RunStrategy)">
            <summary>
            Available values: Throughput, ColdStart and Monitoring.
                Throughput: default strategy which allows to get good precision level.
                ColdStart: should be used only for measuring cold start of the application or testing purpose.
                Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithLaunchCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            How many times we should launch process with target benchmark.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithWarmupCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            How many warmup iterations should be performed.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMinWarmupCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            Minimum count of warmup iterations that should be performed
            The default value is 6
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMaxWarmupCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            Maximum count of warmup iterations that should be performed
            The default value is 50
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithIterationCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            How many target iterations should be performed.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MinIterationCount"/> will be ignored.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MaxIterationCount"/> will be ignored.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithIterationTime(BenchmarkDotNet.Jobs.Job,Perfolizer.Horology.TimeInterval)">
            <summary>
            Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithInvocationCount(BenchmarkDotNet.Jobs.Job,System.Int64)">
            <summary>
            Invocation count in a single iteration.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.IterationTime"/> will be ignored.
            If specified, it must be a multiple of <see cref="P:BenchmarkDotNet.Jobs.RunMode.UnrollFactor"/>.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithUnrollFactor(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            How many times the benchmark method will be invoked per one iteration of a generated loop.
            The default value is 16.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.RunOncePerIteration(BenchmarkDotNet.Jobs.Job)">
            <summary>
            Run the benchmark exactly once per iteration.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMinIterationCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            Minimum count of target iterations that should be performed.
            The default value is 15.
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/> is not going to work.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMaxIterationCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            Maximum count of target iterations that should be performed.
            The default value is 100.
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/>  is not going to work.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithPowerPlan(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Environments.PowerPlan)">
            <summary>
            Power plan for benchmarks.
            The default value is HighPerformance.
            <remarks>Only available for Windows.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithPowerPlan(BenchmarkDotNet.Jobs.Job,System.Guid)">
            <summary>
            Setting power plans by guid.
            The default value is HighPerformance.
            <remarks>Only available for Windows.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.DontEnforcePowerPlan(BenchmarkDotNet.Jobs.Job)">
            <summary>
            ensures that BenchmarkDotNet does not enforce any power plan
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMemoryRandomization(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            specifies whether Engine should allocate some random-sized memory between iterations
            <remarks>it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.With(BenchmarkDotNet.Jobs.Job,System.Collections.Generic.IReadOnlyList{BenchmarkDotNet.Jobs.EnvironmentVariable})">
            <summary>
            Creates a new job based on the given job with specified environment variables.
            It overrides the whole list of environment variables which were defined in the original job.
            </summary>
            <param name="job">The original job</param>
            <param name="environmentVariables">The environment variables for the new job</param>
            <exception cref="T:System.InvalidOperationException">
            Throws an exception if <paramref name="environmentVariables"/> contains two variables with the same key.
            </exception>
            <returns>The new job with overriden environment variables</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithEnvironmentVariables(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Jobs.EnvironmentVariable[])">
            <summary>
            Creates a new job based on the given job with specified environment variables.
            It overrides the whole list of environment variables which were defined in the original job.
            </summary>
            <param name="job">The original job</param>
            <param name="environmentVariables">The environment variables for the new job</param>
            <exception cref="T:System.InvalidOperationException">
            Throws an exception if <paramref name="environmentVariables"/> contains two variables with the same key.
            </exception>
            <returns>The new job with overriden environment variables</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.With(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Jobs.EnvironmentVariable)">
            <summary>
            Creates a new job based on the given job with additional environment variable.
            All existed environment variables of the original job will be copied to the new one.
            If the original job already contains an environment variable with the same key, it will be overriden.
            </summary>
            <param name="job">The original job</param>
            <param name="environmentVariable">The new environment variable which should be added for the new job</param>
            <returns>The new job with additional environment variable</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithEnvironmentVariable(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Jobs.EnvironmentVariable)">
            <summary>
            Creates a new job based on the given job with additional environment variable.
            All existed environment variables of the original job will be copied to the new one.
            If the original job already contains an environment variable with the same key, it will be overriden.
            </summary>
            <param name="job">The original job</param>
            <param name="environmentVariable">The new environment variable which should be added for the new job</param>
            <returns>The new job with additional environment variable</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithEnvironmentVariable(BenchmarkDotNet.Jobs.Job,System.String,System.String)">
            <summary>
            Creates a new job based on the given job with additional environment variable.
            All existed environment variables of the original job will be copied to the new one.
            If the original job already contains an environment variable with the same key, it will be overriden.
            </summary>
            <param name="job">The original job</param>
            <param name="key">The key of the new environment variable</param>
            <param name="value">The value of the new environment variable</param>
            <returns>The new job with additional environment variable</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithoutEnvironmentVariables(BenchmarkDotNet.Jobs.Job)">
            <summary>
            Creates a new job based on the given job without any environment variables.
            </summary>
            <param name="job">The original job</param>
            <returns>The new job which doesn't have any environment variables</returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithNuGet(BenchmarkDotNet.Jobs.Job,System.String,System.String,System.Uri,System.Boolean)">
            <summary>
            Runs the job with a specific NuGet dependency which will be resolved during the Job build process
            </summary>
            <param name="job"></param>
            <param name="packageName">The NuGet package name</param>
            <param name="packageVersion">(optional)The NuGet package version</param>
            <param name="source">(optional)Indicate the URI of the NuGet package source to use during the restore operation.</param>
            <param name="prerelease">(optional)Allows prerelease packages to be installed.</param>
            <returns></returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithNuGet(BenchmarkDotNet.Jobs.Job,BenchmarkDotNet.Jobs.NuGetReferenceList)">
            <summary>
            Runs the job with a specific NuGet dependencies which will be resolved during the Job build process
            </summary>
            <param name="job"></param>
            <param name="nuGetReferences">A collection of NuGet dependencies</param>
            <returns></returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMaxRelativeError(BenchmarkDotNet.Jobs.Job,System.Double)">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            The default value is 0.02.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxAbsoluteError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMaxAbsoluteError(BenchmarkDotNet.Jobs.Job,Perfolizer.Horology.TimeInterval)">
            <summary>
            Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error).
            Doesn't have a default value.
            <remarks>If <see cref="P:BenchmarkDotNet.Jobs.AccuracyMode.MaxRelativeError"/> is also provided, the smallest value is used as stop criteria.</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMinIterationTime(BenchmarkDotNet.Jobs.Job,Perfolizer.Horology.TimeInterval)">
            <summary>
            Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithMinInvokeCount(BenchmarkDotNet.Jobs.Job,System.Int32)">
            <summary>
            Minimum count of benchmark invocations per iteration
            The default value is 4.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithEvaluateOverhead(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result.
            True by default, very important for nano-benchmarks.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.WithOutlierMode(BenchmarkDotNet.Jobs.Job,Perfolizer.Mathematics.OutlierDetection.OutlierMode)">
            <summary>
            Specifies which outliers should be removed from the distribution
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.AsMutator(BenchmarkDotNet.Jobs.Job)">
            <summary>
            mutator job should not be added to the config, but instead applied to other jobs in given config
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.JobExtensions.AsDefault(BenchmarkDotNet.Jobs.Job,System.Boolean)">
            <summary>
            use it if you want to specify custom default settings for default job used by console arguments parser
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.MetaMode.IsMutator">
            <summary>
            mutator job should not be added to the config, but instead applied to other jobs in given config
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.MetaMode.IsDefault">
            <summary>
            set to true if you want to specify custom default settings for default job used by console arguments parser
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.NuGetReference.Equals(BenchmarkDotNet.Jobs.NuGetReference)">
            <summary>
            Object is equals when the package name and version are the same
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BenchmarkDotNet.Jobs.NuGetReference.IsValidVersion(System.String)">
            <summary>
            Tries to validate the version string
            </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="F:BenchmarkDotNet.Jobs.NuGetReference.PreReleaseValidator">
            <summary>
            Used to validate all pre-release parts of a semver version
            </summary>
            <remarks>
            Allows alphanumeric chars, ".", "+", "-"
            </remarks>
        </member>
        <member name="T:BenchmarkDotNet.Jobs.NuGetReferenceList">
            <summary>
            An ordered list of NuGet references. Does not allow duplicate references with the same PackageName.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.RunStrategy">
            <summary>
            Available values: Throughput and ColdStart.
                Throughput: default strategy which allows to get good precision level.
                ColdStart: should be used only for measuring cold start of the application or testing purpose.
                Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.LaunchCount">
            <summary>
            How many times we should launch process with target benchmark.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.WarmupCount">
            <summary>
            How many warmup iterations should be performed.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.IterationCount">
            <summary>
            How many target iterations should be performed
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MinIterationCount"/> will be ignored.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.MaxIterationCount"/> will be ignored.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.IterationTime">
            <summary>
            Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration.
            The default value is 500 milliseconds.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.InvocationCount">
            <summary>
            Invocation count in a single iteration.
            If specified, <see cref="P:BenchmarkDotNet.Jobs.RunMode.IterationTime"/> will be ignored.
            If specified, it must be a multiple of <see cref="P:BenchmarkDotNet.Jobs.RunMode.UnrollFactor"/>.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.UnrollFactor">
            <summary>
            How many times the benchmark method will be invoked per one iteration of a generated loop.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.MinIterationCount">
            <summary>
            Minimum count of target iterations that should be performed
            The default value is 15
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/> is not going to work</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.MaxIterationCount">
            <summary>
            Maximum count of target iterations that should be performed
            The default value is 100
            <remarks>If you set this value to below 15, then <see cref="T:BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer"/>  is not going to work</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.MinWarmupIterationCount">
            <summary>
            Minimum count of warmup iterations that should be performed
            The default value is 6
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.MaxWarmupIterationCount">
            <summary>
            Maximum count of warmup iterations that should be performed
            The default value is 50
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Jobs.RunMode.MemoryRandomization">
            <summary>
            specifies whether Engine should allocate some random-sized memory between iterations
            <remarks>it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration</remarks>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Loggers.ILogger.Priority">
            <summary>
            If there are several loggers with the same <see cref="P:BenchmarkDotNet.Loggers.ILogger.Id"/>,
            only logger with the highest priority will be used.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Loggers.LoggerWithPrefix">
            <summary>
            Adds prefix for each line
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Mathematics.MeasurementsStatistics">
            <summary>
            the goal of this struct is to avoid any heap allocations, please keep it in mind
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Mathematics.MeasurementsStatistics.StandardError">
            <summary>
            Standard error in nanoseconds.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Mathematics.MeasurementsStatistics.Mean">
            <summary>
            Mean in nanoseconds.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Mathematics.MeasurementsStatistics.ConfidenceInterval">
            <summary>
            99.9% confidence interval in nanoseconds.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Mathematics.NumeralSystem.Arabic">
            <summary>
            Arabic numerals (1, 2, 3, 4, ...)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Mathematics.NumeralSystem.Roman">
            <summary>
            Roman numerals (I, II, III, IV, ...)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Mathematics.NumeralSystem.Stars">
            <summary>
            Unary numeral system (*, **, ***, ****, ...)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Mathematics.PercentileValues.Percentile(System.Collections.Generic.IReadOnlyList{System.Double},System.Int32)">
            <summary>
            Calculates the Nth percentile from the set of values
            </summary>
            <remarks>
            The implementation is expected to be consistent with the one from Excel.
            It's a quite common to export bench output into .csv for further analysis
            And it's a good idea to have same results from all tools being used.
            </remarks>
            <param name="sortedValues">Sequence of the values to be calculated</param>
            <param name="percentile">Value in range 0..100</param>
            <returns>Percentile from the set of values</returns>
        </member>
        <member name="M:BenchmarkDotNet.Mathematics.Statistics.CanBeInverted">
            <summary>
            Returns true, if this statistics can be inverted (see <see cref="M:BenchmarkDotNet.Mathematics.Statistics.Invert"/>).
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Mathematics.Statistics.Invert">
            <summary>
            Statistics for [1/X]. If Min is less then or equal to 0, returns null.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Mathematics.Statistics.MulMean(BenchmarkDotNet.Mathematics.Statistics,BenchmarkDotNet.Mathematics.Statistics)">
            <summary>
            Mean for [X*Y].
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Mathematics.Statistics.DivMean(BenchmarkDotNet.Mathematics.Statistics,BenchmarkDotNet.Mathematics.Statistics)">
            <summary>
            Mean for [X/Y].
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Portability.Cpu.ProcCpuInfoProvider">
            <summary>
            CPU information from output of the `cat /proc/info` command.
            Linux only.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Portability.Cpu.SysctlCpuInfoProvider">
            <summary>
            CPU information from output of the `sysctl -a` command.
            MacOSX only.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Portability.Cpu.WmicCpuInfoProvider">
            <summary>
            CPU information from output of the `wmic cpu get Name, NumberOfCores, NumberOfLogicalProcessors /Format:List` command.
            Windows only.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Portability.RuntimeInformation.IsMono">
            <summary>
            returns true for both the old (implementation of .NET Framework) and new Mono (.NET 6+ flavour)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Portability.RuntimeInformation.GetWindowsUbr">
            <summary>
            On Windows, this method returns UBR (Update Build Revision) based on Registry.
            Returns null if the value is not available
            </summary>
            <returns></returns>
        </member>
        <member name="M:BenchmarkDotNet.Reports.DisplayPrecisionManager.GetPrecision(BenchmarkDotNet.Reports.SummaryStyle,BenchmarkDotNet.Columns.IStatisticColumn,BenchmarkDotNet.Columns.IStatisticColumn)">
            <summary>
            Returns the best amount of decimal digits for the given column.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Reports.Measurement">
            <summary>
            The basic captured statistics for a benchmark
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Reports.Measurement.Operations">
            <summary>
            Gets the number of operations performed.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Reports.Measurement.Nanoseconds">
            <summary>
            Gets the total number of nanoseconds it took to perform all operations.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Reports.Measurement.#ctor(System.Int32,BenchmarkDotNet.Engines.IterationMode,BenchmarkDotNet.Engines.IterationStage,System.Int32,System.Int64,System.Double)">
            <summary>
            Creates an instance of <see cref="T:BenchmarkDotNet.Reports.Measurement"/> struct.
            </summary>
            <param name="launchIndex"></param>
            <param name="iterationMode"></param>
            <param name="iterationStage"></param>
            <param name="iterationIndex"></param>
            <param name="operations">The number of operations performed.</param>
            <param name="nanoseconds">The total number of nanoseconds it took to perform all operations.</param>
        </member>
        <member name="M:BenchmarkDotNet.Reports.Measurement.GetAverageTime">
            <summary>
            Gets the average duration of one operation.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Reports.Measurement.Parse(System.String,System.Int32)">
             <summary>
             Parses the benchmark statistics from the plain text line.
            
             E.g. given the input <paramref name="line"/>:
            
                 WorkloadTarget 1: 10 op, 1005842518 ns
            
             Will extract the number of <see cref="P:BenchmarkDotNet.Reports.Measurement.Operations"/> performed and the
             total number of <see cref="P:BenchmarkDotNet.Reports.Measurement.Nanoseconds"/> it took to perform them.
             </summary>
             <param name="line">The line to parse.</param>
             <param name="processIndex">Process launch index, indexed from one.</param>
             <returns>An instance of <see cref="T:BenchmarkDotNet.Reports.Measurement"/> if parsed successfully. <c>Null</c> in case of any trouble.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Reports.MeasurementExtensions.GetOpsPerSecond(BenchmarkDotNet.Reports.Measurement)">
            <summary>
            Gets the number of operations performed per second (ops/sec).
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Reports.Summary.Item(BenchmarkDotNet.Running.BenchmarkCase)">
            <summary>
            Returns a report for the given benchmark or null if there is no a corresponded report.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Running.BenchmarkId">
            <summary>
            represents an internal entity used to identify a benchmark within an executable with multiple benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Running.BenchmarkSwitcher.RunAll(BenchmarkDotNet.Configs.IConfig,System.String[])">
            <summary>
            Run all available benchmarks.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Running.BenchmarkSwitcher.RunAllJoined(BenchmarkDotNet.Configs.IConfig,System.String[])">
            <summary>
            Run all available benchmarks and join them to a single summary
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Running.BuildPartition.RepresentativeBenchmarkCase">
            <summary>
            the benchmarks are grouped by the build settings
            so you can use this benchmark to get the runtime settings
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Running.ConsoleTitler">
            <summary>
            Updates Console.Title, subject to platform capabilities and Console availability.
            Restores the original (or fallback) title upon disposal.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Running.ConsoleTitler.IsEnabled">
            <summary>
            Whether this instance has any effect. This will be false if the platform doesn't support Console retitling,
            or if Console output is redirected.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Running.ConsoleTitler.UpdateTitle(System.String)">
            <summary>
            Updates Console.Title if enabled.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher.UpdateDuplicatedDependencies(BenchmarkDotNet.Toolchains.ArtifactsPaths,BenchmarkDotNet.Loggers.ILogger)">
            <summary>
            update CoreRun folder with newer versions of duplicated dependencies
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain.#ctor(System.IO.FileInfo,System.Boolean,System.String,System.IO.FileInfo,System.IO.DirectoryInfo,System.String)">
            <summary>
            creates a CoreRunToolchain which is using provided CoreRun to execute .NET Core apps
            </summary>
            <param name="coreRun">the path to CoreRun</param>
            /<param name="createCopy">should a copy of CoreRun be performed? True by default. <remarks>The toolchain replaces old dependencies in CoreRun folder with newer versions if used by the benchmarks.</remarks></param>
            <param name="targetFrameworkMoniker">TFM, netcoreapp2.1 is the default</param>
            <param name="customDotNetCliPath">path to dotnet cli, if not provided the one from PATH will be used</param>
            <param name="displayName">display name, CoreRun is the default value</param>
            <param name="restorePath">the directory to restore packages to</param>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain">
            <summary>
            this toolchain is designed for the new .csprojs, to build .NET 4.x benchmarks from the context of .NET Core host process
            it does not work with the old .csprojs or project.json!
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.GetRuntimeSettings(BenchmarkDotNet.Jobs.GcMode,BenchmarkDotNet.Characteristics.IResolver)">
            <summary>
            returns an MSBuild string that defines Runtime settings
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.GetProjectFilePath(System.Type,BenchmarkDotNet.Loggers.ILogger)">
            <summary>
            returns a path to the project file which defines the benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.AdditionalNuGetFeed(System.String,System.String)">
            <summary>it allows you to define an additional NuGet feed, you can seal the feeds list by using the UseNuGetClearTag() method</summary>
            <param name="feedName">the name of the feed, will be used in the auto-generated NuGet.config file</param>
            <param name="feedAddress">the address of the feed, will be used in the auto-generated NuGet.config file</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.UseNuGetClearTag(System.Boolean)">
            <summary>
            emits clear tag in the auto-generated NuGet.config file
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.TargetFrameworkMoniker(System.String)">
            <param name="targetFrameworkMoniker">TFM, example: netcoreapp2.1</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.DotNetCli(System.String)">
            <param name="newCustomDotNetCliPath">if not provided, the one from PATH will be used</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.RuntimeIdentifier(System.String)">
            <param name="newRuntimeIdentifier">if not provided, portable OS-arch will be used (example: "win-x64", "linux-x86")</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.RuntimeFrameworkVersion(System.String)">
            <param name="newRuntimeFrameworkVersion">optional, when set it's copied to the generated .csproj file</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.DisplayName(System.String)">
            <param name="newDisplayName">the name of the toolchain to be displayed in results</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.UseTempFolderForRestore(System.Boolean)">
            <summary>
            restore to temp folder to keep your CI clean or install same package many times (perhaps with different content but same version number), by default true for local builds
            https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/dogfooding.md#3---consuming-subsequent-code-changes-by-rebuilding-the-package-alternative-2
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator.GetBuildArtifactsDirectoryPath(BenchmarkDotNet.Running.BuildPartition,System.String)">
            <summary>
            we need our folder to be on the same level as the project that we want to reference
            we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build)
            and also by NuGet internal implementation like looking for global.json file in parent folders
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings">
            <summary>
            custom settings used in the auto-generated project.json / .csproj file
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode)">
            <summary>
            <param name="targetFrameworkMoniker">
            sample values: netcoreapp2.0, netcoreapp2.1
            </param>
            <param name="runtimeFrameworkVersion">
            used in the auto-generated .csproj file
            simply ignored if null or empty
            </param>
            <param name="name">
            display name used for showing the results
            </param>
            <param name="customDotNetCliPath">
            customize dotnet cli path if default is not desired
            simply ignored if null
            </param>
            <param name="packagesPath">the directory to restore packages to</param>
            <param name="customRuntimePack">path to a custom runtime pack</param>
            <param name="aotCompilerPath">path to Mono AOT compiler</param>
            <param name="aotCompilerMode">Mono AOT compiler moder</param>
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.TargetFrameworkMoniker">
            <summary>
            sample values: netcoreapp2.0, netcoreapp2.1
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.Name">
            <summary>
            display name used for showing the results
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.PackagesPath">
            <summary>
            The directory to restore packages to.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.CustomRuntimePack">
            <summary>
            Path to a custom runtime pack.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.AOTCompilerPath">
            <summary>
            Path to the Mono AOT Compiler
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.AOTCompilerMode">
            <summary>
            Mono AOT Compiler mode, either 'mini' or 'llvm'
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetBuildArtifactsDirectoryPath(BenchmarkDotNet.Running.BuildPartition,System.String)">
            <summary>
            returns a path to the folder where auto-generated project and code are going to be placed
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetBinariesDirectoryPath(System.String,System.String)">
            <summary>
            returns a path where executable should be found after the build (usually \bin)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetIntermediateDirectoryPath(System.String,System.String)">
            <summary>
            returns a path where intermediate files should be found after the build (usually \obj)
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetExecutableExtension">
            <summary>
            returns OS-specific executable extension
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetProjectFilePath(System.String)">
            <summary>
            returns a path to the auto-generated .csproj file
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetProjectFilePathForReferences(System.String)">
            <summary>
            returns a path to the auto-generated .csproj file that is used to build the reference dlls
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetArtifactsToCleanup(BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            returns a list of artifacts that should be removed after running the benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.CopyAllRequiredFiles(BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            if you need to copy some extra files to make the benchmarks work you should override this method
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GenerateNuGetConfig(BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            generates NuGet.Config file to make sure that BDN is using the right NuGet feeds
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GenerateProject(BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Toolchains.ArtifactsPaths,BenchmarkDotNet.Loggers.ILogger)">
            <summary>
            generates .csproj file with a reference to the project with benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GenerateBuildScript(BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            generates a script can be used when debugging compilation issues
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GetPackagesDirectoryPath(System.String)">
            <summary>
            returns a path to the folder where NuGet packages should be restored
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GenerateAppConfig(BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            generates an app.config file next to the executable with benchmarks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.GeneratorBase.GenerateCode(BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            generates the C# source code with all required boilerplate.
            <remarks>You most probably do NOT need to override this method!!</remarks>
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ByRefConsumeEmitter.EmitActionBeforeLoopOverride(System.Reflection.Emit.ILGenerator)">
            <summary>Emits the action before loop override.</summary>
            <param name="ilBuilder">The il builder.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">EmitActionKind - null</exception>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.EmitExtensions">
            <summary>
            this class is a set of hack extensions that allow us to target .NET Standard 2.0 only and keep some .NET Framework-specific logic
            do not copy, it's a set of dirty hacks
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.NonConsumableConsumeEmitter.EmitActionBeforeLoopOverride(System.Reflection.Emit.ILGenerator)">
            <summary>Emits the action before loop override.</summary>
            <param name="ilBuilder">The il builder.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">EmitActionKind - null</exception>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableEmitter">
            <summary>
            A helper type that emits code that matches BenchmarkType.txt template.
            IMPORTANT: this type IS NOT thread safe.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableEmitter.ArgFieldInfo">
            <summary>
            Maps action args to fields that store arg values.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableEmitter.EmitPartitionAssembly(BenchmarkDotNet.Toolchains.Results.GenerateResult,BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Loggers.ILogger)">
            <summary>
            Emits assembly with runnables from current build partition..
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants">
            <summary>
            A helper type that emits code that matches BenchmarkType.txt template.
            IMPORTANT: this type IS NOT thread safe.
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor">
            <summary>
            Implementation of <see cref="T:BenchmarkDotNet.Toolchains.IExecutor" /> for in-process benchmarks.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.DefaultTimeout">
            <summary> Default timeout for in-process benchmarks. </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.#ctor(System.TimeSpan,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor" /> class.</summary>
            <param name="timeout">Timeout for the run.</param>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.ExecutionTimeout">
            <summary>Timeout for the run.</summary>
            <value>The timeout for the run.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.LogOutput">
            <summary>Gets a value indicating whether the output should be logged.</summary>
            <value><c>true</c> if the output should be logged; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.Execute(BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters)">
            <summary>Executes the specified benchmark.</summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.Instance">
            <summary>The default toolchain instance.</summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.DontLogOutput">
            <summary>The toolchain instance without output logging.</summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain" /> class.</summary>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.#ctor(System.TimeSpan,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain" /> class.</summary>
            <param name="timeout">Timeout for the run.</param>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.InProcessHost">
            <summary>Host API for in-process benchmarks.</summary>
            <seealso cref="T:BenchmarkDotNet.Engines.IHost"/>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.#ctor(BenchmarkDotNet.Running.BenchmarkCase,BenchmarkDotNet.Loggers.ILogger,BenchmarkDotNet.Diagnosers.IDiagnoser)">
            <summary>Creates a new instance of <see cref="T:BenchmarkDotNet.Toolchains.InProcess.InProcessHost"/>.</summary>
            <param name="benchmarkCase">Current benchmark.</param>
            <param name="logger">Logger for informational output.</param>
            <param name="diagnoser">Diagnosers, if attached.</param>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.IsDiagnoserAttached">
            <summary><c>True</c> if there are diagnosers attached.</summary>
            <value><c>True</c> if there are diagnosers attached.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.RunResults">
            <summary>Results of the run.</summary>
            <value>Results of the run.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.Config">
            <summary>Current config</summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.Write(System.String)">
            <summary>Passes text to the host.</summary>
            <param name="message">Text to write.</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.WriteLine">
            <summary>Passes new line to the host.</summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.WriteLine(System.String)">
            <summary>Passes text (new line appended) to the host.</summary>
            <param name="message">Text to write.</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.SendSignal(BenchmarkDotNet.Engines.HostSignal)">
            <summary>Sends notification signal to the host.</summary>
            <param name="hostSignal">The signal to send.</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessHost.ReportResults(BenchmarkDotNet.Engines.RunResults)">
            <summary>Submits run results to the host.</summary>
            <param name="runResults">The run results.</param>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.InProcessValidator">
            <summary>
                Validator to be used together with <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain" /> or <see cref="T:BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain"/>
                to proof that the config matches the environment.
            </summary>
            <seealso cref="T:BenchmarkDotNet.Validators.IValidator" />
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.DontFailOnError">
            <summary>The instance of validator that does NOT fail on error.</summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.FailOnError">
            <summary>The instance of validator that DOES fail on error.</summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.TreatsWarningsAsErrors">
            <summary>Gets a value indicating whether warnings are treated as errors.</summary>
            <value>
                <c>true</c> if the validator should treat warnings as errors; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.Validate(BenchmarkDotNet.Validators.ValidationParameters)">
            <summary>Proofs that benchmarks' jobs match the environment.</summary>
            <param name="validationParameters">The validation parameters.</param>
            <returns>Enumerable of validation errors.</returns>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction">
            <summary>Common API to run the Setup/Clean/Idle/Run methods</summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.InvokeSingle">
            <summary>Gets or sets invoke single callback.</summary>
            <value>Invoke single callback.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.InvokeUnroll">
            <summary>Gets or sets invoke multiple times callback.</summary>
            <value>Invoke multiple times callback.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.LastRunResult">
            <summary>Gets the last run result.</summary>
            <value>The last run result.</value>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory">
            <summary>Helper class that creates <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction"/> instances. </summary>
            <summary>Helper class that creates <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction"/> instances. </summary>
            <summary>Helper class that creates <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction"/> instances. </summary>
            <summary>Helper class that creates <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction"/> instances. </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateCore(System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Dispatch method that creates <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction"/> using
            <paramref name="targetMethod"/> or <paramref name="fallbackIdleSignature"/> to find correct implementation.
            Either <paramref name="targetMethod"/> or <paramref name="fallbackIdleSignature"/> should be not <c>null</c>.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.Create(System.Type,System.Object,System.Reflection.MethodInfo,System.Int32)">
            <summary>Helper to enforce .ctor signature.</summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateWorkload(BenchmarkDotNet.Running.Descriptor,System.Object,System.Int32)">
            <summary>Creates run benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <param name="unrollFactor">Unroll factor.</param>
            <returns>Run benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateOverhead(BenchmarkDotNet.Running.Descriptor,System.Object,System.Int32)">
            <summary>Creates idle benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <param name="unrollFactor">Unroll factor.</param>
            <returns>Idle benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateGlobalSetup(BenchmarkDotNet.Running.Descriptor,System.Object)">
            <summary>Creates global setup benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <returns>Setup benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateGlobalCleanup(BenchmarkDotNet.Running.Descriptor,System.Object)">
            <summary>Creates global cleanup benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <returns>Cleanup benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateIterationSetup(BenchmarkDotNet.Running.Descriptor,System.Object)">
            <summary>Creates global setup benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <returns>Setup benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateIterationCleanup(BenchmarkDotNet.Running.Descriptor,System.Object)">
            <summary>Creates global cleanup benchmark action.</summary>
            <param name="descriptor">Descriptor info.</param>
            <param name="instance">Instance of target.</param>
            <returns>Cleanup benchmark action.</returns>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.CreateDummy">
            <summary>Creates a dummy benchmark action.</summary>
            <returns>Dummy benchmark action.</returns>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.BenchmarkActionBase">
            <summary>Base class that provides reusable API for final implementations.</summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder">
            <summary>
            In process (no emit) toolchain builder
            </summary>
            <seealso cref="T:BenchmarkDotNet.Toolchains.IBuilder" />
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder.Build(BenchmarkDotNet.Toolchains.Results.GenerateResult,BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Loggers.ILogger)">
            <summary>always returns success</summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor">
            <summary>
            Implementation of <see cref="T:BenchmarkDotNet.Toolchains.IExecutor" /> for in-process (no emit) toolchain.
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.DefaultTimeout">
            <summary> Default timeout for in-process benchmarks. </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.#ctor(System.TimeSpan,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor" /> class.</summary>
            <param name="timeout">Timeout for the run.</param>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.ExecutionTimeout">
            <summary>Timeout for the run.</summary>
            <value>The timeout for the run.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.LogOutput">
            <summary>Gets a value indicating whether the output should be logged.</summary>
            <value><c>true</c> if the output should be logged; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.Execute(BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters)">
            <summary>Executes the specified benchmark.</summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator">
            <summary>
            Implementation of <see cref="T:BenchmarkDotNet.Toolchains.IGenerator"/> for in-process (no emit) toolchain.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator.GenerateProject(BenchmarkDotNet.Running.BuildPartition,BenchmarkDotNet.Loggers.ILogger,System.String)">
            <summary>returns a success</summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitRunner">
            <summary>
            In-process (no emit) toolchain runner
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitRunner.FillMembers(System.Object,BenchmarkDotNet.Running.BenchmarkCase)">
            <summary>Fills the properties of the instance of the object used to run the benchmark.</summary>
            <param name="instance">The instance.</param>
            <param name="benchmarkCase">The benchmark.</param>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain">
            <summary>
                A toolchain to run the benchmarks in-process (no emit).
            </summary>
            <seealso cref="T:BenchmarkDotNet.Toolchains.IToolchain" />
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.Instance">
            <summary>The default toolchain instance.</summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.DontLogOutput">
            <summary>The toolchain instance without output logging.</summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain" /> class.</summary>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.#ctor(System.TimeSpan,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain" /> class.</summary>
            <param name="timeout">Timeout for the run.</param>
            <param name="logOutput"><c>true</c> if the output should be logged.</param>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.Name">
            <summary>Name of the toolchain.</summary>
            <value>The name of the toolchain.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.Generator">
            <summary>The generator.</summary>
            <value>The generator.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.Builder">
            <summary>The builder.</summary>
            <value>The builder.</value>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.Executor">
            <summary>The executor.</summary>
            <value>The executor.</value>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.ToString">
            <summary>Returns a <see cref="T:System.String" /> that represents this instance.</summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.NativeAot.Generator">
            <summary>
            generates new csproj file for self-contained NativeAOT app
            based on https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built
            and https://github.com/dotnet/corert/tree/7f902d4d8b1c3280e60f5e06c71951a60da173fb/samples/HelloWorld#add-corert-to-your-project
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.Generator.GenerateReflectionFile(BenchmarkDotNet.Toolchains.ArtifactsPaths)">
            <summary>
            mandatory to make it possible to call GC.GetAllocatedBytesForCurrentThread() using reflection (not part of .NET Standard)
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.Net60">
            <summary>
            compiled as net6.0, targets experimental 6.0.0-* NativeAOT build from the https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.Net70">
            <summary>
            compiled as net7.0, targets latest NativeAOT build from the NuGet.org feed
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.Net80">
            <summary>
            compiled as net8.0, targets latest NativeAOT build from the NuGet.org feed: "https://api.nuget.org/v3/index.json"
            </summary>
        </member>
        <member name="F:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.Net90">
            <summary>
            compiled as net9.0, targets latest NativeAOT build from the .NET 9 feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9/nuget/v3/index.json
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.UseNuGet(System.String,System.String)">
            <summary>
            creates a NativeAOT toolchain targeting NuGet build of Microsoft.DotNet.ILCompiler
            Based on https://github.com/dotnet/runtimelab/blob/d0a37893a67c125f9b0cd8671846ff7d867df241/samples/HelloWorld/README.md#add-corert-to-your-project
            </summary>
            <param name="microsoftDotNetILCompilerVersion">the version of Microsoft.DotNet.ILCompiler which should be used. The default is empty which maps to latest version.</param>
            <param name="nuGetFeedUrl">url to NuGet feed, The default is: "https://api.nuget.org/v3/index.json"</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.UseLocalBuild(System.IO.DirectoryInfo)">
            <summary>
            creates a NativeAOT toolchain targeting local build of ILCompiler
            Based on https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/nativeaot.md
            </summary>
            <param name="ilcPackages">the path to shipping packages, example: "C:\runtime\artifacts\packages\Release\Shipping"</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.PackagesRestorePath(System.String)">
            <summary>
            The directory to restore packages to (optional).
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.RootAllApplicationAssemblies(System.Boolean)">
            <summary>
            This controls the compiler behavior where all code in the application assemblies is considered dynamically reachable.
            This option is disabled by default.
            Enabling this option (true) has a significant effect on the size of the resulting executable because it prevents removal of unused code that would otherwise happen.
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.IlcGenerateCompleteTypeMetadata(System.Boolean)">
            <summary>
            This controls the generation of complete type metadata.
            This option is enabled by default.
            This is a compilation mode that prevents a situation where some members of a type are visible to reflection at runtime, but others aren't, because they weren't compiled.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.IlcGenerateStackTraceData(System.Boolean)">
            <summary>
            This controls generation of stack trace metadata that provides textual names in stack traces.
            This option is enabled by default.
            This is for example the text string one gets by calling Exception.ToString() on a caught exception.
            With this option disabled, stack traces will still be generated, but will be based on reflection metadata alone (they might be less complete).
            </summary>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.IlcOptimizationPreference(System.String)">
            <summary>
            Options related to code generation.
            </summary>
            <param name="value">"Speed" to favor code execution speed (default), "Size" to favor smaller code size</param>
        </member>
        <member name="M:BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.IlcInstructionSet(System.String)">
            <summary>
            By default, the compiler targets the minimum instruction set supported by the target OS and architecture.
            This option allows targeting newer instruction sets for better performance.
            The native binary will require the instruction sets to be supported by the hardware in order to run.
            For example, `avx2,bmi2,fma,pclmul,popcnt,aes` will produce binary that takes advantage of instruction sets
            that are typically present on current Intel and AMD processors.
            </summary>
            <param name="value">Specify empty string ("", not null) to use the defaults.</param>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.Results.ExecuteResult.StandardOutput">
            <summary>
            All lines printed to standard output by the Benchmark process
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.Results.ExecuteResult.PrefixedLines">
            <summary>
            Lines reported by the Benchmark process that are starting with "//"
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Toolchains.Results.ExecuteResult.Results">
            <summary>
            Lines reported by the Benchmark process that are not starting with "//"
            </summary>
        </member>
        <member name="T:BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain">
            <summary>
            Build a benchmark program with the Roslyn compiler.
            </summary>
        </member>
        <member name="P:BenchmarkDotNet.Validators.CompositeValidator.TreatsWarningsAsErrors">
            <summary>
            returns true if any of the validators has TreatsWarningsAsErrors == true
            </summary>
        </member>
        <member name="T:SimpleJson.JsonArray">
            <summary>
            Represents the json array.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
            <param name="capacity">The capacity of the json array.</param>
        </member>
        <member name="M:SimpleJson.JsonArray.ToString">
            <summary>
            The json representation of the array.
            </summary>
            <returns>The json representation of the array.</returns>
        </member>
        <member name="T:SimpleJson.JsonObject">
            <summary>
            Represents the json object.
            </summary>
        </member>
        <member name="F:SimpleJson.JsonObject._members">
            <summary>
            The internal member dictionary.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the key.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.String,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
                <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.String)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.TryGetValue(System.String,System.Object@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Determines whether [contains] [the specified item].
            </summary>
            <param name="item">The item.</param>
            <returns>
            	<c>true</c> if [contains] [the specified item]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <summary>
            Copies to.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Removes the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.ToString">
            <summary>
            Returns a json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:SimpleJson.SimpleJson">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:SimpleJson.SimpleJson.DeserializeObject(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>An IList&lt;object>, a IDictionary&lt;string,object>, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.TryDeserializeObject(System.String,System.Object@)">
            <summary>
            Try parsing the json string into a value.
            </summary>
            <param name="json">
            A JSON string.
            </param>
            <param name="obj">
            The object.
            </param>
            <returns>
            Returns true if successful otherwise false.
            </returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.SerializeObject(System.Object,SimpleJson.IJsonSerializerStrategy)">
            <summary>
            Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
            </summary>
            <param name="json">A IDictionary&lt;string,object> / IList&lt;object></param>
            <param name="jsonSerializerStrategy">Serializer strategy to use</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.IsNumeric(System.Object)">
            <summary>
            Determines if a given object is numeric in any way
            (can be integer, double, null, etc).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
             <summary>
             Indicates that the value of the marked element could be <c>null</c> sometimes,
             so checking for <c>null</c> is required before its usage.
             </summary>
             <example><code>
             [CanBeNull] object Test() => null;
            
             void UseTest() {
               var p = Test();
               var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element can never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
            <example><code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
            <example><code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
             <summary>
             Indicates that the marked method builds a string by the format pattern and (optional) arguments.
             The parameter, which contains the format string, should be given in the constructor. The format string
             should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
             </summary>
             <example><code>
             [StringFormatMethod("message")]
             void ShowError(string message, params object[] args) { /* do something */ }
            
             void Foo() {
               ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
             }
             </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as the format string.
            </param>
        </member>
        <member name="T:JetBrains.Annotations.StructuredMessageTemplateAttribute">
             <summary>
             Indicates that the marked parameter is a message template where placeholders are to be replaced by the following arguments
             in the order in which they appear.
             </summary>
             <example><code>
             void LogInfo([StructuredMessageTemplate]string message, params object[] args) { /* do something */ }
            
             void Foo() {
               LogInfo("User created: {username}"); // Warning: Non-existing argument in format string
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
             <summary>
             Use this annotation to specify a type that contains static or const fields
             with values for the annotated property/field/parameter.
             The specified type will be used to improve completion suggestions.
             </summary>
             <example><code>
             namespace TestNamespace
             {
               public class Constants
               {
                 public static int INT_CONST = 1;
                 public const string STRING_CONST = "1";
               }
            
               public class Class1
               {
                 [ValueProvider("TestNamespace.Constants")] public int myField;
                 public void Foo([ValueProvider("TestNamespace.Constants")] string str) { }
            
                 public void Test()
                 {
                   Foo(/*try completion here*/);//
                   myField = /*try completion here*/
                 }
               }
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ValueRangeAttribute">
            <summary>
            Indicates that the integral value falls into the specified interval.
            It's allowed to specify multiple non-intersecting intervals.
            Values of interval boundaries are inclusive.
            </summary>
            <example><code>
            void Foo([ValueRange(0, 100)] int value) {
              if (value == -1) { // Warning: Expression is always 'false'
                ...
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NonNegativeValueAttribute">
            <summary>
            Indicates that the integral value never falls below zero.
            </summary>
            <example><code>
            void Foo([NonNegativeValue] int value) {
              if (value == -1) { // Warning: Expression is always 'false'
                ...
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be a string literal and match
            one of the parameters of the caller function. This annotation is used for parameters
            like 'string paramName' parameter of the <see cref="T:System.ArgumentNullException"/> constructor.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
            
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
            
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependence between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If the method has a single input parameter, its name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for the method output
            means that the method doesn't return normally (throws or terminates the process).<br/>
            Value <c>canbenull</c> is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
            with rows separated by the semicolon. There is no notion of order rows, all rows are checked
            for applicability and applied per each program state tracked by the analysis engine.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("null &lt;= param:null")] // reverse condition syntax
            public string GetName(string surname)
            </code></item>
            <item><code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data)
            </code></item>
            <item><code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates whether the marked element should be localized.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
             <summary>
             Indicates that the value of the marked type (or its derivatives)
             cannot be compared using '==' or '!=' operators and <c>Equals()</c>
             should be used instead. However, using '==' or '!=' for comparison
             with <c>null</c> is always permitted.
             </summary>
             <example><code>
             [CannotApplyEqualityOperator]
             class NoEquality { }
            
             class UsesNoEquality {
               void Test() {
                 var ca1 = new NoEquality();
                 var ca2 = new NoEquality();
                 if (ca1 != null) { // OK
                   bool condition = ca1 == ca2; // Warning
                 }
               }
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
             <summary>
             When applied to a target attribute, specifies a requirement for any type marked
             with the target attribute to implement or inherit the specific type or types.
             </summary>
             <example><code>
             [BaseTypeRequired(typeof(IComponent)] // Specify requirement
             class ComponentAttribute : Attribute { }
            
             [Component] // ComponentAttribute requires implementing IComponent interface
             class MyComponent : IComponent { }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
             <summary>
             Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
             so this symbol will be ignored by usage-checking inspections. <br/>
             You can use <see cref="T:JetBrains.Annotations.ImplicitUseKindFlags"/> and <see cref="T:JetBrains.Annotations.ImplicitUseTargetFlags"/>
             to configure how this attribute is applied.
             </summary>
             <example><code>
             [UsedImplicitly]
             public class TypeConverter {}
            
             public class SummaryData
             {
               [UsedImplicitly(ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature)]
               public SummaryData() {}
             }
            
             [UsedImplicitly(ImplicitUseTargetFlags.WithInheritors | ImplicitUseTargetFlags.Default)]
             public interface IService {}
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Can be applied to attributes, type parameters, and parameters of a type assignable from <see cref="T:System.Type"/> .
            When applied to an attribute, the decorated attribute behaves the same as <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            When applied to a type parameter or to a parameter of type <see cref="T:System.Type"/>,
            indicates that the corresponding type is used implicitly.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseKindFlags">
            <summary>
            Specifies the details of an implicitly used symbol when it is marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specifies what is considered to be used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of the type marked with the attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithInheritors">
            <summary> Inherited entities are considered used. </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with the attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available APIs,
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells the code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that the delegate can only be invoked during method execution
            (the delegate can be invoked zero or multiple times, but not stored to some field and invoked later,
            when the containing method is no longer on the execution stack).
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            If <see cref="P:JetBrains.Annotations.InstantHandleAttribute.RequireAwait"/> is true, the attribute will only take effect if the method invocation is located under the 'await' expression.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.InstantHandleAttribute.RequireAwait">
            <summary>
            Require the method invocation to be used under the 'await' expression for this attribute to take effect on the code analysis engine.
            Can be used for delegate/enumerable parameters of 'async' methods.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
             <summary>
             Indicates that a method does not make any observable state changes.
             The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
             </summary>
             <example><code>
             [Pure] int Multiply(int x, int y) => x * y;
            
             void M() {
               Multiply(123, 42); // Warning: Return value of pure method is not used
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of the method invocation must be used.
            </summary>
            <remarks>
            Methods decorated with this attribute (in contrast to pure methods) might change state,
            but make no sense without using their return value. <br/>
            Similarly to <see cref="T:JetBrains.Annotations.PureAttribute"/>, this attribute
            will help to detect usages of the method when the return value is not used.
            Optionally, you can specify a message to use when showing warnings, e.g.
            <code>[MustUseReturnValue("Use the return value to...")]</code>.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.RequireStaticDelegateAttribute">
            <summary>
            This annotation allows to enforce allocation-less usage patterns of delegates for performance-critical APIs.
            When this annotation is applied to the parameter of delegate type, the IDE checks the input argument of this parameter:
            * When a lambda expression or anonymous method is passed as an argument, the IDE verifies that the passed closure
              has no captures of the containing local variables and the compiler is able to cache the delegate instance
              to avoid heap allocations. Otherwise a warning is produced.
            * The IDE warns when the method name or local function name is passed as an argument as this always results
              in heap allocation of the delegate instance.
            </summary>
            <remarks>
            In C# 9.0+ code, the IDE will also suggest to annotate the anonymous function with the 'static' modifier
            to make use of the similar analysis provided by the language/compiler.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.ProvidesContextAttribute">
             <summary>
             Indicates the type member or parameter of some type that should be used instead of all other ways
             to get the value of that type. This annotation is useful when you have some "context" value evaluated
             and stored somewhere, meaning that all other ways to get this value must be consolidated with the existing one.
             </summary>
             <example><code>
             class Foo {
               [ProvidesContext] IBarService _barService = ...;
            
               void ProcessNode(INode node) {
                 DoSomething(node, node.GetGlobalServices().Bar);
                 //              ^ Warning: use value of '_barService' field
               }
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by code completion
            as a 'Source Template'. When the extension method is completed over some expression, its source code
            is automatically expanded like a template at the call site.
            </summary>
            <remarks>
            Template method bodies can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:JetBrains.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing the caret inside the block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:JetBrains.Annotations.MacroAttribute.Editable"/> property value to -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:JetBrains.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how a method, constructor invocation, or property access
            over a collection type affects the contents of the collection.
            When applied to a return value of a method, indicates if the returned collection
            is created exclusively for the caller (CollectionAccessType.UpdatedContent) or
            can be read/updated from outside (CollectionAccessType.Read | CollectionAccessType.UpdatedContent)
            Use <see cref="P:JetBrains.Annotations.CollectionAccessAttribute.CollectionAccessType"/> to specify the access type.
            </summary>
            <remarks>
            Using this attribute only makes sense if all collection methods are marked with this attribute.
            </remarks>
            <example><code>
            public class MyStringCollection : List&lt;string&gt;
            {
              [CollectionAccess(CollectionAccessType.Read)]
              public string GetFirstString()
              {
                return this.ElementAt(0);
              }
            }
            class Test
            {
              public void Foo()
              {
                // Warning: Contents of the collection is never updated
                var col = new MyStringCollection();
                string x = col.GetFirstString();
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessType">
            <summary>
            Provides a value for the <see cref="T:JetBrains.Annotations.CollectionAccessAttribute"/> to define
            how the collection method invocation affects the contents of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is an assertion method, i.e. it halts the control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with
            <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by the <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies the assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw an exception.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that the method is a pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
             <summary>
             Indicates that IEnumerable passed as a parameter is not enumerated.
             Use this annotation to suppress the 'Possible multiple enumeration of IEnumerable' inspection.
             </summary>
             <example><code>
             static void ThrowIfNull&lt;T&gt;([NoEnumeration] T v, string n) where T : class
             {
               // custom check for null but no enumeration
             }
            
             void Foo(IEnumerable&lt;string&gt; values)
             {
               ThrowIfNull(values, nameof(values));
               var x = values.ToList(); // No warnings about multiple enumeration
             }
             </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that the marked parameter, field, or property is a regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InjectedLanguage">
            <summary>
            Language of injected code fragment inside marked by the <see cref="T:JetBrains.Annotations.LanguageInjectionAttribute"/> string literal.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LanguageInjectionAttribute">
            <summary>
            Indicates that the marked parameter, field, or property is accepting a string literal
            containing code fragments in a specified language.
            </summary>
            <example><code>
            void Foo([LanguageInjection(InjectedLanguage.CSS, Prefix = "body{", Suffix = "}")] string cssProps)
            {
              // cssProps should only contains a list of CSS properties
            }
            </code></example>
            <example><code>
            void Bar([LanguageInjection("json")] string json)
            {
            }
            </code></example>
        </member>
        <member name="P:JetBrains.Annotations.LanguageInjectionAttribute.InjectedLanguage">
            <summary>Specifies a language of the injected code fragment.</summary>
        </member>
        <member name="P:JetBrains.Annotations.LanguageInjectionAttribute.InjectedLanguageName">
            <summary>Specifies a language name of the injected code fragment.</summary>
        </member>
        <member name="P:JetBrains.Annotations.LanguageInjectionAttribute.Prefix">
            <summary>Specifies a string that "precedes" the injected string literal.</summary>
        </member>
        <member name="P:JetBrains.Annotations.LanguageInjectionAttribute.Suffix">
            <summary>Specifies a string that "follows" the injected string literal.</summary>
        </member>
        <member name="T:JetBrains.Annotations.NoReorderAttribute">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.CodeTemplateAttribute">
            <summary>
            <para>
            Defines the code search template using the Structural Search and Replace syntax.
            It allows you to find and, if necessary, replace blocks of code that match a specific pattern.
            Search and replace patterns consist of a textual part and placeholders.
            Textural part must contain only identifiers allowed in the target language and will be matched exactly (white spaces, tabulation characters, and line breaks are ignored).
            Placeholders allow matching variable parts of the target code blocks.
            A placeholder has the following format: $placeholder_name$- where placeholder_name is an arbitrary identifier.
            </para>
            <para>
            Available placeholders:
            <list type="bullet">
            <item>$this$ - expression of containing type</item>
            <item>$thisType$ - containing type</item>
            <item>$member$ - current member placeholder</item>
            <item>$qualifier$ - this placeholder is available in the replace pattern and can be used to insert a qualifier expression matched by the $member$ placeholder.
            (Note that if $qualifier$ placeholder is used, then $member$ placeholder will match only qualified references)</item>
            <item>$expression$ - expression of any type</item>
            <item>$identifier$ - identifier placeholder</item>
            <item>$args$ - any number of arguments</item>
            <item>$arg$ - single argument</item>
            <item>$arg1$ ... $arg10$ - single argument</item>
            <item>$stmts$ - any number of statements</item>
            <item>$stmt$ - single statement</item>
            <item>$stmt1$ ... $stmt10$ - single statement</item>
            <item>$name{Expression, 'Namespace.FooType'}$ - expression with 'Namespace.FooType' type</item>
            <item>$expression{'Namespace.FooType'}$ - expression with 'Namespace.FooType' type</item>
            <item>$name{Type, 'Namespace.FooType'}$ - 'Namespace.FooType' type</item>
            <item>$type{'Namespace.FooType'}$ - 'Namespace.FooType' type</item>
            <item>$statement{1,2}$ - 1 or 2 statements</item>
            </list>
            </para>
            <para>
            Note that you can also define your own placeholders of the supported types and specify arguments for each placeholder type.
            This can be done using the following format: $name{type, arguments}$. Where 'name' - is the name of your placeholder,
            'type' - is the type of your placeholder (one of the following: Expression, Type, Identifier, Statement, Argument, Member),
            'arguments' - arguments list for your placeholder. Each placeholder type supports its own arguments, check examples below for more details.
            The placeholder type may be omitted and determined from the placeholder name, if the name has one of the following prefixes:
            <list type="bullet">
            <item>expr, expression - expression placeholder, e.g. $exprPlaceholder{}$, $expressionFoo{}$</item>
            <item>arg, argument - argument placeholder, e.g. $argPlaceholder{}$, $argumentFoo{}$</item>
            <item>ident, identifier - identifier placeholder, e.g. $identPlaceholder{}$, $identifierFoo{}$</item>
            <item>stmt, statement - statement placeholder, e.g. $stmtPlaceholder{}$, $statementFoo{}$</item>
            <item>type - type placeholder, e.g. $typePlaceholder{}$, $typeFoo{}$</item>
            <item>member - member placeholder, e.g. $memberPlaceholder{}$, $memberFoo{}$</item>
            </list>
            </para>
            <para>
            Expression placeholder arguments:
            <list type="bullet">
            <item>expressionType - string value in single quotes, specifies full type name to match (empty string by default)</item>
            <item>exactType - boolean value, specifies if expression should have exact type match (false by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myExpr{Expression, 'Namespace.FooType', true}$ - defines expression placeholder, matching expressions of the 'Namespace.FooType' type with exact matching.</item>
            <item>$myExpr{Expression, 'Namespace.FooType'}$ - defines expression placeholder, matching expressions of the 'Namespace.FooType' type or expressions which can be implicitly converted to 'Namespace.FooType'.</item>
            <item>$myExpr{Expression}$ - defines expression placeholder, matching expressions of any type.</item>
            <item>$exprFoo{'Namespace.FooType', true}$ - defines expression placeholder, matching expressions of the 'Namespace.FooType' type with exact matching.</item>
            </list>
            </para>
            <para>
            Type placeholder arguments:
            <list type="bullet">
            <item>type - string value in single quotes, specifies full type name to match (empty string by default)</item>
            <item>exactType - boolean value, specifies if expression should have exact type match (false by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myType{Type, 'Namespace.FooType', true}$ - defines type placeholder, matching 'Namespace.FooType' types with exact matching.</item>
            <item>$myType{Type, 'Namespace.FooType'}$ - defines type placeholder, matching 'Namespace.FooType' types or types, which can be implicitly converted to 'Namespace.FooType'.</item>
            <item>$myType{Type}$ - defines type placeholder, matching any type.</item>
            <item>$typeFoo{'Namespace.FooType', true}$ - defines types placeholder, matching 'Namespace.FooType' types with exact matching.</item>
            </list>
            </para>
            <para>
            Identifier placeholder arguments:
            <list type="bullet">
            <item>nameRegex - string value in single quotes, specifies regex to use for matching (empty string by default)</item>
            <item>nameRegexCaseSensitive - boolean value, specifies if name regex is case sensitive (true by default)</item>
            <item>type - string value in single quotes, specifies full type name to match (empty string by default)</item>
            <item>exactType - boolean value, specifies if expression should have exact type match (false by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myIdentifier{Identifier, 'my.*', false, 'Namespace.FooType', true}$ - defines identifier placeholder, matching identifiers (ignoring case) starting with 'my' prefix with 'Namespace.FooType' type.</item>
            <item>$myIdentifier{Identifier, 'my.*', true, 'Namespace.FooType', true}$ - defines identifier placeholder, matching identifiers (case sensitively) starting with 'my' prefix with 'Namespace.FooType' type.</item>
            <item>$identFoo{'my.*'}$ - defines identifier placeholder, matching identifiers (case sensitively) starting with 'my' prefix.</item>
            </list>
            </para>
            <para>
            Statement placeholder arguments:
            <list type="bullet">
            <item>minimalOccurrences - minimal number of statements to match (-1 by default)</item>
            <item>maximalOccurrences - maximal number of statements to match (-1 by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myStmt{Statement, 1, 2}$ - defines statement placeholder, matching 1 or 2 statements.</item>
            <item>$myStmt{Statement}$ - defines statement placeholder, matching any number of statements.</item>
            <item>$stmtFoo{1, 2}$ - defines statement placeholder, matching 1 or 2 statements.</item>
            </list>
            </para>
            <para>
            Argument placeholder arguments:
            <list type="bullet">
            <item>minimalOccurrences - minimal number of arguments to match (-1 by default)</item>
            <item>maximalOccurrences - maximal number of arguments to match (-1 by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myArg{Argument, 1, 2}$ - defines argument placeholder, matching 1 or 2 arguments.</item>
            <item>$myArg{Argument}$ - defines argument placeholder, matching any number of arguments.</item>
            <item>$argFoo{1, 2}$ - defines argument placeholder, matching 1 or 2 arguments.</item>
            </list>
            </para>
            <para>
            Member placeholder arguments:
            <list type="bullet">
            <item>docId - string value in single quotes, specifies XML documentation id of the member to match (empty by default)</item>
            </list>
            Examples:
            <list type="bullet">
            <item>$myMember{Member, 'M:System.String.IsNullOrEmpty(System.String)'}$ - defines member placeholder, matching 'IsNullOrEmpty' member of the 'System.String' type.</item>
            <item>$memberFoo{'M:System.String.IsNullOrEmpty(System.String)'}$ - defines member placeholder, matching 'IsNullOrEmpty' member of the 'System.String' type.</item>
            </list>
            </para>
            <para>
            For more information please refer to the <a href="https://www.jetbrains.com/help/resharper/Navigation_and_Search__Structural_Search_and_Replace.html">Structural Search and Replace</a> article.
            </para>
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.SearchTemplate">
            <summary>
            Structural search pattern to use in the code template.
            The pattern includes a textual part, which must contain only identifiers allowed in the target language,
            and placeholders, which allow matching variable parts of the target code blocks.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.Message">
            <summary>
            Message to show when the search pattern was found.
            You can also prepend the message text with "Error:", "Warning:", "Suggestion:" or "Hint:" prefix to specify the pattern severity.
            Code patterns with replace templates produce suggestions by default.
            However, if a replace template is not provided, then warning severity will be used.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.ReplaceTemplate">
            <summary>
            Structural search replace pattern to use in code template replacement.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.ReplaceMessage">
            <summary>
            The replace message to show in the light bulb.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.FormatAfterReplace">
            <summary>
            Apply code formatting after code replacement.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.MatchSimilarConstructs">
            <summary>
            Whether similar code blocks should be matched.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.ShortenReferences">
            <summary>
            Automatically insert namespace import directives or remove qualifiers that become redundant after the template is applied.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.CodeTemplateAttribute.SuppressionKey">
            <summary>
            The string to use as a suppression key.
            By default the following suppression key is used 'CodeTemplate_SomeType_SomeMember',
            where 'SomeType' and 'SomeMember' are names of the associated containing type and member to which this attribute is applied.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RouteTemplateAttribute">
            <summary>
            Indicates that the marked parameter, field, or property is a route template.
            </summary>
            <remarks>
            This attribute allows IDE to recognize the use of web frameworks' route templates
            to enable syntax highlighting, code completion, navigation, rename and other features in string literals.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.RouteParameterConstraintAttribute">
            <summary>
            Indicates that the marked type is custom route parameter constraint,
            which is registered in the application's Startup with the name <c>ConstraintName</c>.
            </summary>
            <remarks>
            You can specify <c>ProposedType</c> if target constraint matches only route parameters of specific type,
            it will allow IDE to create method's parameter from usage in route template
            with specified type instead of default <c>System.String</c>
            and check if constraint's proposed type conflicts with matched parameter's type.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.UriStringAttribute">
            <summary>
            Indicates that the marked parameter, field, or property is an URI string.
            </summary>
            <remarks>
            This attribute enables code completion, navigation, renaming and other features
            in URI string literals assigned to annotated parameters, fields, or properties.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.AspRouteConventionAttribute">
            <summary>
            Indicates that the marked method declares routing convention for ASP.NET.
            </summary>
            <remarks>
            The IDE will analyze all usages of methods marked with this attribute,
            and will add all routes to completion, navigation, and other features over URI strings.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.AspDefaultRouteValuesAttribute">
            <summary>
            Indicates that the marked method parameter contains default route values of routing convention for ASP.NET.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspRouteValuesConstraintsAttribute">
            <summary>
            Indicates that the marked method parameter contains constraints on route values of routing convention for ASP.NET.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspRouteOrderAttribute">
            <summary>
            Indicates that the marked parameter or property contains routing order provided by ASP.NET routing attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspRouteVerbsAttribute">
            <summary>
            Indicates that the marked parameter or property contains HTTP verbs provided by ASP.NET routing attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspAttributeRoutingAttribute">
            <summary>
            Indicates that the marked attribute is used for attribute routing in ASP.NET.
            </summary>
            <remarks>
            The IDE will analyze all usages of attributes marked with this attribute,
            and will add all routes to completion, navigation and other features over URI strings.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.AspMinimalApiDeclarationAttribute">
            <summary>
            Indicates that the marked method declares an ASP.NET Minimal API endpoint.
            </summary>
            <remarks>
            The IDE will analyze all usages of methods marked with this attribute,
            and will add all routes to completion, navigation and other features over URI strings.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.AspMinimalApiGroupAttribute">
            <summary>
            Indicates that the marked method declares an ASP.NET Minimal API endpoints group.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMinimalApiHandlerAttribute">
            <summary>
            Indicates that the marked parameter contains an ASP.NET Minimal API endpoint handler.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that the marked parameter or method is a Razor section.
            Use this attribute for custom wrappers similar to
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has an <c>ItemsSource</c> property and should be treated
            as an <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolution.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of an <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            The property should have the tree ancestor of the <c>ItemsControl</c> type, or
            marked with the <see cref="T:JetBrains.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemStyleOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>Style</c>-derived type that
            is used to style items of an <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:JetBrains.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.XamlOneWayBindingModeByDefaultAttribute">
            <summary>
            XAML attribute. Indicates that DependencyProperty has <c>OneWay</c> binding mode by default.
            </summary>
            <remarks>
            This attribute must be applied to DependencyProperty's CLR accessor property if it is present, or to a DependencyProperty descriptor field otherwise.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.XamlTwoWayBindingModeByDefaultAttribute">
            <summary>
            XAML attribute. Indicates that DependencyProperty has <c>TwoWay</c> binding mode by default.
            </summary>
            <remarks>
            This attribute must be applied to DependencyProperty's CLR accessor property if it is present, or to a DependencyProperty descriptor field otherwise.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.TestSubjectAttribute">
            <summary>
            Specifies the subject being tested by a test class or a test method.
            </summary>
            <remarks>
            The <see cref="T:JetBrains.Annotations.TestSubjectAttribute"/> can be applied to a test class or a test method to indicate what class
            or interface the tests defined in them test. This information can be used by an IDE to provide better navigation
            support or by test runners to group tests by subject and to provide better test reports.
            </remarks>
        </member>
        <member name="P:JetBrains.Annotations.TestSubjectAttribute.Subject">
            <summary>
            Gets the type of the subject being tested.
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.TestSubjectAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:JetBrains.Annotations.TestSubjectAttribute"/> class with the specified subject type.
            </summary>
            <param name="subject">The type of the subject being tested.</param>
        </member>
        <member name="T:JetBrains.Annotations.MeansTestSubjectAttribute">
             <summary>
             Signifies a generic argument as the test subject for a test class.
             </summary>
             <remarks>
             The <see cref="T:JetBrains.Annotations.MeansTestSubjectAttribute"/> can be applied to a generic parameter of a base test class to indicate that
             the type passed as the argument is the class being tested. This information can be used by an IDE to provide better
             navigation support or by test runners to group tests by subject and to provide better test reports.
             </remarks>
             <example><code>
             public class BaseTestClass&lt;[MeansTestSubject] T&gt;
             {
               protected T Component { get; }
             }
            
             public class CalculatorAdditionTests : BaseTestClass&lt;Calculator&gt;
             {
               [Test]
               public void Should_add_two_numbers()
               {
                  Assert.That(Component.Add(2, 3), Is.EqualTo(5));
               }
             }
             </code></example>
        </member>
        <member name="T:DirtyAssemblyResolveHelper">
             <summary>
             Sometimes NuGet/VS/other tool does not generate the right assembly binding redirects
             or just for any other magical reasons
             our users get FileNotFoundException when trying to run their benchmarks
            
             We want our users to be happy and we try to help the .NET framework when it fails to load an assembly
            
             It's not recommended to copy this code OR reuse it anywhere. It's an UGLY WORKAROUND.
            
             If one day we can remove it, the person doing that should celebrate!!
             </summary>
        </member>
        <member name="M:DirtyAssemblyResolveHelper.HelpTheFrameworkToResolveTheAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            according to https://msdn.microsoft.com/en-us/library/ff527268(v=vs.110).aspx
            "the handler is invoked whenever the runtime fails to bind to an assembly by name."
            </summary>
            <returns>not null when we find it manually, null when can't help</returns>
        </member>
    </members>
</doc>
