name: Update HTML Documents

on:
  pull_request:
    types:
      - closed
    branches:
      - master   # target branch of the PR
    paths:
      - "doc/distrib/html/*/**"   # matches any subfolder changes inside doc/distrib/html/
      
permissions:
  contents: write          # Allows reading/writing repository files
  pull-requests: write     # Allows creating/updating pull requests

jobs:
  run-on-merge:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    env:
      MAIN_BRANCH: master   # You can change this or set it dynamically

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # fetches all commits
          
      - name: Detect changed HTML files in doc/distrib/html
        id: changes
        run: |
          # Get changed HTML files under doc/distrib/html/
          CHANGED_FILES=$(git diff --name-only "${{ github.event.pull_request.base.sha }}" "${{ github.event.pull_request.merge_commit_sha }}" | grep '^doc/distrib/html/.*\.html$' || true)

          echo "Changed HTML files:"
          echo "$CHANGED_FILES"

          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      # Map files in src/ to full paths
      - name: Map changed files to full paths in src/
        id: map_files
        run: |
          import os
          import subprocess
          import json
          import glob

          # Get list of changed files from previous step
          changed_files = os.environ.get("CHANGED_FILES", "")
          if not changed_files.strip():
              print("No files provided in CHANGED_FILES")
              files = []
          else:
              files = changed_files.split()  # split by space
          file_map = []
          langs_path = "doc/distrib/html" 
          lang_dirs = []
          
          #Creates a list containing all the languages supported
          for item in os.listdir(langs_path):
              item_path = os.path.join(langs_path, item)
              if os.path.isdir(item_path):
                  lang_dirs.append(item)
          
          print("Languages:", lang_dirs)

          for f in files:
              # Get the filename with extension (without full path)
              filename = os.path.basename(f)

              # Get the language of the current file
              matches = [p for p in lang_dirs if p in f]
              if not matches:
                  print(f"No language match found for {f}, skipping.")
                  continue
              lang_match = matches[0]
  
              # Only search inside src/
              search_pattern = os.path.join("src", "**", filename)
              paths = glob.glob(search_pattern, recursive=True)

              # Filter for paths containing the specific language in file
              lang_paths = [p for p in paths if lang_match in p]

              if lang_paths:
                  file_map.append((f, lang_paths[0]))
              else:
                  print(f"⚠️ File {filename} not found in src/ with " + lang_match + " in the path!")

          print("File map:", file_map)

          # Save dictionary as JSON in GitHub Actions output
          with open(os.environ['GITHUB_OUTPUT'], "a") as gh_out:
              gh_out.write(f"file_map={json.dumps(file_map)}\n")
              
        shell: python
        env:
          CHANGED_FILES: ${{ steps.changes.outputs.changed_files }}

      - name: Overwrite files based on changed_files and file_map
        run: |
          import os
          import json
          import shutil

          # Get dictionary from previous step output
          file_map_json = os.environ.get("FILE_MAP", "{}")
          file_map = json.loads(file_map_json)

          # Iterate over changed files
          for f in file_map:
              src_path = f[0]
              dest_path = f[1]
              # Copy the file to destination
              shutil.copy2(src_path, dest_path)
              print(f"Copied {src_path} -> {dest_path}")
              
        shell: python
        env:
          FILE_MAP: ${{ steps.map_files.outputs.file_map }}        # JSON dictionary
          CHANGED_FILES: ${{ steps.changes.outputs.changed_files }} # newline-separated list
          
      - name: Check for changes
        id: git-check
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
          
      #Commit and push changes
      - name: Commit changes
        id: commit
        env:
          GH_TOKEN: ${{ secrets.DYNAMO_ACTIONS_TOKEN }}
        if: steps.git-check.outputs.changed == 'true'
        run: |
          set -e
          
          # Generate unique branch name using timestamp
          BRANCH="auto-update-$(date +%s)"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          # Configure Git
          git config user.name "dynamo-ci-user"
          git config user.email "dynamo@autodesk.com"
          
          # Create new branch
          git checkout -b $BRANCH
          git add src/**/*.html
          git commit -m "Automated changes"
          git push -u origin $BRANCH

      # Create PR using GitHub CLI
      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ secrets.DYNAMO_ACTIONS_TOKEN }}
        if: steps.git-check.outputs.changed == 'true'
        run: |
          # Get the branch name from previous step
          BRANCH="${{ steps.commit.outputs.branch }}"
          
          gh pr create --title "Documentation Automated Update" \
                       --body "This PR contains automated changes generated due to changes in doc/distrib/html subfolders" \
                       --base $MAIN_BRANCH \
                       --head $BRANCH
