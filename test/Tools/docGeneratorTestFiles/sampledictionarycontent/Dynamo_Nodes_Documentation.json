[{
    "Name": "ByKeysValues",
    "imageFile": ["ByKeysValues"],
    "dynFile": ["ByKeysValues"],
    "folderPath": "Dictionary/Create",
    "inDepth": "ByKeysValues will return a dictionary given the keys (strings) to lookup by and the values to return. The number of entries in the dictionary will be whatever input is shorter."
}, {
    "Name": "Components",
    "imageFile": ["Components"],
    "dynFile": ["Components"],
    "folderPath": "Dictionary/Action",
    "inDepth": "Components is essentially the reverse of ByKeysValues. Given a dictionary, this node will return the components that comprise the dictionary."
}, {
    "Name": "RemoveKeys",
    "imageFile": ["RemoveKeys"],
    "dynFile": ["RemoveKeys"],
    "folderPath": "Dictionary/Action",
    "inDepth": ""
}, {
    "Name": "SetValueAtKeys",
    "imageFile": ["SetValueAtKeys"],
    "dynFile": ["SetValueAtKeys"],
    "folderPath": "Dictionary/Action",
    "inDepth": "Produce a new Dictionary with a list of keys set to the new values, possibly overwriting existing key-value pairs. These two lists are expected to be of the same length. If not, the shorter of the two bounds the number of insertions."
}, {
    "Name": "ValueAtKey",
    "imageFile": ["ValueAtKey"],
    "dynFile": ["ValueAtKey"],
    "folderPath": "Dictionary/Action",
    "inDepth": "ValueAtKey will return the value from the given dictionary by the given key (string)."
}, {
    "Name": "Count",
    "imageFile": ["Count"],
    "dynFile": ["Count"],
    "folderPath": "Dictionary/Query",
    "inDepth": "Count will return the count of key/value pairs in the dictionary."
}, {
    "Name": "Keys",
    "imageFile": ["Keys"],
    "dynFile": ["Keys"],
    "folderPath": "Dictionary/Query",
    "inDepth": "Keys will return the keys stored in the given dictionary."
}, {
    "Name": "Values",
    "imageFile": ["Values"],
    "dynFile": ["Values"],
    "folderPath": "Dictionary/Query",
    "inDepth": "Values will return the values stored in the given dictionary."
}, {
    "Name": "Add",
    "imageFile": ["Add"],
    "dynFile": ["Add"],
    "folderPath": "Display/Color/Create",
    "inDepth": "Add will return a Vector that is the sum of two other Vectors. In the example below, the sum of the WCS Z axis and X axis Vectors results in a Vector with coordinates of (1,0,1). The new Vector is represented as a Line."
}, {
    "Name": "ByARGB",
    "imageFile": ["ByARGB"],
    "dynFile": ["ByARGB"],
    "folderPath": "Display/Color/Create",
    "inDepth": "ByARGB will create a color using input Alpha, Red, Green, and Blue values. The input values are in the range 0 to 255. In the example below, we use 4 number sliders set to the range 0 to 255 to control the input values of a ByARGB node. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
}, {
    "Name": "Color Palette",
    "imageFile": ["Color Palette.gif"],
    "dynFile": ["Color Palette"],
    "folderPath": "Display/Color/Create",
    "inDepth": "The color palette provides a nice UI to pick colors for use within Dynamo. (Kudos to Adam Sheather of the Bad Monkeys for this one."
}, {
    "Name": "Divide",
    "imageFile": ["Divide"],
    "dynFile": ["Divide"],
    "folderPath": "Display/Color/Create",
    "inDepth": "Divide will divide the individual channels of a color by an input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Divide node to divide the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
}, {
    "Name": "Multiply",
    "imageFile": ["Multiply"],
    "dynFile": ["Multiply"],
    "folderPath": "Display/Color/Create",
    "inDepth": "Multiply will multiply the individual channels of a color by an input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Multiply node to multiply the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
}, {
    "Name": "Brightness",
    "imageFile": ["Brightness"],
    "dynFile": ["Brightness"],
    "folderPath": "Display/Color/Action",
    "inDepth": "Brightness will return the brightness value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The brightness value of the resulting color is found by using a Brightness node."
}, {
    "Name": "Components",
    "imageFile": ["Components"],
    "dynFile": ["Components"],
    "folderPath": "Display/Color/Action",
    "inDepth": "Components will return the Days, Hours, Minutes, etc of a TimeSpan. In the example below, a TimeSpan of 5:16:21 returns 0 Days, 5 Hours, 6 Minutes, 21 Seconds, and 0 Milliseconds."
}, {
    "Name": "Hue",
    "imageFile": ["Hue"],
    "dynFile": ["Hue"],
    "folderPath": "Display/Color/Action",
    "inDepth": "Hue will return the hue value of an input color. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The hue value of the resulting color is found by using a Hue node."
}, {
    "Name": "Saturation",
    "imageFile": ["Saturation"],
    "dynFile": ["Saturation"],
    "folderPath": "Display/Color/Action",
    "inDepth": "Saturation will return the saturation value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The saturation value of the resulting color is found by using a Saturation node."
}, {
    "Name": "Alpha",
    "imageFile": ["Alpha"],
    "dynFile": ["Alpha"],
    "folderPath": "Display/Color/Query",
    "inDepth": "Alpha will return the alpha value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The alpha value of the resulting color is found by using an Alpha node."
}, {
    "Name": "Blue",
    "imageFile": ["Blue"],
    "dynFile": ["Blue"],
    "folderPath": "Display/Color/Query",
    "inDepth": "Blue will return the blue value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The blue value of the resulting color is found by using a Blue node."
}, {
    "Name": "Green",
    "imageFile": ["Green"],
    "dynFile": ["Green"],
    "folderPath": "Display/Color/Query",
    "inDepth": "Green will return the green value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The green value of the resulting color is found by using a Green node."
}, {
    "Name": "Red",
    "imageFile": ["Red"],
    "dynFile": ["Red"],
    "folderPath": "Display/Color/Query",
    "inDepth": "Red will return the red value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The red value of the resulting color is found by using a Red node."
}, {
    "Name": "ByColorsAndParameters",
    "imageFile": ["ByColorsAndParameters"],
    "dynFile": ["ByColorsAndParameters"],
    "folderPath": "Display/Color Range/Create",
    "inDepth": "ByColorsAndParameters creates an  2D color range from a list of input colors and a corresponding list of specified UV parameters in the range 0 to 1. In the example below, we use a code block to create three different colors (in this case simply green, red, and blue) and to combine them into a list. We use a separate code block to create three UV parameters, one for each color. These two lists are used as inputs to a ByColorsAndParameters node. We use a subsequent GetColorAtParameter node, along with a Display.ByGeometryColor node to visualize the 2D color range across a set of cubes."
}, {
    "Name": "Color Range",
    "imageFile": ["Color Range"],
    "dynFile": ["Color Range"],
    "folderPath": "Display/Color Range/Create",
    "inDepth": "Color Range will create a gradient between a set of input colors, and allow colors from that gradient to be selected by a list of input values. The first input, colors, is a list of colors to use in the gradient. The second inut, indices, will determine the relative location of the input colors in the gradient. This list should correspond to the list of colors, each value being in the range 0 to 1. The exact value is not important, only the relative position of the values. The color corresponding to the lowest value will be on the left of the gradient, and the color corresponding to the highest value will be on the right side of the gradient. The final values input allows the user to select points along the gradient in the range 0 to 1 to output. In the example below, we first create two colors: red and green. The order of these colors in the gradient is determined by a list that we create with a code block. A third code block is used to create a range of numbers between 0 and 1 that will determine the output colors from the gradient. A set of cubes is generated along the x-axis, and these cubes are finally colored according the gradient by using a Display.ByGeometryColor node."
}, {
    "Name": "GetColorAtParameter",
    "imageFile": ["GetColorAtParameter"],
    "dynFile": ["GetColorAtParameter"],
    "folderPath": "Display/Color Range/Action",
    "inDepth": "GetColorAtParameter takes an input 2D color range, and returns a list of colors at specified UV parameters in the range 0 to 1. In the example below, we first create a 2D Color Range using a ByColorsAndParameters node with a list of colors and list of parameters to set the range. A code block is used to generate a range of numbers between 0 and 1, which is used as the u and v inputs in a UV.ByCoordinates node. The lacing of this node is set to cross product. A set of cubes is created in a similar manner, which a Point.ByCoordinates node with cross product lacing used to created an array of cubes. We then use a Display.ByGeometryColor node with the array of cubes and the list of colors obtained from the GetColorAtParameter node."
}, {
    "Name": "Watch",
    "imageFile": ["Watch"],
    "dynFile": ["Watch"],
    "folderPath": "Display/Watch/Action",
    "inDepth": "Watch will display the output of a node in list format. In the example below, the contents of an Excel file are returned as a list and displayed in a Watch node. Watch is useful for understanding the list structures, geometry types, etc that different nodes return."
}, {
    "Name": "Watch 3D",
    "imageFile": ["Watch 3D"],
    "dynFile": ["Watch 3D"],
    "folderPath": "Display/Watch/Action",
    "inDepth": "Watch 3D will preview the geometry output of a node in a new workspace window. In the example below, a Solid is previewed in the Watch3D node while its PolySurface bounding box is previewed in the workspace."
}, {
    "Name": "Watch Image",
    "imageFile": ["Watch Image"],
    "dynFile": ["Watch Image"],
    "folderPath": "Display/Watch/Action",
    "inDepth": "Watch Image will preview a bitmap. In the example below, a bitmap used as a height field is previewed in a Watch Image node. This allows us to compare the resulting geometry with the original image."
}, {
    "Name": "ByCorners",
    "imageFile": ["ByCorners"],
    "dynFile": ["ByCorners"],
    "folderPath": "Geometry/Abstract/BoundingBox/Create",
    "inDepth": "Cuboid By Corners creates a cuboid where the two input points are used as the opposite corners of the cuboid. In the example file, two points are randomly generated and used to create a cuboid."
}, {
    "Name": "ByGeometry",
    "imageFile": ["ByGeometry"],
    "dynFile": ["ByGeometry"],
    "folderPath": "Geometry/Abstract/BoundingBox/Create",
    "inDepth": "ByGeometry brings each input geometry into Revit as an individual Import Instance element. An Import Instance is identified as an Import Symbol in Revit."
}, {
    "Name": "Contains",
    "imageFile": ["Contains"],
    "dynFile": ["Contains"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "Bounding Box Contains tests if a specified Point is inside of a Bounding Box. Because the Point in this example is at (5,5,5), and our Origin Sphere’s Radius is larger than 5, the Contains node will return True."
}, {
    "Name": "Intersection",
    "imageFile": ["Intersection"],
    "dynFile": ["Intersection"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "Bounding Box Intersection solves for the Intersection for two Bounding Boxes and returns the overlapping Bounding Box. This example uses two cones to demonstrate the use of this node. In order to visualize the Box we are converting it to a Cuboid."
}, {
    "Name": "Intersects",
    "imageFile": ["Intersects"],
    "dynFile": ["Intersects"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "Bounding Box Intersects tests two bounding boxes for overlap. If the boxes intersect, the node will return True, otherwise it will return False. This example tests for an intersection between the Bounding Boxes of two input Cones."
}, {
    "Name": "IsEmpty",
    "imageFile": ["IsEmpty"],
    "dynFile": ["IsEmpty"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "IsEmpty will return a boolean value based on whether the Bounding Box is empty or not."
}, {
    "Name": "ToCuboid",
    "imageFile": ["ToCuboid"],
    "dynFile": ["ToCuboid"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "Bounding Box ToCuboid creates a Cuboid geometry from a Bounding Box. In order to visualize the relationship of the input Sphere to the Cuboid in the example, we are extracting its edge curves."
}, {
    "Name": "ToPolySurface",
    "imageFile": ["ToPolySurface"],
    "dynFile": ["ToPolySurface"],
    "folderPath": "Geometry/Abstract/BoundingBox/Action",
    "inDepth": "ToPolySurface will return a bounding box as a PolySurface. In the example below, the bounding box of several unioned spheres is returned as a PolySurface. The resulting PolySurface is displayed with a color and transparency to show the original geometry inside."
}, {
    "Name": "MaxPoint",
    "imageFile": ["MaxPoint"],
    "dynFile": ["MaxPoint"],
    "folderPath": "Geometry/Abstract/BoundingBox/Query",
    "inDepth": "Bounding Box MaxPoint returns the point that has the largest X, Y and Z values. This example shows a Bounding Box MaxPoint of a Sphere."
}, {
    "Name": "MinPoint",
    "imageFile": ["MinPoint"],
    "dynFile": ["MinPoint"],
    "folderPath": "Geometry/Abstract/BoundingBox/Query",
    "inDepth": "Bounding Box MinPoint returns the point that has the smallest X, Y and Z values. This example shows a Bounding Box MinPoint of a Sphere."
}, {
    "Name": "ByCylindricalCoordinates",
    "imageFile": ["ByCylindricalCoordinates"],
    "dynFile": ["ByCylindricalCoordinates"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "The Point By Cylindrical Coordinates node creates a point located within a cylindrical space. Here, we set the lacing to Cross-Reference and use a range of angles and elevations to generate a grid of points along a cylinder with a dynamic radius."
}, {
    "Name": "ByMatrix",
    "imageFile": ["ByMatrix"],
    "dynFile": ["ByMatrix"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "Add in-depth information about ByMatrix..."
}, {
    "Name": "ByOrigin (origin)",
    "imageFile": ["ByOrigin (origin)"],
    "dynFile": ["ByOrigin (origin)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "ByOrigin (origin) will return a new CoordinateSystem with it's origin at the input Point. In the example below, a new CoordinateSystem is created with its origin at (4,4,0)."
}, {
    "Name": "ByOrigin (x, y, z)",
    "imageFile": ["ByOrigin (x, y, z)"],
    "dynFile": ["ByOrigin (x, y, z)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "ByOrigin (x, y, z) will return a new CoordinateSystem with the X, Y, and Z values of its origin as the node's inputs. In the example below, a new CoordinateSystem is created with it's origin at (4,2,1) from inputs 4, 2, and 1 into X, Y, and Z respectively."
}, {
    "Name": "ByOrigin (x, y)",
    "imageFile": ["ByOrigin (x, y)"],
    "dynFile": ["ByOrigin (x, y)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "ByOrigin (x, y) will return a new CoordinateSystem with the X and Y values of its origin as inputs. In the example below, a new CoordinateSystem is created with it's origin at (4,2,0) from inputs 4 and 2 into X and Y respectively."
}, {
    "Name": "ByOriginVectors (origin, xAxis, yAxis)",
    "imageFile": ["ByOriginVectors (origin, xAxis, yAxis)"],
    "dynFile": ["ByOriginVectors (origin, xAxis, yAxis)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "ByOriginVectors (origin, xAxis, yAxis) will return a new CoordinateSystem at an input origin point with input X and Y axes. In the example below, the CoordinateSystem is placed at an origin with new vectors for the X and Y axes. The result is a CoordinateSystem rotated relative to the original CoordinateSystem."
}, {
    "Name": "ByOriginVectors (origin, xAxis, yAxis, zAxis)",
    "imageFile": ["ByOriginVectors (origin, xAxis, yAxis, zAxis)"],
    "dynFile": ["ByOriginVectors (origin, xAxis, yAxis, zAxis)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "Add in-depth information about ByOriginVectors (origin, xAxis, yAxis, zAxis)..."
}, {
    "Name": "ByPlane",
    "imageFile": ["ByPlane"],
    "dynFile": ["ByPlane"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "Sketch planes are used in the creation of 2D and 3D geometry in Revit."
}, {
    "Name": "BySphericalCoordinates",
    "imageFile": ["BySphericalCoordinates"],
    "dynFile": ["BySphericalCoordinates"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "The Point By Spherical Coordinates node creates a point located within a spherical space. Here, we set the lacing to Cross-Reference and use a range of phi and theta angles to generate a grid of points along a cylinder with a dynamic radius. The location of the sphere is set to a Coordinate System with the origin (1, 5, 1)."
}, {
    "Name": "Identity",
    "imageFile": ["Identity"],
    "dynFile": ["Identity"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Create",
    "inDepth": "Identity will return what is passed in. In the example below, the Identity node is used to preview each piece of geometry created inside a Code Block."
}, {
    "Name": "Inverse",
    "imageFile": ["Inverse"],
    "dynFile": ["Inverse"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Inverse will return an inverted CoordinateSystem from the input. In the example below, a CoordinateSystem at (1,2,0) is inverted into a CoordinateSystem at (-1,-2,0). The geometry drawn on the CoordinateSystems will be opposite the WCS origin from each other."
}, {
    "Name": "IsEqualTo",
    "imageFile": ["IsEqualTo"],
    "dynFile": ["IsEqualTo"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "IsEqualTo will return a boolean value based on whether the values of the input CoordinateSystems are equal to each other. In the example below, two CoordinateSystems with identical, positive and negative origin positions are passed through IsEqualTo, returning a false boolean value. However, inverting the positive CoordinateSystem returns a true boolean value from IsEqualTo because it's origin point X and Y values are now negative."
}, {
    "Name": "Mirror",
    "imageFile": ["Mirror"],
    "dynFile": ["Mirror"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Geometry Mirror reflects a Geometry across a defined Plane. In this example, we are Mirroring a Cone across the Y-Axis."
}, {
    "Name": "PostMultiplyBy",
    "imageFile": ["PostMultiplyBy"],
    "dynFile": ["PostMultiplyBy"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "PostMultiplyBy will return a new CoordinateSystem from multiplying it by a CoordinateSystem and other (argument) CoordinateSystem. In the example below, a new CoordinateSystem is returned that is translated and rotated relative to the CS it was multiplied by and it's argument. Switching the coordinatesystem and other inputs will produce a different result as one is applied after the other."
}, {
    "Name": "PreMultiplyBy",
    "imageFile": ["PreMultiplyBy"],
    "dynFile": ["PreMultiplyBy"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "PreMultiplyBy will return a new CoordinateSystem from multiplying it by an other (argument) CoordinateSystem and a CoordinateSystem. In the example below, a new CoordinateSystem is returned that is translated and rotated relative to the CoordinateSystem it was multiplied by and it's argument. This node is similar to the PostMultiplyBy node with the only difference being that the other input is applied before the coordinatesystem input."
}, {
    "Name": "Rotate (origin, axis, degrees)",
    "imageFile": ["Rotate (origin, axis, degrees)"],
    "dynFile": ["Rotate (origin, axis, degrees)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Rotates a coordinate system around an origin and an axis by a specified degree."
}, {
    "Name": "Rotate (plane, degrees)",
    "imageFile": ["Rotate (plane, degrees)"],
    "dynFile": ["Rotate (plane, degrees)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Rotates a coordinate system on a plane by a specified degree."
}, {
    "Name": "Scale (plane, xamount, yamount, zamount)",
    "imageFile": ["Scale (plane, xamount, yamount, zamount)"],
    "dynFile": ["Scale (plane, xamount, yamount, zamount)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Scale the coordinate system non-uniformly around the origin on a given plane."
}, {
    "Name": "Scale (amount)",
    "imageFile": ["Scale (amount)"],
    "dynFile": ["Scale (amount)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Scale the coordinate system uniformly around the origin."
}, {
    "Name": "Scale (basePoint, from, to)",
    "imageFile": ["Scale (basePoint, from, to)"],
    "dynFile": ["Scale (basePoint, from, to)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": ""
}, {
    "Name": "Scale (xamount, yamount, zamount)",
    "imageFile": ["Scale (xamount, yamount, zamount)"],
    "dynFile": ["Scale (xamount, yamount, zamount)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Scale the coordinate system non-uniformly around the origin."
}, {
    "Name": "Scale1D",
    "imageFile": ["Scale1D"],
    "dynFile": ["Scale1D"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Geometry Scale1D Scales a Geometry in one direction from a Base Point and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the Cone Start Point. The original Cone Edges are drawn as a visual reference."
}, {
    "Name": "Scale2D",
    "imageFile": ["Scale2D"],
    "dynFile": ["Scale2D"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Geometry Scale2D Scales a Geometry in two directions from a Base Plane and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the YZ-Plane."
}, {
    "Name": "ScaleFactor",
    "imageFile": ["ScaleFactor"],
    "dynFile": ["ScaleFactor"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "ScaleFactor will return a Vector consisting of the X, Y, and Z scale factors of a CoordinateSystem. In the example below, a scaled CoordinateSystem returns a Vector with X, Y, and Z values of 4.4 and a length of 7.621."
}, {
    "Name": "Transform (cs)",
    "imageFile": ["Transform (cs)"],
    "dynFile": ["Transform (cs)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Transform the object by the input CoordinateSystem matrix."
}, {
    "Name": "Transform (fromCoordinateSystem, contextCoordinateSystem)",
    "imageFile": ["Transform (fromCoordinateSystem, contextCoordinateSystem)"],
    "dynFile": ["Transform (fromCoordinateSystem, contextCoordinateSystem)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Transforms this Coordinate System from source CoordinateSystem to a new context CoordinateSystem."
}, {
    "Name": "Translate (xTranslation, yTranslation, zTranslation)",
    "imageFile": ["Translate (xTranslation, yTranslation, zTranslation)"],
    "dynFile": ["Translate (xTranslation, yTranslation, zTranslation)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Translates any given Coordinate System by the given displacements in the x, y, and z directions defined in WCS respectively."
}, {
    "Name": "Translate (direction, distance)",
    "imageFile": ["Translate (direction, distance)"],
    "dynFile": ["Translate (direction, distance)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Translates any CoordinateSystem type by the given distance in the given direction."
}, {
    "Name": "Translate (direction)",
    "imageFile": ["Translate (direction)"],
    "dynFile": ["Translate (direction)"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Action",
    "inDepth": "Translate the object in the direction and magnitude of input Vector."
}, {
    "Name": "Determinant",
    "imageFile": ["Determinant"],
    "dynFile": ["Determinant"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "Obtain the Determinant of this CoordinateSystem."
}, {
    "Name": "IsScaledOrtho",
    "imageFile": ["IsScaledOrtho"],
    "dynFile": ["IsScaledOrtho"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "Tests if the scaling orthogonal, i.e. does it have a shear component."
}, {
    "Name": "IsSingular",
    "imageFile": ["IsSingular"],
    "dynFile": ["IsSingular"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "Determine whether it is possible to get the Inverse of this CoordinateSystem."
}, {
    "Name": "IsUniscaledOrtho",
    "imageFile": ["IsUniscaledOrtho"],
    "dynFile": ["IsUniscaledOrtho"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "Tests if the scaling orthogonal and are all the vectors normalized."
}, {
    "Name": "Origin",
    "imageFile": ["Origin"],
    "dynFile": ["Origin"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "Origin will return a Point at the Origin of the WorldCoordinateSystem. In the example below, a Circle by centerpoint and radius is created using a Point at the WCS Origin."
}, {
    "Name": "XAxis",
    "imageFile": ["XAxis"],
    "dynFile": ["XAxis"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "XAxis will return a Vector that represents the WorldCoordinateSystem X axis. In the example below, the Vector returned is used to create a Line that follows the WCS X axis."
}, {
    "Name": "XScaleFactor",
    "imageFile": ["XScaleFactor"],
    "dynFile": ["XScaleFactor"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "XScaleFactor will return a double representing the scale factor along the X Axis. In the example below, a cylinder is scaled by 2.3, returning an X scale factor of 2.3."
}, {
    "Name": "XYPlane",
    "imageFile": ["XYPlane"],
    "dynFile": ["XYPlane"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "XYPlane returns a plane in Dynamo from a reference point in the Revit conceptual design environment."
}, {
    "Name": "YAxis",
    "imageFile": ["YAxis"],
    "dynFile": ["YAxis"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "YAxis will return a Vector that represents the WorldCoordinateSystem Y axis. In the example below, the Vector returned is used to create a Line that follows the WCS Y axis."
}, {
    "Name": "YScaleFactor",
    "imageFile": ["YScaleFactor"],
    "dynFile": ["YScaleFactor"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "YScaleFactor will return a double representing the scale factor along the Y Axis. In the example below, a cylinder is scaled by 2.3, returning an Y scale factor of 2.3."
}, {
    "Name": "YZPlane",
    "imageFile": ["YZPlane"],
    "dynFile": ["YZPlane"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "YZPlane returns a plane in Dynamo from a reference point in the Revit conceptual design environment."
}, {
    "Name": "ZAxis",
    "imageFile": ["ZAxis"],
    "dynFile": ["ZAxis"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "ZAxis will return a Vector that represents the WorldCoordinateSystem Z axis. In the example below, the Vector returned is used to create a Line that follows the WCS Z axis."
}, {
    "Name": "ZScaleFactor",
    "imageFile": ["ZScaleFactor"],
    "dynFile": ["ZScaleFactor"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "ZScaleFactor will return a double representing the scale factor along the Z Axis. In the example below, a cylinder is scaled by 2.3, returning an Z scale factor of 2.3."
}, {
    "Name": "ZXPlane",
    "imageFile": ["ZXPlane"],
    "dynFile": ["ZXPlane"],
    "folderPath": "Geometry/Abstract/CoordinateSystem/Query",
    "inDepth": "ZXPlane will return a plane on the Z and X axes of a CoordinateSystem. In the example below, a plane is placed on the ZX axes of a rotated CoordinateSystem."
}, {
    "Name": "AdjacentFaces",
    "imageFile": ["AdjacentFaces"],
    "dynFile": ["AdjacentFaces"],
    "folderPath": "Geometry/Abstract/Edge/Query",
    "inDepth": "AdjacentFaces will return the Faces adjacent to an input Vertex. In the example below, a Vertex on a Cuboid will return a List of three Faces. Adjusting the Index Selector slider will change the input Vertex and return different sets of adjacent Faces. The Faces are represented as Surfaces."
}, {
    "Name": "CurveGeometry",
    "imageFile": ["CurveGeometry"],
    "dynFile": ["CurveGeometry"],
    "folderPath": "Geometry/Abstract/Edge/Query",
    "inDepth": "CurveGeometry will return an Edge as a Curve. In the example below, an identified Edge is represented as a Curve."
}, {
    "Name": "EndVertex",
    "imageFile": ["EndVertex"],
    "dynFile": ["EndVertex"],
    "folderPath": "Geometry/Abstract/Edge/Query",
    "inDepth": "EndVertex will return the Vertex at the end of an Edge. In the example below, an end Vertex is represented as a Point."
}, {
    "Name": "StartVertex",
    "imageFile": ["StartVertex"],
    "dynFile": ["StartVertex"],
    "folderPath": "Geometry/Abstract/Edge/Query",
    "inDepth": "StartVertex will return the Vertex at the start of an Edge. In the example below, a start Vertex is represented as a Point."
}, {
    "Name": "SurfaceGeometry",
    "imageFile": ["SurfaceGeometry"],
    "dynFile": ["SurfaceGeometry"],
    "folderPath": "Geometry/Abstract/Face/Action",
    "inDepth": "SurfaceGeometry will return a Face as a Surface. In the example below, a Face is identified on the Solid and returned as a Surface."
}, {
    "Name": "Edges",
    "imageFile": ["Edges"],
    "dynFile": ["Edges"],
    "folderPath": "Geometry/Abstract/Face/Query",
    "inDepth": "Edges will return a List of Edges from an input geometry. In the example below, a Cuboid returns a List of 12 Edges."
}, {
    "Name": "Vertices",
    "imageFile": ["Vertices"],
    "dynFile": ["Vertices"],
    "folderPath": "Geometry/Abstract/Face/Query",
    "inDepth": "Vertices will return a List of Vertex locations for an input geometry. In the example below, the a Cuboid returns a list of 8 Vertex locations."
}, {
    "Name": "ByBestFitThroughPoints",
    "imageFile": ["ByBestFitThroughPoints"],
    "dynFile": ["ByBestFitThroughPoints"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
}, {
    "Name": "ByLineAndPoint",
    "imageFile": ["ByLineAndPoint"],
    "dynFile": ["ByLineAndPoint"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane by Line and Point creates a plane using the input Point as the origin, and passing through the input line. The point must not lie on the axis of the line. In the example, we create a line by first using a set of random points and then creating a line with ByBestFitThroughPoints. An origin point is created with a code block providing the x,y, and z coordinates for a Point.ByCoordinates component. We then use the line and point as inputs to create a Plane by Line and Point."
}, {
    "Name": "ByOriginNormal",
    "imageFile": ["ByOriginNormal"],
    "dynFile": ["ByOriginNormal"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane by Origin Normal creates a plane using the input point as the origin, and perpendicular to the input Normal vector. In the example below, we use a code block to specify the x,y, and z coordinates of a Point By Coordinates. We then use that point as the Origin, and use a world Y-Axis as the normal vector for a Plane by Origin Normal."
}, {
    "Name": "ByOriginNormalXAxis",
    "imageFile": ["ByOriginNormalXAxis"],
    "dynFile": ["ByOriginNormalXAxis"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane by Origin Normal XAxis is similar to Plane By Origin Normal, but this allows us to also input a direction for the XAxis to control the orientation of the plane. If the input xAxis vector is not in the plane defined by the origin and normal inputs, it is first projected onto the plane to determine the Plane XAxis. In the example below, we use world YAxis as the normal vector, and use two code blocks to define the origin point and input xAxis."
}, {
    "Name": "ByOriginXAxisYAxis",
    "imageFile": ["ByOriginXAxisYAxis"],
    "dynFile": ["ByOriginXAxisYAxis"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane by Origin XAxis YAxis uses an origin point and two vectors to define a plane. The Normal vector of the plane is created by taking the cross product of the X and Y axis vectors. In the example below, we use world YAxis as the xAxis, and use two code blocks to define the origin point and input xAxis. "
}, {
    "Name": "ByThreePoints",
    "imageFile": ["ByThreePoints"],
    "dynFile": ["ByThreePoints"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane by Three Points will create a plane that passes through the three input points. The points must not be co-linear. In the example below, we use three code blocks to define the three initial points, then use ByThreePoints to create a plane."
}, {
    "Name": "XY",
    "imageFile": ["XY"],
    "dynFile": ["XY"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane XY creates a plane in the world XY directions. The normal of this plane is the world Z-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XY plane is highlighted."
}, {
    "Name": "XZ",
    "imageFile": ["XZ"],
    "dynFile": ["XZ"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane XZ creates a plane in the world XZ directions. The normal of this plane is the world Y-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XZ plane is highlighted."
}, {
    "Name": "YZ",
    "imageFile": ["YZ"],
    "dynFile": ["YZ"],
    "folderPath": "Geometry/Abstract/Plane/Create",
    "inDepth": "Plane YZ creates a plane in the world YZ directions. The normal of this plane is the world X-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the YZ plane is highlighted."
}, {
    "Name": "Offset",
    "imageFile": ["Offset"],
    "dynFile": ["Offset"],
    "folderPath": "Geometry/Abstract/Plane/Action",
    "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
}, {
    "Name": "ToCoordinateSystem",
    "imageFile": ["ToCoordinateSystem"],
    "dynFile": ["ToCoordinateSystem"],
    "folderPath": "Geometry/Abstract/Plane/Action",
    "inDepth": "Plane To Coordinate System will return a Coordinate System based on the input plane, using the plane's origin, XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then use ToCoordinateSystem to convert the Plane to a Coordinate System "
}, {
    "Name": "Normal",
    "imageFile": ["Normal"],
    "dynFile": ["Normal"],
    "folderPath": "Geometry/Abstract/Plane/Query",
    "inDepth": "Plane Normal will find the normal vector of an input plane. This is also equal to taking the cross product of the plane XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the normal vector of this plane."
}, {
    "Name": "Origin",
    "imageFile": ["Origin"],
    "dynFile": ["Origin"],
    "folderPath": "Geometry/Abstract/Plane/Query",
    "inDepth": "Origin will return a Point at the Origin of the WorldCoordinateSystem. In the example below, a Circle by centerpoint and radius is created using a Point at the WCS Origin."
}, {
    "Name": "XAxis",
    "imageFile": ["XAxis"],
    "dynFile": ["XAxis"],
    "folderPath": "Geometry/Abstract/Plane/Query",
    "inDepth": "XAxis will return a Vector that represents the WorldCoordinateSystem X axis. In the example below, the Vector returned is used to create a Line that follows the WCS X axis."
}, {
    "Name": "YAxis",
    "imageFile": ["YAxis"],
    "dynFile": ["YAxis"],
    "folderPath": "Geometry/Abstract/Plane/Query",
    "inDepth": "YAxis will return a Vector that represents the WorldCoordinateSystem Y axis. In the example below, the Vector returned is used to create a Line that follows the WCS Y axis."
}, {
    "Name": "Edges",
    "imageFile": ["Edges"],
    "dynFile": ["Edges"],
    "folderPath": "Geometry/Abstract/Topology/Query",
    "inDepth": "Edges will return a List of Edges from an input geometry. In the example below, a Cuboid returns a List of 12 Edges."
}, {
    "Name": "Faces",
    "imageFile": ["Faces"],
    "dynFile": ["Faces"],
    "folderPath": "Geometry/Abstract/Topology/Query",
    "inDepth": "Faces will return all the faces of a Revit element as surfaces in Dynamo."
}, {
    "Name": "Vertices",
    "imageFile": ["Vertices"],
    "dynFile": ["Vertices"],
    "folderPath": "Geometry/Abstract/Topology/Query",
    "inDepth": "Vertices will return a List of Vertex locations for an input geometry. In the example below, the a Cuboid returns a list of 8 Vertex locations."
}, {
    "Name": "ByCoordinates (x, y, z)",
    "imageFile": ["ByCoordinates (x, y, z)"],
    "dynFile": ["ByCoordinates (x, y, z)"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "ByCoordinates (x, y, z) will return a Vector from X, Y, and Z coordinates. The input coordinate location defines the Vector's position and length. In the example below, a Vector is returned from a coordinate location of (1,0,1) and is represented as a Line."
}, {
    "Name": "ByCoordinates (x, y, z, normalized)",
    "imageFile": ["ByCoordinates (x, y, z, normalized)"],
    "dynFile": ["ByCoordinates (x, y, z, normalized)"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "ByCoordinates (x, y, z, normalized) will return a Vector from coordinate values and a normalize boolean toggle. In the example below, a Vector is returned with a length of 2.83 that can be normalized to 1. The Vector is represented as a Line to show length change when toggling normalize."
}, {
    "Name": "ByTwoPoints",
    "imageFile": ["ByTwoPoints"],
    "dynFile": ["ByTwoPoints"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "ByTwoPoints will return a Vector defined by two Point locations. In the example below, a Vector created by two Points is represented by a Line. The Vector's length is 3, equal to the distance between Points."
}, {
    "Name": "XAxis",
    "imageFile": ["XAxis"],
    "dynFile": ["XAxis"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "XAxis will return a Vector that represents the WorldCoordinateSystem X axis. In the example below, the Vector returned is used to create a Line that follows the WCS X axis."
}, {
    "Name": "YAxis",
    "imageFile": ["YAxis"],
    "dynFile": ["YAxis"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "YAxis will return a Vector that represents the WorldCoordinateSystem Y axis. In the example below, the Vector returned is used to create a Line that follows the WCS Y axis."
}, {
    "Name": "ZAxis",
    "imageFile": ["ZAxis"],
    "dynFile": ["ZAxis"],
    "folderPath": "Geometry/Abstract/Vector/Create",
    "inDepth": "ZAxis will return a Vector that represents the WorldCoordinateSystem Z axis. In the example below, the Vector returned is used to create a Line that follows the WCS Z axis."
}, {
    "Name": "Add",
    "imageFile": ["Add"],
    "dynFile": ["Add"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Add will return a Vector that is the sum of two other Vectors. In the example below, the sum of the WCS Z axis and X axis Vectors results in a Vector with coordinates of (1,0,1). The new Vector is represented as a Line."
}, {
    "Name": "AngleAboutAxis",
    "imageFile": ["AngleAboutAxis"],
    "dynFile": ["AngleAboutAxis"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "AngleAboutAxis will return the angle measurement between two Vectors in degrees from 0 to 360 and about an axis of rotation. In the example below, the angle between two Vectors is measured about the Z axis. Adjust Z Elevation and Rotation Degrees sliders to see how they affect the resulting angle measurement. The Vectors are represented as Lines."
}, {
    "Name": "AngleWithVector",
    "imageFile": ["AngleWithVector"],
    "dynFile": ["AngleWithVector"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "AngleWithVector will return the angle measurement between two Vectors in degrees from 0 to 180. In the example below, an angle measurement is returned for two Vectors. Adjust Z Elevation and Rotation Degrees sliders to see how they affect the resulting angle measurement. The Vectors are represented as Lines."
}, {
    "Name": "AsPoint",
    "imageFile": ["AsPoint"],
    "dynFile": ["AsPoint"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "AsPoint will return a Point at the coordinate values of a Vector. In the example below, a Point is returned from the Vector.ByCoordinates node at (10,5,6)."
}, {
    "Name": "Cross",
    "imageFile": ["Cross"],
    "dynFile": ["Cross"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Cross will return the cross product of two Vectors. In the example below, the cross product of two Vectors results in a new Vector. The Vectors are represented as Lines."
}, {
    "Name": "Dot",
    "imageFile": ["Dot"],
    "dynFile": ["Dot"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Dot will return the dot product of two Vectors as a double. In the example below, Vectors of (10,5,6) and (1,10,1) return a dot product of 66."
}, {
    "Name": "IsAlmostEqualTo",
    "imageFile": ["IsAlmostEqualTo"],
    "dynFile": ["IsAlmostEqualTo"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "IsAlmostEqualTo will return a boolean value based on whether a Vector has the same values as another. In the example below, a true value is returned when comparing a Vector on the WCS Z axis to a Vector with coordinates of (0,0,1). Adjusting the Vector Direction slider will change the Vector's coordinate values making it unequal. The Vectors are represented as Lines."
}, {
    "Name": "IsParallel",
    "imageFile": ["IsParallel"],
    "dynFile": ["IsParallel"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "IsParallel will return a boolean value based on whether a Vector is parallel to another Vector. In the example below, two Vectors represented as Lines are compared. Adjust the slider to rotate one Vector in and out of parallel with the other."
}, {
    "Name": "Normalized",
    "imageFile": ["Normalized"],
    "dynFile": ["Normalized"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Normalized will return a normalized Vector. The Vector returned will have a length of 1 regardless of its original length. In the example below, a Vector of length ~1.4142 is normalized to a length of 1."
}, {
    "Name": "Reverse",
    "imageFile": ["Reverse"],
    "dynFile": ["Reverse"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Reverse will return a new Vector pointing in the opposite direction from its input. In the example below, a Vector of (1,0,1) will return a Vector of (-1,0,-1). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different reversed vector. The Vectors are represented as Lines."
}, {
    "Name": "Rotate (plane, degrees)",
    "imageFile": ["Rotate (plane, degrees)"],
    "dynFile": ["Rotate (plane, degrees)"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Rotates a vector around the Plane origin and normal by a specified degree."
}, {
    "Name": "Rotate (axis, degrees)",
    "imageFile": ["Rotate (axis, degrees)"],
    "dynFile": ["Rotate (axis, degrees)"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Rotates a vector around the axis and normal by a specified degree."
}, {
    "Name": "Scale (xScaleFactor, yScaleFactor, zScaleFactor)",
    "imageFile": ["Scale (xScaleFactor, yScaleFactor, zScaleFactor)"],
    "dynFile": ["Scale (xScaleFactor, yScaleFactor, zScaleFactor)"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Scale Vector non-uniformly around the origin."
}, {
    "Name": "Scale (scale_factor)",
    "imageFile": ["Scale (scale_factor)"],
    "dynFile": ["Scale (scale_factor)"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Scale Vector uniformly around the origin."
}, {
    "Name": "Subtract",
    "imageFile": ["Subtract"],
    "dynFile": ["Subtract"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Subtract will return a Vector that is the difference of two other Vectors. In the example below, the difference of the a Vector with coordinates (1,0,1) and WCS Z axis results in a Vector with coordinates of (1,0,0). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different subtracted vector. The Vectors are represented as Lines."
}, {
    "Name": "Transform",
    "imageFile": ["Transform"],
    "dynFile": ["Transform"],
    "folderPath": "Geometry/Abstract/Vector/Action",
    "inDepth": "Transform will return a new Vector based on an input CoordinateSystem. In the example below, a Vector is transformed from the WorldCoordinateSystem to a new CoordinateSystem defined by spherical coordinates. Try adjusting the sliders to move the new Vector into a different position. Both Vectors are represented as Lines."
}, {
    "Name": "Length",
    "imageFile": ["Length"],
    "dynFile": ["Length"],
    "folderPath": "Geometry/Abstract/Vector/Query",
    "inDepth": "Length returns the length of a curtain panel's boundary as a double. This can be used even if the curtain panel is not rectangular."
}, {
    "Name": "X",
    "imageFile": ["X"],
    "dynFile": ["X"],
    "folderPath": "Geometry/Abstract/Vector/Query",
    "inDepth": "X returns a double representing a reference point's X coordinate value in the Revit conceptual design environment."
}, {
    "Name": "Y",
    "imageFile": ["Y"],
    "dynFile": ["Y"],
    "folderPath": "Geometry/Abstract/Vector/Query",
    "inDepth": "Y returns a double representing a reference point's Y coordinate value in the Revit conceptual design environment."
}, {
    "Name": "Z",
    "imageFile": ["Z"],
    "dynFile": ["Z"],
    "folderPath": "Geometry/Abstract/Vector/Query",
    "inDepth": "Z returns a double representing a reference point's Z coordinate value in the Revit conceptual design environment."
}, {
    "Name": "AdjacentEdges",
    "imageFile": ["AdjacentEdges"],
    "dynFile": ["AdjacentEdges"],
    "folderPath": "Geometry/Abstract/Vertex/Query",
    "inDepth": "AdjacentEdges will return the Edges that emanate from a Vertex. In the example below, the Edges emanating from a Vertex on a Cube are represented as Lines. Adjust the Edges slider to return different sets of adjacent Edges."
}, {
    "Name": "AdjacentFaces",
    "imageFile": ["AdjacentFaces"],
    "dynFile": ["AdjacentFaces"],
    "folderPath": "Geometry/Abstract/Vertex/Query",
    "inDepth": "AdjacentFaces will return the Faces adjacent to an input Vertex. In the example below, a Vertex on a Cuboid will return a List of three Faces. Adjusting the Index Selector slider will change the input Vertex and return different sets of adjacent Faces. The Faces are represented as Surfaces."
}, {
    "Name": "PointGeometry",
    "imageFile": ["PointGeometry"],
    "dynFile": ["PointGeometry"],
    "folderPath": "Geometry/Abstract/Vertex/Query",
    "inDepth": "PointGeometry will return Vertex locations as Points. In the example below, the Vertices of a Cube are returned and represented as Points."
}, {
    "Name": "ByBestFitThroughPoints",
    "imageFile": ["ByBestFitThroughPoints"],
    "dynFile": ["ByBestFitThroughPoints"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
}, {
    "Name": "ByCenterPointRadiusAngle",
    "imageFile": ["ByCenterPointRadiusAngle"],
    "dynFile": ["ByCenterPointRadiusAngle"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Arc ByCenterPointRadiusAngle draws an arc relative to its center and normal direction. By entering the start and end angle, you are essentially drawing a portion of a circle. In this example, a random point is generated on the XY plane and an arc is constructed around it.  "
}, {
    "Name": "ByCenterPointStartPointEndPoint",
    "imageFile": ["ByCenterPointStartPointEndPoint"],
    "dynFile": ["ByCenterPointStartPointEndPoint"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Arc ByCenterPointStartPointEndPoint draws a best-fit arc around a specified Center. The arc will always begin at the Start Point and end at the closest point possible to the given End Point. This example demonstrates this property by randomly feeding the node three random points for the center, start and end point."
}, {
    "Name": "ByCenterPointStartPointSweepAngle",
    "imageFile": ["ByCenterPointStartPointSweepAngle"],
    "dynFile": ["ByCenterPointStartPointSweepAngle"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "The Arc ByCenterPointStartPointSweepAngle creates an arc around a Center Point with a given Sweep Angle. The Start Point tells Dynamo where to begin drawing the arc. This example draws an arc around a randomly generated point."
}, {
    "Name": "ByFillet",
    "imageFile": ["ByFillet"],
    "dynFile": ["ByFillet"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Arc ByFillet draws a portion of a tangential circle along two input curves. In this example, two intersecting lines are drawn and then filleted at a controlled radius."
}, {
    "Name": "ByFilletTangentToCurve",
    "imageFile": ["ByFilletTangentToCurve"],
    "dynFile": ["ByFilletTangentToCurve"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Arc ByFilletTangentToCurve draws the best fit arc that is tangent to three input curves. In this example, we are using two input lines as reference curves and a circle for the arc to be tangent to."
}, {
    "Name": "ByStartPointEndPointStartTangent",
    "imageFile": ["ByStartPointEndPointStartTangent"],
    "dynFile": ["ByStartPointEndPointStartTangent"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Arc ByStartPointEndPointStartTangent draws an arc from two specified points and any given start vector. This example draws an arc from two random points that is always tangent to the X-Axis."
}, {
    "Name": "ByThreePoints",
    "imageFile": ["ByThreePoints"],
    "dynFile": ["ByThreePoints"],
    "folderPath": "Geometry/Curves/Arc/Create",
    "inDepth": "Plane by Three Points will create a plane that passes through the three input points. The points must not be co-linear. In the example below, we use three code blocks to define the three initial points, then use ByThreePoints to create a plane."
}, {
    "Name": "ByStartEndAndTangencies",
    "imageFile": ["ByStartEndAndTangencies"],
    "dynFile": ["ByStartEndAndTangencies"],
    "folderPath": "Geometry/Curves/Arc/Action",
    "inDepth": "The Arc ByStartEndAndTangencies Action creates a compound arc using two Input Points and their corresponding Vectors. In this example, two points are connected by a compound arc that is always tangent to the Y-Axis at its Start and End Points."
}, {
    "Name": "CenterPoint",
    "imageFile": ["CenterPoint"],
    "dynFile": ["CenterPoint"],
    "folderPath": "Geometry/Curves/Arc/Query",
    "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
}, {
    "Name": "Radius",
    "imageFile": ["Radius"],
    "dynFile": ["Radius"],
    "folderPath": "Geometry/Curves/Arc/Query",
    "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
}, {
    "Name": "StartAngle",
    "imageFile": ["StartAngle"],
    "dynFile": ["StartAngle"],
    "folderPath": "Geometry/Curves/Arc/Query",
    "inDepth": "Start Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise starting from the plane X-axis. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Start Angle to extract the angle of the beginning pont of the ellipse."
}, {
    "Name": "SweepAngle",
    "imageFile": ["SweepAngle"],
    "dynFile": ["SweepAngle"],
    "folderPath": "Geometry/Curves/Arc/Query",
    "inDepth": "Sweep Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise on the ellipse plane, starting from the start angle. The end angle of the ellipse would be equal to the start angle plus the sweep angle. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Sweep Angle to extract arc length of the ellipse arc."
}, {
    "Name": "ByBestFitThroughPoints",
    "imageFile": ["ByBestFitThroughPoints"],
    "dynFile": ["ByBestFitThroughPoints"],
    "folderPath": "Geometry/Curves/Circle/Create",
    "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
}, {
    "Name": "ByCenterPointRadius",
    "imageFile": ["ByCenterPointRadius"],
    "dynFile": ["ByCenterPointRadius"],
    "folderPath": "Geometry/Curves/Circle/Create",
    "inDepth": "Sphere by Center Point Radius will create a sphere centered at the input point, and with an input radius. In the example below, we use a code block to specify the coordinates of a Point created by coordinates, and we use a number slider to determine the radius of the sphere."
}, {
    "Name": "ByCenterPointRadiusNormal",
    "imageFile": ["ByCenterPointRadiusNormal"],
    "dynFile": ["ByCenterPointRadiusNormal"],
    "folderPath": "Geometry/Curves/Circle/Create",
    "inDepth": "Circle By Center Point Radius Normal creates a circle at a point with a controllable radius and normal. In this example, we create a vector from the Origin Point to the Point By Coordinates to control the direction of the circle."
}, {
    "Name": "ByPlaneRadius",
    "imageFile": ["ByPlaneRadius"],
    "dynFile": ["ByPlaneRadius"],
    "folderPath": "Geometry/Curves/Circle/Create",
    "inDepth": "Circle By Plane Radius is a condensed node to create any type of circle. In this example, we use the YZ plane to determine the circle direction, and a Number slider to dynamically control the circle’s radius."
}, {
    "Name": "ByThreePoints",
    "imageFile": ["ByThreePoints"],
    "dynFile": ["ByThreePoints"],
    "folderPath": "Geometry/Curves/Circle/Create",
    "inDepth": "Plane by Three Points will create a plane that passes through the three input points. The points must not be co-linear. In the example below, we use three code blocks to define the three initial points, then use ByThreePoints to create a plane."
}, {
    "Name": "CenterPoint",
    "imageFile": ["CenterPoint"],
    "dynFile": ["CenterPoint"],
    "folderPath": "Geometry/Curves/Circle/Query",
    "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
}, {
    "Name": "Radius",
    "imageFile": ["Radius"],
    "dynFile": ["Radius"],
    "folderPath": "Geometry/Curves/Circle/Query",
    "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
}, {
    "Name": "ByBlendBetweenCurves",
    "imageFile": ["ByBlendBetweenCurves"],
    "dynFile": ["ByBlendBetweenCurves"],
    "folderPath": "Geometry/Curves/Curve/Create",
    "inDepth": "Curve by Blend Between Curves will create a new curve that connects two input curves. The two 'endOrStart' inputs determine whether to connect the end or start points of each curve. The created curve will match the curvature of the original curves at the connection points. In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. Two boolean toggle nodes let us control which ends of the two curves to blend between."
}, {
    "Name": "ByIsoCurveOnSurface",
    "imageFile": ["ByIsoCurveOnSurface"],
    "dynFile": ["ByIsoCurveOnSurface"],
    "folderPath": "Geometry/Curves/Curve/Create",
    "inDepth": "Curve by IsoCurve on Surface will create a curve that is the isocurve on a surface by specifying the U or V direction, and specifying the parameter in the opposite direction at which to create the curve. The 'direction' input determines which direction of isocurve to create. A value of one corresponds to the u-direction, while a value of zero corresponds to the v-direction. In the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByIsoCurveOnSurface node. A number slider set to a range of 0 to 1 and a step of 1 is used to control whether we extract the isocurve in the u or in the v direction. A second number slider is used to determine the parameter at which the isocurve is extracted."
}, {
    "Name": "ByParameterLineOnSurface",
    "imageFile": ["ByParameterLineOnSurface"],
    "dynFile": ["ByParameterLineOnSurface"],
    "folderPath": "Geometry/Curves/Curve/Create",
    "inDepth": "Curve by Parameter Line On Surface will create a line along a surface between two input UV coordinates. n the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByParameterLineOnSurface node. A set of number sliders are used to adjust the U and V inputs of two UV.ByCoordinates nodes, which are then used to determing the start and end point of the line on the surface."
}, {
    "Name": "ApproximateWithArcAndLineSegments",
    "imageFile": ["ApproximateWithArcAndLineSegments"],
    "dynFile": ["ApproximateWithArcAndLineSegments"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Approximate with Arc and Line Segments takes a curve as input, and returns a list of straight line and arc curves that approximate the original curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input for an ApproximateWithArcAndLineSegments node."
}, {
    "Name": "CoordinateSystemAtParameter",
    "imageFile": ["CoordinateSystemAtParameter"],
    "dynFile": ["CoordinateSystemAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Coordinate System at Parameter uses U and V input parameters and returns a coordinate system. The x-axis, y-axis, and z-axis of the Coordinate System are determined by the Normal direction, U direction, and V direction, respectively. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CoordnateSystemAtParameter node."
}, {
    "Name": "CoordinateSystemAtSegmentLength",
    "imageFile": ["CoordinateSystemAtSegmentLength"],
    "dynFile": ["CoordinateSystemAtSegmentLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Coordinate System At Segment Length will return a coordinate system aligned with the input curve at the specified curve length, measured from the start point of the curve. The resulting coordinate system will have its x-axis in the direction of the normal of the curve and the y-axis in the direction of the tangent of the curve at the specified length. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length input for a CoordinateSystemAtParameter node. If the specified length is longer than the length of the curve, this node will return a Coordinate System at the end point of the curve."
}, {
    "Name": "EndParameter",
    "imageFile": ["EndParameter"],
    "dynFile": ["EndParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "End Parameter will return a number that represents the end of the domain in which the input curve can be evaluated. In most cases the end parameter will be one. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an EndParameter node. "
}, {
    "Name": "Extend",
    "imageFile": ["Extend"],
    "dynFile": ["Extend"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extend will extend a input curve by a given input distance. The pickSide input takes the start or end point of the curve as input, and determines which end of the curve to extend. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the query node Curve.EndPoint to find the end point of the curve, to use as the 'pickSide' input. A number slider allows us to control the distance of the extension."
}, {
    "Name": "ExtendEnd",
    "imageFile": ["ExtendEnd"],
    "dynFile": ["ExtendEnd"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extend End will extend a input curve by a given input distance, starting from the end point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
}, {
    "Name": "ExtendStart",
    "imageFile": ["ExtendStart"],
    "dynFile": ["ExtendStart"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extend Start will extend a input curve by a given input distance, starting from the start point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
}, {
    "Name": "Extrude (direction, distance)",
    "imageFile": ["Extrude (direction, distance)"],
    "dynFile": ["Extrude (direction, distance)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the specified direction, by the specified distance."
}, {
    "Name": "Extrude (distance)",
    "imageFile": ["Extrude (distance)"],
    "dynFile": ["Extrude (distance)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the normal direction, by the specified distance"
}, {
    "Name": "Extrude (direction)",
    "imageFile": ["Extrude (direction)"],
    "dynFile": ["Extrude (direction)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the specified direction, by the length of the input Vector."
}, {
    "Name": "ExtrudeAsSolid (direction, distance)",
    "imageFile": ["ExtrudeAsSolid (direction, distance)"],
    "dynFile": ["ExtrudeAsSolid (direction, distance)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the specified direction, by the specified distance. Curve must be closed."
}, {
    "Name": "ExtrudeAsSolid (distance)",
    "imageFile": ["ExtrudeAsSolid (distance)"],
    "dynFile": ["ExtrudeAsSolid (distance)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the Normal direction by the specified distance. Curve must be closed."
}, {
    "Name": "ExtrudeAsSolid (direction)",
    "imageFile": ["ExtrudeAsSolid (direction)"],
    "dynFile": ["ExtrudeAsSolid (direction)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Extrudes a Curve in the specified direction, by the length of the input Vector. Curve must be closed."
}, {
    "Name": "HorizontalFrameAtParameter",
    "imageFile": ["HorizontalFrameAtParameter"],
    "dynFile": ["HorizontalFrameAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Horizontal Frame At Parameter will return a coordinate system aligned with the input curve at the specified parameter. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. The resulting coordinate system will have its z-axis in the world Z direction, and the y-axis in the direction of the tangent of the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a HorizontalFrameAtParameter node."
}, {
    "Name": "Join",
    "imageFile": ["Join"],
    "dynFile": ["Join"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Join this curve and the input curve into a new PolyCurve, maintaining the original curves exactly."
}, {
    "Name": "NormalAtParameter",
    "imageFile": ["NormalAtParameter"],
    "dynFile": ["NormalAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Normal At Parameter uses U and V input parameters and returns the Normal vector of the surface at the input UV position on the surface. In the example below, we first create a surface by using a Sweep2Rails. We then use two number sliders to determine the U and V parameters to determine the Normal with a NormalAtParameter node."
}, {
    "Name": "Offset",
    "imageFile": ["Offset"],
    "dynFile": ["Offset"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
}, {
    "Name": "ParameterAtChordLength",
    "imageFile": ["ParameterAtChordLength"],
    "dynFile": ["ParameterAtChordLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Parameter At Chord Length will return the parameter of a point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a parameter at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
}, {
    "Name": "ParameterAtPoint",
    "imageFile": ["ParameterAtPoint"],
    "dynFile": ["ParameterAtPoint"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Parameter at Point will return the parameter value of a specified point along a curve. If the input point is not on the curve, Parameter At Point will return the parameter of the point on the curve closes to the input point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. An extra single point is created with a Code Block to specify the x and y coordinates. The ParameterAtPoint node returns the parameter along the curve at the point that is closest to the input point."
}, {
    "Name": "ParameterAtSegmentLength",
    "imageFile": ["ParameterAtSegmentLength"],
    "dynFile": ["ParameterAtSegmentLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Parameter At Segment Length will return the parameter of a point that is a given length along the curve from the start point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length to find a parameter at. If the input segment length is longer than the curve, this node will return the parameter value of the end point of the curve."
}, {
    "Name": "Patch",
    "imageFile": ["Patch"],
    "dynFile": ["Patch"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Patch will attempt to create a surface using an input curve as the boundary. The input curve must be closed. In the example below, we first use a Point.ByCylindricalCoordinates node to create a set of points at set intervals in a circle, but with random elevations and radii. We then use a NurbsCurve.ByPoints node to create a closed curve based on these points. A Patch node is cused to create a surface from the boundary closed curve. Note that because the points were created with random radii and elevations, not all arrangements result in a curve that is able to be patched."
}, {
    "Name": "PlaneAtParameter",
    "imageFile": ["PlaneAtParameter"],
    "dynFile": ["PlaneAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Plane At Parameter will return a plane aligned with a curve at a specified parameter. The normal vector of the resulting plane will correspond to the tangent of the curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a PlaneAtParameter node."
}, {
    "Name": "PlaneAtSegmentLength",
    "imageFile": ["PlaneAtSegmentLength"],
    "dynFile": ["PlaneAtSegmentLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Plane At Segment Length will return a plane aligned with a curve at a point that is a specified distance along the curve, measured from the start point. If the input length is greater than the total length of the curve, this node will use the end point of the curve. The normal vector of the resulting plane will correspond to the tangent of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the parameter input for a PlaneAtSegmentLength node."
}, {
    "Name": "PointAtChordLength",
    "imageFile": ["PointAtChordLength"],
    "dynFile": ["PointAtChordLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Point At Chord Length will return the point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a point at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
}, {
    "Name": "PointAtParameter",
    "imageFile": ["PointAtParameter"],
    "dynFile": ["PointAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Point At Parameter will return the point on a surface specified by U and V parameters. In the example below, we first create a surface by using a BySweep2Rails node. We then use two number sliders to control the U and V values of the parameter for a PointAtParameter node."
}, {
    "Name": "PointAtSegmentLength",
    "imageFile": ["PointAtSegmentLength"],
    "dynFile": ["PointAtSegmentLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Point At Segment Length will return the point on a curve at a given length along the curve, measured from the start point of the curve. If the input length is greater than the length of the curve, the node will return the end point of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider is and used as the input length to a Point At Segment Length node. "
}, {
    "Name": "PointsAtChordLengthFromPoint",
    "imageFile": ["PointsAtChordLengthFromPoint"],
    "dynFile": ["PointsAtChordLengthFromPoint"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Points At Chord Length From Point will return a list of points along a curve, measured sequentially according to an input chord length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtChordLengthFromPoint node. Finally, a second number slider is used to adjust the straight-line chord length to use."
}, {
    "Name": "PointsAtEqualChordLength",
    "imageFile": ["PointsAtEqualChordLength"],
    "dynFile": ["PointsAtEqualChordLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Points At Equal Chord Length will return a list of points along an input curve by dividing the curve into equal straight-line chord lengths. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualChordLength node."
}, {
    "Name": "PointsAtEqualSegmentLength",
    "imageFile": ["PointsAtEqualSegmentLength"],
    "dynFile": ["PointsAtEqualSegmentLength"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Points At Equal Segment Length will return a list of points along an input curve by dividing the curve into equal length segments. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualSegmentLength node."
}, {
    "Name": "PointsAtSegmentLengthFromPoint",
    "imageFile": ["PointsAtSegmentLengthFromPoint"],
    "dynFile": ["PointsAtSegmentLengthFromPoint"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Points At Segment Length From Point will return a list of points along a curve, measured sequentially according to an input segment length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtSegmentLengthFromPoint node. Finally, a second number slider is used to adjust the curve segment length to use"
}, {
    "Name": "Project",
    "imageFile": ["Project"],
    "dynFile": ["Project"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Project will project a point along a given vector direction onto a specified geometry. The projection is only attempted in the positve direction of the vector. If the vector does not intersect the given geometry, it will return null. In the example below, we create a point using a code block to specify the x,y, and z coordinates. We use a sphere as the geometry to project onto, and the world XAxis as the projection Direction. The output is a point on the surface of the sphere that is projected from the original point."
}, {
    "Name": "PullOntoPlane",
    "imageFile": ["PullOntoPlane"],
    "dynFile": ["PullOntoPlane"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Pull Onto Plane will create a new curve by projecting an input curve onto an input plane, using the normal of the plane as the direction of projection. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the world XY plane as the plane to project onto in a PullOntoPlane node. The result is a planar curve on the XY plane."
}, {
    "Name": "PullOntoSurface",
    "imageFile": ["PullOntoSurface"],
    "dynFile": ["PullOntoSurface"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Pull Onto Surface will create a new curve by projecting an input curve onto an input surface, using the normal vectors of the surface as the directions of projection. In the example below, we first create surface by using a Surface.BySweep node that uses curves generated according to a sine curve. This surface is used as the base surface to pull onto in a PullOntoSurface node. For the curve, we create a circle by using a Code Block to specify the coordinates of the center point, and a number slider to control the radius of the circle. The result is a projection of the cirle onto the surface. "
}, {
    "Name": "Reverse",
    "imageFile": ["Reverse"],
    "dynFile": ["Reverse"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Reverse will return a new Vector pointing in the opposite direction from its input. In the example below, a Vector of (1,0,1) will return a Vector of (-1,0,-1). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different reversed vector. The Vectors are represented as Lines."
}, {
    "Name": "SegmentLengthAtParameter",
    "imageFile": ["SegmentLengthAtParameter"],
    "dynFile": ["SegmentLengthAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Segment Length At Parameter will return the length of a curve between the start point and the input parameter, where zero is the parameter at the beginning of the curve, and one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider set to the range zero to one is used for the parameter input in a SegmentLengthAtParameter node."
}, {
    "Name": "SegmentLengthBetweenParameters",
    "imageFile": ["SegmentLengthBetweenParameters"],
    "dynFile": ["SegmentLengthBetweenParameters"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Segment Length Between Parameters will return the length of a curve between the input start parameter and the input end parameter, where a value of zero is the parameter at the beginning of the curve and a value of one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a SegmentLengthBetweenParameters node."
}, {
    "Name": "Simplify",
    "imageFile": ["Simplify"],
    "dynFile": ["Simplify"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Returns a new Curve approximated with the supplied tolerance."
}, {
    "Name": "SplitByParameter",
    "imageFile": ["SplitByParameter"],
    "dynFile": ["SplitByParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Split the Curve into pieces given the supplide parameters."
}, {
    "Name": "SplitByPoints",
    "imageFile": ["SplitByPoints"],
    "dynFile": ["SplitByPoints"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Split By Points will split an input curve at specified points, and will return a list of resulting segments. If the specified points are not on the curve, this node will find the points along the curve that are closest to the input points and split the curve at those resulting points. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. The same set of points is used as the list of points in a SplitByPoints node. The result is a list of curve segments between the generated points."
}, {
    "Name": "StartParameter",
    "imageFile": ["StartParameter"],
    "dynFile": ["StartParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Start Parameter will return a number that represents the start of the domain in which the input curve can be evaluated. In most cases the start parameter will be zero. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an StartParameter node."
}, {
    "Name": "SweepAsSolid",
    "imageFile": ["SweepAsSolid"],
    "dynFile": ["SweepAsSolid"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Sweep As Solid will create a solid by sweeping an input closed profile curve along a specified path. In the example below, we use a rectangle as the base profile curve. The path is created by using a cosine function with a sequence of angles to vary the x-coordinates of a set of points. The points are used as the input to a NurbsCurve.ByPoints node. We then create a solid by sweeping the rectangle along the created cosine curve."
}, {
    "Name": "SweepAsSurface",
    "imageFile": ["SweepAsSurface"],
    "dynFile": ["SweepAsSurface"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "SweepAsSurface will create a surface by sweeping an input curve along a specfied path. In the example below, we create a curve to sweep by useing a Code Block to create three points of an Arc.ByThreePoints node. A path curve is created a simple line along the x-axis. SweepAsSurface moves the profile curve along the path curve creating a surface."
}, {
    "Name": "TangentAtParameter",
    "imageFile": ["TangentAtParameter"],
    "dynFile": ["TangentAtParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Tangent At Parameter will return a vector aligned with the tangent direction at the specified parameter of a curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TangentAtParameter node."
}, {
    "Name": "ToNurbsCurve",
    "imageFile": ["ToNurbsCurve"],
    "dynFile": ["ToNurbsCurve"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "To Nurbs Curve takes a curve as input, and returns a Nurbs curve that approximates the input curve. In the example below, we create an arc by using a Code Block to define three points and using an Arc.ByThreePoints node. This arc is converted to a Nurbs Curve by using a ToNurbsCurve node. Note that the default degree of the resulting Nurbs Curve is 3."
}, {
    "Name": "TrimByEndParameter",
    "imageFile": ["TrimByEndParameter"],
    "dynFile": ["TrimByEndParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Trim By End Parameter will remove the end of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByEndParameter node."
}, {
    "Name": "TrimByParameter",
    "imageFile": ["TrimByParameter"],
    "dynFile": ["TrimByParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Trim By Parameter will remove the start and end of an input curve by trimming the curve at the specified parameters, and will return the resulting middle section of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. Two number sliders set to the range 0 to 1 are used to control the start and end parameter inputs for a TrimByParameter node."
}, {
    "Name": "TrimByStartParameter",
    "imageFile": ["TrimByStartParameter"],
    "dynFile": ["TrimByStartParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Trim By Start Parameter will remove the beginning of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByStartParameter node."
}, {
    "Name": "TrimInteriorByParameter",
    "imageFile": ["TrimInteriorByParameter"],
    "dynFile": ["TrimInteriorByParameter"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Trim Interior By Parameter will remove the interior portion of a given curve, based on the two input parameters. This node will output the two remaining exterior parts of the curve as a list of two curves.  In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a TrimInteriorByParameter node."
}, {
    "Name": "TrimSegmentsByParameter (parameters)",
    "imageFile": ["TrimSegmentsByParameter (parameters)"],
    "dynFile": ["TrimSegmentsByParameter (parameters)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Removes several segments of the curve, discarding the 1st, 3rd, 5th ... segments."
}, {
    "Name": "TrimSegmentsByParameter (parameters, discardEvenSegments)",
    "imageFile": ["TrimSegmentsByParameter (parameters, discardEvenSegments)"],
    "dynFile": ["TrimSegmentsByParameter (parameters, discardEvenSegments)"],
    "folderPath": "Geometry/Curves/Curve/Action",
    "inDepth": "Removes several segments of the curve, discarding the even segments."
}, {
    "Name": "EndPoint",
    "imageFile": ["EndPoint"],
    "dynFile": ["EndPoint"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "End Point will return the end point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the end point of this curve by using an EndPoint node."
}, {
    "Name": "IsClosed",
    "imageFile": ["IsClosed"],
    "dynFile": ["IsClosed"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "Is Closed will return a boolean value that corresponds to whether the input curve is closed or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is closed by using a IsClosed node. "
}, {
    "Name": "IsPlanar",
    "imageFile": ["IsPlanar"],
    "dynFile": ["IsPlanar"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "Is Planar will return a boolean value that corresponds to whether the input curve is planar or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is planar by using a IsPlanar node."
}, {
    "Name": "Length",
    "imageFile": ["Length"],
    "dynFile": ["Length"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "Length returns the length of a curtain panel's boundary as a double. This can be used even if the curtain panel is not rectangular."
}, {
    "Name": "Normal",
    "imageFile": ["Normal"],
    "dynFile": ["Normal"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "Plane Normal will find the normal vector of an input plane. This is also equal to taking the cross product of the plane XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the normal vector of this plane."
}, {
    "Name": "StartPoint",
    "imageFile": ["StartPoint"],
    "dynFile": ["StartPoint"],
    "folderPath": "Geometry/Curves/Curve/Query",
    "inDepth": "Start Point will return the start point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the start point of this curve by using a StartPoint node."
}, {
    "Name": "ByCoordinateSystemRadii",
    "imageFile": ["ByCoordinateSystemRadii"],
    "dynFile": ["ByCoordinateSystemRadii"],
    "folderPath": "Geometry/Curves/Ellipse/Create",
    "inDepth": "Ellipse by Coordinate System Radii takes a coordinate system as an input, then creates an ellipse using the inputted radii. The input xAxisRadius and yAxisRadius correspond to the X and Y directions of the input Coordinate System (not the World X and Y directions). In the example file, we generate two random values to create a Coordinate System, then use that Coordinate System with two number sliders for the x and y radii."
}, {
    "Name": "ByOriginRadii",
    "imageFile": ["ByOriginRadii"],
    "dynFile": ["ByOriginRadii"],
    "folderPath": "Geometry/Curves/Ellipse/Create",
    "inDepth": "Ellipse by Origin Radii creates an ellipse centered on the input Origin point, and has an x and y radius from the input xAxisRadius and yAxisRadius. This ellipse will be aligned with the World XY plane. In the example below, we generate two random numbers to create an origin point, then use two number sliders for the x and y axis radii."
}, {
    "Name": "ByOriginVectors",
    "imageFile": ["ByOriginVectors"],
    "dynFile": ["ByOriginVectors"],
    "folderPath": "Geometry/Curves/Ellipse/Create",
    "inDepth": "Ellipse by Origin Vectors creates an ellipse centered on the input origin points. In this case, the XAxisRadius and YAxisRadius require vectors as inputs. The two vectors must be orthogonal (at right angles) to each other. The two vectors will determine the plane of the ellipse. They need not be in the world X and Y directions. In the example, we first create an origin point by generating two random numbers. We then use a unit X and unit Y vector, which are then scaled by number sliders."
}, {
    "Name": "ByPlaneRadii",
    "imageFile": ["ByPlaneRadii"],
    "dynFile": ["ByPlaneRadii"],
    "folderPath": "Geometry/Curves/Ellipse/Create",
    "inDepth": "Ellipse by Plane Radii creates an ellipse centered at the input plane. The xAxisRadius and yAxisRadius take numbers as inputs, and correspond to the X and Y diretions of the input plane, which may be different from world X and Y directions. In the example below, we use a YZ plane as the input, then use two number sliders for the xAxisRadius and yAxisRadius. Because we used a YZ plane, the input xAxisRadius will correspond to the world Y direction, while the yAxisRadius will correspond to the world Z direction."
}, {
    "Name": "ByPlaneRadiiAngles",
    "imageFile": ["ByPlaneRadiiAngles"],
    "dynFile": ["ByPlaneRadiiAngles"],
    "folderPath": "Geometry/Curves/EllipseArc/Create",
    "inDepth": "Ellipse Arc by Plane Radii Angles creates a portion of an ellipse. The input xRadius and yRadius give the radii of the ellipse along the X and Y directions of the input plane (which may be different than world X and Y). The startAngle input defines the beginning point of the arc along the ellipse in degrees, starting counter-clockwise from the plane X-axis, and continuing for a total arc length of the sweepAngle input. In the example below, we use the XY plane, and a series of number sliders to control the other input parameters."
}, {
    "Name": "CenterPoint",
    "imageFile": ["CenterPoint"],
    "dynFile": ["CenterPoint"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
}, {
    "Name": "MajorAxis",
    "imageFile": ["MajorAxis"],
    "dynFile": ["MajorAxis"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Major Axis to extract the major axis of the ellipse."
}, {
    "Name": "MinorAxis",
    "imageFile": ["MinorAxis"],
    "dynFile": ["MinorAxis"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse.  In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Minor Axis to extract the minor axis of the ellipse."
}, {
    "Name": "Plane",
    "imageFile": ["Plane"],
    "dynFile": ["Plane"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Sketch planes are used in the creation of 2D and 3D geometry in Revit."
}, {
    "Name": "StartAngle",
    "imageFile": ["StartAngle"],
    "dynFile": ["StartAngle"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Start Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise starting from the plane X-axis. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Start Angle to extract the angle of the beginning pont of the ellipse."
}, {
    "Name": "SweepAngle",
    "imageFile": ["SweepAngle"],
    "dynFile": ["SweepAngle"],
    "folderPath": "Geometry/Curves/EllipseArc/Query",
    "inDepth": "Sweep Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise on the ellipse plane, starting from the start angle. The end angle of the ellipse would be equal to the start angle plus the sweep angle. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Sweep Angle to extract arc length of the ellipse arc."
}, {
    "Name": "CenterPoint",
    "imageFile": ["CenterPoint"],
    "dynFile": ["CenterPoint"],
    "folderPath": "Geometry/Curves/Ellipse/Query",
    "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
}, {
    "Name": "MajorAxis",
    "imageFile": ["MajorAxis"],
    "dynFile": ["MajorAxis"],
    "folderPath": "Geometry/Curves/Ellipse/Query",
    "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Major Axis to extract the major axis of the ellipse."
}, {
    "Name": "MinorAxis",
    "imageFile": ["MinorAxis"],
    "dynFile": ["MinorAxis"],
    "folderPath": "Geometry/Curves/Ellipse/Query",
    "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse.  In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Minor Axis to extract the minor axis of the ellipse."
}, {
    "Name": "ByAxis",
    "imageFile": ["ByAxis"],
    "dynFile": ["ByAxis"],
    "folderPath": "Geometry/Curves/Helix/Create",
    "inDepth": "Helix By Axis creates a helix. The axis of the helix is defined by the input axis point and the axis direction. The helix will be created counter-clockwise around the axis, starting from the start point and continuing for an angular length of the Angle Turns input, in degrees. The Pitch input determines the distance of the helix per each 360 degrees in the direction of the axis. In the example below, we start the helix at the point (3,5) and use the Y-axis to define the helix axis. The start point of the helix is controlled by three number sliders. The pitch and angleTurns use two more number sliders. Note that the angleTurns is in degrees."
}, {
    "Name": "Angle",
    "imageFile": ["Angle"],
    "dynFile": ["Angle"],
    "folderPath": "Geometry/Curves/Helix/Query",
    "inDepth": "Angle will find the total angular length of a helix in degrees, where one complete turn is equal to 360. In the example below, we create a helix using Helix By Axis, then use Angle to find the total angle of the helix."
}, {
    "Name": "AxisDirection",
    "imageFile": ["AxisDirection"],
    "dynFile": ["AxisDirection"],
    "folderPath": "Geometry/Curves/Helix/Query",
    "inDepth": "Axis Direction will return the direction of the central axis of a helix as a vector. Together with the Axis Point, this defines the central axis. In the example below, we create a helix using Helix By Axis, then use Axis Direction to find the direction of the helix axis."
}, {
    "Name": "AxisPoint",
    "imageFile": ["AxisPoint"],
    "dynFile": ["AxisPoint"],
    "folderPath": "Geometry/Curves/Helix/Query",
    "inDepth": "Axis Point will return the base point of the helix axis. Together with the Axis Direction, this defines the central axis of a helix. In the example below, we create a helix using Helix By Axis, then use Axis Point to find the initial point of the helix axis."
}, {
    "Name": "Pitch",
    "imageFile": ["Pitch"],
    "dynFile": ["Pitch"],
    "folderPath": "Geometry/Curves/Helix/Query",
    "inDepth": "Pitch will return the linear distance along the axis direction that a helix spans in one complete turn (360 degrees). In the example below, we create a helix using Helix by Axis, then use Pitch to find the pitch of the helix."
}, {
    "Name": "Radius",
    "imageFile": ["Radius"],
    "dynFile": ["Radius"],
    "folderPath": "Geometry/Curves/Helix/Query",
    "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
}, {
    "Name": "ByBestFitThroughPoints",
    "imageFile": ["ByBestFitThroughPoints"],
    "dynFile": ["ByBestFitThroughPoints"],
    "folderPath": "Geometry/Curves/Line/Create",
    "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
}, {
    "Name": "ByStartPointDirectionLength",
    "imageFile": ["ByStartPointDirectionLength"],
    "dynFile": ["ByStartPointDirectionLength"],
    "folderPath": "Geometry/Curves/Line/Create",
    "inDepth": "Line by Start Point Direction Length creates a line beginning at the startPoint input, and with a length and direction according to the input direction vector and length. In the example below, we use a code block specify the x,y, and z coordinates of a point. We then use a number slider to control the length of the line."
}, {
    "Name": "ByStartPointEndPoint",
    "imageFile": ["ByStartPointEndPoint"],
    "dynFile": ["ByStartPointEndPoint"],
    "folderPath": "Geometry/Curves/Line/Create",
    "inDepth": "Reference planes can be created in both Revit projects and families. The reference plane in Revit does not dynamically change with its Dynamo inputs."
}, {
    "Name": "ByTangency",
    "imageFile": ["ByTangency"],
    "dynFile": ["ByTangency"],
    "folderPath": "Geometry/Curves/Line/Create",
    "inDepth": "Line By Tangency creates a line tangent to an input curve, and with a length of 1 unit. The parameter input specifies the position along the curve to evaluate, with a parameter of zero being the beginning of the curve, and a value of 1 being the end of the curve. In the example, we use a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw a Nurbs Curve. We then use a number slider between 0 and 1 as an input parameter to create a line tangent to the curve."
}, {
    "Name": "Direction",
    "imageFile": ["Direction"],
    "dynFile": ["Direction"],
    "folderPath": "Geometry/Curves/Line/Query",
    "inDepth": "Direction will return a vector that points in the same direction as a line. The magnitude of the vector is equal to the length of the original line. In the example below, we generate a set of random points, and then us ByBestFitThroughPoints to create a line. We use Direction to find the vector direction of the created line."
}, {
    "Name": "ByControlPoints (points, degree)",
    "imageFile": ["ByControlPoints (points, degree)"],
    "dynFile": ["ByControlPoints (points, degree)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
}, {
    "Name": "ByControlPoints (points, degree, closeCurve)",
    "imageFile": ["ByControlPoints (points, degree, closeCurve)"],
    "dynFile": ["ByControlPoints (points, degree, closeCurve)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. We also have the option to close the curve back to the first point in the list. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
}, {
    "Name": "ByControlPoints (points)",
    "imageFile": ["ByControlPoints (points)"],
    "dynFile": ["ByControlPoints (points)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Control Points inputs a list of points to use as control points and outputs a Nurbs Curve. This example uses a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw the Nurbs Curve."
}, {
    "Name": "ByControlPointsWeightsKnots",
    "imageFile": ["ByControlPointsWeightsKnots"],
    "dynFile": ["ByControlPointsWeightsKnots"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Add in-depth information about ByControlPointsWeightsKnots..."
}, {
    "Name": "ByPoints (points)",
    "imageFile": ["ByPoints (points)"],
    "dynFile": ["ByPoints (points)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
}, {
    "Name": "ByPoints (points, closeCurve)",
    "imageFile": ["ByPoints (points, closeCurve)"],
    "dynFile": ["ByPoints (points, closeCurve)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through and also allows us to close the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions, closing the curve back to the first point in the list."
}, {
    "Name": "ByPoints (points, degree)",
    "imageFile": ["ByPoints (points, degree)"],
    "dynFile": ["ByPoints (points, degree)"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through, and also allows us to change the degree of the curve. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
}, {
    "Name": "ByPointsTangents",
    "imageFile": ["ByPointsTangents"],
    "dynFile": ["ByPointsTangents"],
    "folderPath": "Geometry/Curves/NurbsCurve/Create",
    "inDepth": "Returns a BSplineCurve through the points, with tangent directions."
}, {
    "Name": "ControlPoints",
    "imageFile": ["ControlPoints"],
    "dynFile": ["ControlPoints"],
    "folderPath": "Geometry/Curves/NurbsCurve/Action",
    "inDepth": "ControlPoints will return the ControlPoints of a NurbsSurface as Points in a List of Lists. In the example below, the ControlPoints are returned from a NurbsSurface created from a Patch."
}, {
    "Name": "Knots",
    "imageFile": ["Knots"],
    "dynFile": ["Knots"],
    "folderPath": "Geometry/Curves/NurbsCurve/Action",
    "inDepth": "Knots will return the knots of a NURBS curve as a list of numbers. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Knots to then get a list of the knots for this curve."
}, {
    "Name": "Weights",
    "imageFile": ["Weights"],
    "dynFile": ["Weights"],
    "folderPath": "Geometry/Curves/NurbsCurve/Action",
    "inDepth": "Weights will return the Weights of a NurbsSurface as doubles in a List of Lists. In the example below, a NurbsSurface returns a list of Weights with a value of 1."
}, {
    "Name": "Degree",
    "imageFile": ["Degree"],
    "dynFile": ["Degree"],
    "folderPath": "Geometry/Curves/NurbsCurve/Query",
    "inDepth": "Degree will return the degree of a NURBS curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Degree to then get the degree of the curve. Since we created the curve without specifying the degree, it used a default degree of three. (A polygonal curve of straight lines has a degree of one, while the most common degree for non-straight-segmented curves is 3)"
}, {
    "Name": "IsPeriodic",
    "imageFile": ["IsPeriodic"],
    "dynFile": ["IsPeriodic"],
    "folderPath": "Geometry/Curves/NurbsCurve/Query",
    "inDepth": "IsPeriodic returns a boolean value of true if the curve is periodic, and false if the curve is not periodic. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use IsPeriodic to determine whether or not the curve is periodic."
}, {
    "Name": "IsRational",
    "imageFile": ["IsRational"],
    "dynFile": ["IsRational"],
    "folderPath": "Geometry/Curves/NurbsCurve/Query",
    "inDepth": "IsRational will return a boolean value based on whether a NurbsSurface is rational. In the example below, a NurbsSurface created by approximating a Surface returns a false value."
}, {
    "Name": "ByJoinedCurves",
    "imageFile": ["ByJoinedCurves"],
    "dynFile": ["ByJoinedCurves"],
    "folderPath": "Geometry/Curves/PolyCurve/Create",
    "inDepth": "Polycurve By Joined Curves creates joined curves from a set of curves with matching vertices. In this example, a RegularPolygon is exploded into a curve list and is then rejoined into a Polycurve."
}, {
    "Name": "ByPoints",
    "imageFile": ["ByPoints"],
    "dynFile": ["ByPoints"],
    "folderPath": "Geometry/Curves/PolyCurve/Create",
    "inDepth": "Revit will generate and contour a mesh from a list of supplied points. The points cannot be collinear."
}, {
    "Name": "ByThickeningCurve",
    "imageFile": ["ByThickeningCurve"],
    "dynFile": ["ByThickeningCurve"],
    "folderPath": "Geometry/Curves/PolyCurve/Create",
    "inDepth": "Polycurve By Thickening Curve is a node that constructs a closed, offset polygon from a single curve. In this node, we can specify the curve being thickened, the overall thickness, and the normal direction of the offset. This example shows how a randomly generated Nurbs Curve is offset perpendicular to its start and end point vector. "
}, {
    "Name": "BasePlane",
    "imageFile": ["BasePlane"],
    "dynFile": ["BasePlane"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Base Plane will return the plane of a planar polycurve. If the curve is not planar, it will give an error. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. Because we only used x and y coordinates, the generated polycurve is planar in the world XY plane. "
}, {
    "Name": "CloseWithLine",
    "imageFile": ["CloseWithLine"],
    "dynFile": ["CloseWithLine"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Close With Line adds a straght line between the start and end point of an open PolyCurve. It returns a new polycurve that includes the added line. In the example below, we generate a set of random points and use PolyCuve By Points with the connectLastToFirst input set to false to create an open PolyCurve. Inputting this PolyCurve into Close With Line creates a new closed polycurve (and in this case would be equivalent to using a 'true' input for the connectLastToFirst option in PolyCurve By Points)"
}, {
    "Name": "CloseWithLineAndTangentArcs",
    "imageFile": ["CloseWithLineAndTangentArcs"],
    "dynFile": ["CloseWithLineAndTangentArcs"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "CloseWithLineAndTangentArcs will return a line and tangent arcs to close an open PolyCurve. In the example below, a PolyCurve with two segments is closed with a line and arcs. The arcs are defined by whether they are at the start or end of the new line, and their radii can be controlled independently."
}, {
    "Name": "CurveAtIndex",
    "imageFile": ["CurveAtIndex"],
    "dynFile": ["CurveAtIndex"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Curve At Index will return the curve segment at the input index of a given polycurve. If the number of curves in the polycurve is less than the give index, CurveAtIndex will return null. The endOrStart input accepts a boolean value of true or false. If true, CurveAtIndex will begin counting at the first segment of the PolyCurve. If false, it will count backwards from the last segment. In the example below, we generate a set of random points, and then use PolyCurve By Points to create an open PolyCurve. We can then use CurveAtIndex to extract specfic segments from the PolyCurve."
}, {
    "Name": "Curves",
    "imageFile": ["Curves"],
    "dynFile": ["Curves"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "A revision cloud's curves are returned as geometry in Dynamo."
}, {
    "Name": "ExtendWithArc",
    "imageFile": ["ExtendWithArc"],
    "dynFile": ["ExtendWithArc"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Extend With Arc will add a circular arc to the beginning or end of an input PolyCurve, and returns a single combined PolyCurve. The radius input will determin the radius of the circle, while the length input determines the distance along the circle for the arc. The total length must be less than or equal to length of a complete circle with the given radius. The generated arc will be tangent to the end of the input PolyCurve. A boolean input for endOrStart controls which end of the PolyCurve the arc will be created. A value of 'true' will result in the arc created at the end of the PolyCurve, while 'false' will create the arc at the beginning of the PolyCurve. In the example below, we first use a set of random points and PolyCurve By Points to generate a PolyCurve. We then use two number sliders and a boolean toggle to set the parametrs for ExtendWithArc."
}, {
    "Name": "ExtendWithEllipse",
    "imageFile": ["ExtendWithEllipse"],
    "dynFile": ["ExtendWithEllipse"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "ExtendWithEllipse will return an extension of a PolyCurve as a portion of an ellipse. In the example below, a PolyCurve with a single segment is extended into an ellipse. The extension is controlled by two radii, it's length, its end parameter, and whether the start or end of the PolyCurve is being extended."
}, {
    "Name": "Fillet",
    "imageFile": ["Fillet"],
    "dynFile": ["Fillet"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Fillet will return a new solid with rounded edges. The edges input specifies which edges to fillet, while the offset input determines the radius of the fillet. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the radius for each fillet."
}, {
    "Name": "Offset",
    "imageFile": ["Offset"],
    "dynFile": ["Offset"],
    "folderPath": "Geometry/Curves/PolyCurve/Action",
    "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
}, {
    "Name": "NumberOfCurves",
    "imageFile": ["NumberOfCurves"],
    "dynFile": ["NumberOfCurves"],
    "folderPath": "Geometry/Curves/PolyCurve/Query",
    "inDepth": "Number Of Curves returns the number of curve segments that make up a given PolyCurve. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. If connectLastToFirst is left as 'false', then the number of curves will be one less than the number of points. Otherwise, if we create a closed PolyCurve, the number of curves will be equal to the number of initial points."
}, {
    "Name": "ByPoints",
    "imageFile": ["ByPoints"],
    "dynFile": ["ByPoints"],
    "folderPath": "Geometry/Curves/Polygon/Create",
    "inDepth": "Revit will generate and contour a mesh from a list of supplied points. The points cannot be collinear."
}, {
    "Name": "RegularPolygon",
    "imageFile": ["RegularPolygon"],
    "dynFile": ["RegularPolygon"],
    "folderPath": "Geometry/Curves/Polygon/Create",
    "inDepth": "Polygon Regular Polygon is a simple component that will inscribe a regular polygon of any number of sides into a circle. In this example, we create the reference circle from a random Best Fit Through Points and draw a six-sided polygon inside the circle."
}, {
    "Name": "Center",
    "imageFile": ["Center"],
    "dynFile": ["Center"],
    "folderPath": "Geometry/Curves/Polygon/Action",
    "inDepth": "Polygon Center finds the center of a given polygon by taking the average value of the corners. For concave polygons, it's possible that the center may actually lie outside the polygon. In the example below, we first generate a list of random angles and radii to use as inputs to Point By Cylindrical Coordinates. By sorting the angles first, we ensure that the resulting polygon will be connected in order of increasing angle, and therefore will not be self-intersecting. We can then use Center to take the average of the points and find the polygon center."
}, {
    "Name": "ContainmentTest",
    "imageFile": ["ContainmentTest"],
    "dynFile": ["ContainmentTest"],
    "folderPath": "Geometry/Curves/Polygon/Action",
    "inDepth": "Containment Test returns a boolean value depending on whether a given point is contained inside a given polygon. The polygon must be planar and non-self-intersecting in order for this to work. In the example below, we create a polygon using a series of points created By Cylindrical Coordinates. Leaving the elevation constant, and sorting the angles ensures a planar and non-self-intersecting polygon. We then create a point to test, and use ContainmentTest to see if the point is inside or outside the polygon."
}, {
    "Name": "Corners",
    "imageFile": ["Corners"],
    "dynFile": ["Corners"],
    "folderPath": "Geometry/Curves/Polygon/Action",
    "inDepth": "Corners will return a list of points that are the corners of the given polygon. In the example below, we first generate a set of random points sorted by angle to use with Polygon By Points. We can get the points back out as a list by using Corners."
}, {
    "Name": "SelfIntersections",
    "imageFile": ["SelfIntersections"],
    "dynFile": ["SelfIntersections"],
    "folderPath": "Geometry/Curves/Polygon/Action",
    "inDepth": "Self Intersections will return a list of all points where a polygon intersects itself. In the example below, we first generate a list of random unsorted angles and radii to use with Points By Cylindrical Coordinates. Because we kept the elevation constant, and did not sort the angles of these points, a polygon created with Polygon By Points will be planar and is likely to be self-intersecting. We can then find the intersection points using Self Intersections"
}, {
    "Name": "PlaneDeviation",
    "imageFile": ["PlaneDeviation"],
    "dynFile": ["PlaneDeviation"],
    "folderPath": "Geometry/Curves/Polygon/Query",
    "inDepth": "Plane Deviation will first calculate the best fit plane through the points of a given polygon. It then computes the distance of each point to that plane to find the maximum deviation of the points from the best fit plane. In the example below, we generate a list of random angles, elevations, and radii, and then use Points By Cylindrical Coordinates to create a set of non-planar points to use for Polygon By Points. Inputting this polygon into PlaneDeviation, we can find the average deviation of the points from a best-fit-plane."
}, {
    "Name": "Points",
    "imageFile": ["Points"],
    "dynFile": ["Points"],
    "folderPath": "Geometry/Curves/Polygon/Query",
    "inDepth": "The points of an underlying mesh are useful for querying elevation or location data. Point sets can be manipulated in Dynamo and fed back into Dynamo as a new topography."
}, {
    "Name": "ByCornerPoints (points)",
    "imageFile": ["ByCornerPoints (points)"],
    "dynFile": ["ByCornerPoints (points)"],
    "folderPath": "Geometry/Curves/Rectangle/Create",
    "inDepth": "The Rectangle By Corner Points node takes a list of four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses four separate inputs for eacher point rather than as a single list. Both nodes are shown in this example."
}, {
    "Name": "ByCornerPoints (p1, p2, p3, p4)",
    "imageFile": ["ByCornerPoints (p1, p2, p3, p4)"],
    "dynFile": ["ByCornerPoints (p1, p2, p3, p4)"],
    "folderPath": "Geometry/Curves/Rectangle/Create",
    "inDepth": "The Rectangle By Corner Points node takes four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses a list of points as the input rather than each input separately. Both nodes are shown in this example."
}, {
    "Name": "ByWidthLength (plane, width, length)",
    "imageFile": ["ByWidthLength (plane, width, length)"],
    "dynFile": ["ByWidthLength (plane, width, length)"],
    "folderPath": "Geometry/Curves/Rectangle/Create",
    "inDepth": "Create a Rectangle centered at the origin of the input plane, with specified width (X Axis length), and length (Y Axis length). In the example, we use the world YZ plane as the input plane. The width specifies the plane X Axis length, which in this case corresponds to the world Y axis, and the length specifies the plane Y Axis length which is this case corresponds to the world Z Axis."
}, {
    "Name": "ByWidthLength (width, length)",
    "imageFile": ["ByWidthLength (width, length)"],
    "dynFile": ["ByWidthLength (width, length)"],
    "folderPath": "Geometry/Curves/Rectangle/Create",
    "inDepth": "The Rectangle By Width Length node creates a rectangle on the Z-base plane with a specified length and width dimension. The center of the rectangle will be located at the grid origin. In this example, we use two Number Sliders to drive the shape of the rectangle. "
}, {
    "Name": "ByWidthLength (cs, width, length)",
    "imageFile": ["ByWidthLength (cs, width, length)"],
    "dynFile": ["ByWidthLength (cs, width, length)"],
    "folderPath": "Geometry/Curves/Rectangle/Create",
    "inDepth": "Create a Rectangle centered at the input origin in the CoordinateSystem XY Plane, with specified width (X Axis length), and length (Y Axis length)."
}, {
    "Name": "Height",
    "imageFile": ["Height"],
    "dynFile": ["Height"],
    "folderPath": "Geometry/Curves/Rectangle/Query",
    "inDepth": "Text note height is returned as a double. The height value is relative to the view scale."
}, {
    "Name": "Width",
    "imageFile": ["Width"],
    "dynFile": ["Width"],
    "folderPath": "Geometry/Curves/Rectangle/Query",
    "inDepth": "Width returns the horizontal dimension of a rectangular curtain panel as a double."
}, {
    "Name": "ByIndices (a, b, c)",
    "imageFile": ["ByIndices (a, b, c)"],
    "dynFile": ["ByIndices (a, b, c)"],
    "folderPath": "Geometry/Meshes/IndexGroup/Create",
    "inDepth": "ByIndices (a, b, c) (a, b, c) will return an IndexGroup of three Indices. In the example below, three indices are defined for a three-sided Mesh created with Mesh.ByPointsFacesIndices."
}, {
    "Name": "ByIndices (a, b, c, d)",
    "imageFile": ["ByIndices (a, b, c, d)"],
    "dynFile": ["ByIndices (a, b, c, d)"],
    "folderPath": "Geometry/Meshes/IndexGroup/Create",
    "inDepth": "ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d) will return an IndexGroup of four Indices. In the example below, four indices are defined for a four-sided Mesh created with Mesh.ByPointsFacesIndices."
}, {
    "Name": "A",
    "imageFile": ["A"],
    "dynFile": ["A"],
    "folderPath": "Geometry/Meshes/IndexGroup/Query",
    "inDepth": "A will return the value of Index A. In the example below, the Index value of A is returned as 0 in a three-sided Mesh."
}, {
    "Name": "B",
    "imageFile": ["B"],
    "dynFile": ["B"],
    "folderPath": "Geometry/Meshes/IndexGroup/Query",
    "inDepth": "B will return the value of Index B. In the example below, the Index value of B is returned as 1 in a three-sided Mesh."
}, {
    "Name": "C",
    "imageFile": ["C"],
    "dynFile": ["C"],
    "folderPath": "Geometry/Meshes/IndexGroup/Query",
    "inDepth": "C will return the value of Index C. In the example below, the Index value of C is returned as 2 in a three-sided Mesh."
}, {
    "Name": "Count",
    "imageFile": ["Count"],
    "dynFile": ["Count"],
    "folderPath": "Geometry/Meshes/IndexGroup/Query",
    "inDepth": "Count will return an integer that represents the number of Indices in an IndexGroup. In the example below, Index counts are returned for Mesh faces with three and four edges."
}, {
    "Name": "D",
    "imageFile": ["D"],
    "dynFile": ["D"],
    "folderPath": "Geometry/Meshes/IndexGroup/Query",
    "inDepth": "D will return the value of Index D. In the example below, the Index value of D is returned as 3 in a four-sided Mesh."
}, {
    "Name": "ByPointsFaceIndices",
    "imageFile": ["ByPointsFaceIndices"],
    "dynFile": ["ByPointsFaceIndices"],
    "folderPath": "Geometry/Meshes/Mesh/Create",
    "inDepth": "ByPointsFaceIndices will return a Mesh based on input vertices as Points and input indices. In the example below, a four-sided Mesh is created with four Points and an IndexGroup of four indices."
}, {
    "Name": "FaceIndices",
    "imageFile": ["FaceIndices"],
    "dynFile": ["FaceIndices"],
    "folderPath": "Geometry/Meshes/Mesh/Query",
    "inDepth": "FaceIndices will return the IndexGroup of a mesh face in counterclockwise order. In the example below, the an Indexgroup is returned for a four-sided mesh face."
}, {
    "Name": "VertexNormals",
    "imageFile": ["VertexNormals"],
    "dynFile": ["VertexNormals"],
    "folderPath": "Geometry/Meshes/Mesh/Query",
    "inDepth": "VertexNormals will return Vectors that represent the normal of each Vertex. In the example below, the normal of each Vertex is returned as a line to represent its direction."
}, {
    "Name": "VertexPositions",
    "imageFile": ["VertexPositions"],
    "dynFile": ["VertexPositions"],
    "folderPath": "Geometry/Meshes/Mesh/Query",
    "inDepth": "VertexPositions will return a Mesh face's Vertex positions as Points. In the example below, the Vertex positions of a four-sided Mesh face are returned as Points."
}, {
    "Name": "ClosestPointTo",
    "imageFile": ["ClosestPointTo"],
    "dynFile": ["ClosestPointTo"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry ClosestPointTo finds the closest point from one geometry to another, adding a 3D Point to the document. This example finds the closest point on one Sphere to another."
}, {
    "Name": "DeserializeFromSAB",
    "imageFile": ["DeserializeFromSAB"],
    "dynFile": ["DeserializeFromSAB"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "DeserializeFromSAB will return geometry from SAB format data. In the example below, SAB data is read from a file and deserialized into a skewed cylinder."
}, {
    "Name": "DistanceTo",
    "imageFile": ["DistanceTo"],
    "dynFile": ["DistanceTo"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry DistanceTo returns the distance between two geometries. This example finds the distance between two Spheres."
}, {
    "Name": "DoesIntersect",
    "imageFile": ["DoesIntersect"],
    "dynFile": ["DoesIntersect"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry DoesIntersect tests two geometries for an intersection. If the objects intersect, the Node will return True. This example tests for an intersection of two Sphere geometries."
}, {
    "Name": "Explode",
    "imageFile": ["Explode"],
    "dynFile": ["Explode"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "The Geometry Explode Node breaks a geometry down into smaller components. For example, a Polysurface can be Exploded into several Surfaces and a Polycurve into curves. In this example, we are extracting a single Surface from a complex Intersection of three Spheres."
}, {
    "Name": "ExportToSAT",
    "imageFile": ["ExportToSAT"],
    "dynFile": ["ExportToSAT"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "ExportToSAT will export the specified geomety to the given SAT file path."
}, {
    "Name": "ExportToSAT (geometry, filePath)",
    "imageFile": ["ExportToSAT (geometry, filePath)"],
    "dynFile": ["ExportToSAT (geometry, filePath)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry ExportToSAT exports Geometry from Dynamo to a SAT file type. In this example, we are exporting a Polysurface from the Intersection of three Spheres."
}, {
    "Name": "FromSolidDef",
    "imageFile": ["FromSolidDef"],
    "dynFile": ["FromSolidDef"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Imports a JSON string and returns an array of imported geometries."
}, {
    "Name": "ImportFromSAT (file)",
    "imageFile": ["ImportFromSAT (file)"],
    "dynFile": ["ImportFromSAT (file)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a file as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
}, {
    "Name": "ImportFromSAT (filePath)",
    "imageFile": ["ImportFromSAT (filePath)"],
    "dynFile": ["ImportFromSAT (filePath)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a filePath as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
}, {
    "Name": "Intersect",
    "imageFile": ["Intersect"],
    "dynFile": ["Intersect"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry Intersect finds the Intersection Geometry that two Geometry objects share. In this example, the Intersection of two Spheres returns a Polysurface, otherwise known as a Solid Intersection."
}, {
    "Name": "IntersectAll",
    "imageFile": ["IntersectAll"],
    "dynFile": ["IntersectAll"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry IntersectAll finds the Intersection Geometry that any number of Geometry objects share. In this example, the Intersection of three Spheres returns a Polysurface, otherwise known as a Solid Intersection."
}, {
    "Name": "IsAlmostEqualTo",
    "imageFile": ["IsAlmostEqualTo"],
    "dynFile": ["IsAlmostEqualTo"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "IsAlmostEqualTo will return a boolean value based on whether a Vector has the same values as another. In the example below, a true value is returned when comparing a Vector on the WCS Z axis to a Vector with coordinates of (0,0,1). Adjusting the Vector Direction slider will change the Vector's coordinate values making it unequal. The Vectors are represented as Lines."
}, {
    "Name": "Mirror",
    "imageFile": ["Mirror"],
    "dynFile": ["Mirror"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry Mirror reflects a Geometry across a defined Plane. In this example, we are Mirroring a Cone across the Y-Axis."
}, {
    "Name": "Rotate (basePlane, degrees)",
    "imageFile": ["Rotate (basePlane, degrees)"],
    "dynFile": ["Rotate (basePlane, degrees)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Rotates an object around the Plane origin and normal by a specified degree."
}, {
    "Name": "Rotate (origin, axis, degrees)",
    "imageFile": ["Rotate (origin, axis, degrees)"],
    "dynFile": ["Rotate (origin, axis, degrees)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Rotates an object around an origin and an axis by a specified degree."
}, {
    "Name": "Scale (plane, xamount, yamount, zamount)",
    "imageFile": ["Scale (plane, xamount, yamount, zamount)"],
    "dynFile": ["Scale (plane, xamount, yamount, zamount)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Scale non-uniformly around a given Plane."
}, {
    "Name": "Scale (xamount, yamount, zamount)",
    "imageFile": ["Scale (xamount, yamount, zamount)"],
    "dynFile": ["Scale (xamount, yamount, zamount)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Scale non-uniformly around the origin."
}, {
    "Name": "Scale (amount)",
    "imageFile": ["Scale (amount)"],
    "dynFile": ["Scale (amount)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Scale uniformly around the origin."
}, {
    "Name": "Scale (basePoint, from, to)",
    "imageFile": ["Scale (basePoint, from, to)"],
    "dynFile": ["Scale (basePoint, from, to)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Scale uniformly around a given point, using two pick points as scalars."
}, {
    "Name": "Scale1D",
    "imageFile": ["Scale1D"],
    "dynFile": ["Scale1D"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry Scale1D Scales a Geometry in one direction from a Base Point and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the Cone Start Point. The original Cone Edges are drawn as a visual reference."
}, {
    "Name": "Scale2D",
    "imageFile": ["Scale2D"],
    "dynFile": ["Scale2D"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry Scale2D Scales a Geometry in two directions from a Base Plane and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the YZ-Plane."
}, {
    "Name": "SerializeAsSAB",
    "imageFile": ["SerializeAsSAB"],
    "dynFile": ["SerializeAsSAB"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Serializes the specified geometry into Standard ACIS Binary(SAB) format and returns serialized binary stream data."
}, {
    "Name": "Split",
    "imageFile": ["Split"],
    "dynFile": ["Split"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "The Geometry Split Node functions similarly to the Geometry Trim Node. It inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, and returns all of the fragments of Geometry. In this example, a Cone is Split with a similar Cone. Although all fragments are returned by the Geometry Split Node, one is previewed in the example file."
}, {
    "Name": "ToSolidDef",
    "imageFile": ["ToSolidDef"],
    "dynFile": ["ToSolidDef"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Convert geometry to Solid Def json."
}, {
    "Name": "Transform (cs)",
    "imageFile": ["Transform (cs)"],
    "dynFile": ["Transform (cs)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Transforms geometry by the given CoordinateSystem's transform."
}, {
    "Name": "Transform (fromCoordinateSystem, contextCoordinateSystem)",
    "imageFile": ["Transform (fromCoordinateSystem, contextCoordinateSystem)"],
    "dynFile": ["Transform (fromCoordinateSystem, contextCoordinateSystem)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Transforms this geometry from source CoordinateSystem to a new context CoordinateSystem."
}, {
    "Name": "Translate (direction, distance)",
    "imageFile": ["Translate (direction, distance)"],
    "dynFile": ["Translate (direction, distance)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Translates any geometry type by the given distance in the given direction."
}, {
    "Name": "Translate (direction)",
    "imageFile": ["Translate (direction)"],
    "dynFile": ["Translate (direction)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Translate geometry in the given direction by the vector length."
}, {
    "Name": "Translate (xTranslation, yTranslation, zTranslation)",
    "imageFile": ["Translate (xTranslation, yTranslation, zTranslation)"],
    "dynFile": ["Translate (xTranslation, yTranslation, zTranslation)"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Translates any given geometry by the given displacements in the x, y, and z directions defined in WCS respectively."
}, {
    "Name": "Trim",
    "imageFile": ["Trim"],
    "dynFile": ["Trim"],
    "folderPath": "Geometry/Modifiers/Geometry/Action",
    "inDepth": "Geometry Trim functions similarly to the Geometry Split Node in that it inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, but returns only a single fragment of the Geometry. The Geometry that is Picked is selected by a reference Point closest to the fragment. In this example, one Cone is Trimmed by another, with its lower portion Picked."
}, {
    "Name": "BoundingBox",
    "imageFile": ["BoundingBox"],
    "dynFile": ["BoundingBox"],
    "folderPath": "Geometry/Modifiers/Geometry/Query",
    "inDepth": "BoundingBox will create a bounding box in Dynamo around a Revit element."
}, {
    "Name": "ContextCoordinateSystem",
    "imageFile": ["ContextCoordinateSystem"],
    "dynFile": ["ContextCoordinateSystem"],
    "folderPath": "Geometry/Modifiers/Geometry/Query",
    "inDepth": "ContextCoordinateSystem will return the CoordinateSystem that was used in creating a piece of geometry. In the example below, a Solid created at centerPoint (3,0,0) returns a CoordinateSystem located at the origin."
}, {
    "Name": "ByGeometryColor",
    "imageFile": ["ByGeometryColor"],
    "dynFile": ["ByGeometryColor"],
    "folderPath": "Geometry/Modifiers/Geometry Color/Create",
    "inDepth": "ByGeometryColor will display a piece of geometry with an input color. In the example below, a circle is displayed with an RGB color of 227, 136, 200 and an Alpha value of 200. Unless it is turned off, the preview of the original geometry will cover up the new colored one."
}, {
    "Name": "BySurfaceColors",
    "imageFile": ["BySurfaceColors"],
    "dynFile": ["BySurfaceColors"],
    "folderPath": "Geometry/Modifiers/Geometry Color/Create",
    "inDepth": "BySurfaceColors will display the input geometry with a gradient of colors. In the example below, a circle is displayed with a gradient of two RGB colors. Unless it is turned off, the preview of the original geometry will cover up the new colored one."
}, {
    "Name": "ByCartesianCoordinates",
    "imageFile": ["ByCartesianCoordinates"],
    "dynFile": ["ByCartesianCoordinates"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "Point By Cartesian Coordinates gives us the ability to set the X, Y and Z values of a point’s location. In this example, we are setting multiple Code Block Ranges controlled by sliders to drive the three-dimensional array of points."
}, {
    "Name": "ByCoordinates (x, y, z)",
    "imageFile": ["ByCoordinates (x, y, z)"],
    "dynFile": ["ByCoordinates (x, y, z)"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "ByCoordinates (x, y, z) will return a Vector from X, Y, and Z coordinates. The input coordinate location defines the Vector's position and length. In the example below, a Vector is returned from a coordinate location of (1,0,1) and is represented as a Line."
}, {
    "Name": "ByCoordinates (x, y)",
    "imageFile": ["ByCoordinates (x, y)", "ByCoordinates_crossReference"],
    "dynFile": ["ByCoordinates (x, y)", "ByCoordinates_crossReference"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "The Point By Coordinates (XY) calls for two number inputs and generates a point on the Dynamo base plane.  In the first example,  we are using two sliders to dynamically control the point’s X and Y location on the Z-plane. In the second, we are using two Number Sliders and a Code Block Range to determine the maximum extents of the grid and the spacing between points. By changing the Points By Coordinates lacing to Cross-Reference, we can create multi-dimensional set of points along the X and Y axis."
}, {
    "Name": "ByCylindricalCoordinates",
    "imageFile": ["ByCylindricalCoordinates"],
    "dynFile": ["ByCylindricalCoordinates"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "The Point By Cylindrical Coordinates node creates a point located within a cylindrical space. Here, we set the lacing to Cross-Reference and use a range of angles and elevations to generate a grid of points along a cylinder with a dynamic radius."
}, {
    "Name": "BySphericalCoordinates",
    "imageFile": ["BySphericalCoordinates"],
    "dynFile": ["BySphericalCoordinates"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "The Point By Spherical Coordinates node creates a point located within a spherical space. Here, we set the lacing to Cross-Reference and use a range of phi and theta angles to generate a grid of points along a cylinder with a dynamic radius. The location of the sphere is set to a Coordinate System with the origin (1, 5, 1)."
}, {
    "Name": "Origin",
    "imageFile": ["Origin"],
    "dynFile": ["Origin"],
    "folderPath": "Geometry/Points/Point/Create",
    "inDepth": "Origin will return a Point at the Origin of the WorldCoordinateSystem. In the example below, a Circle by centerpoint and radius is created using a Point at the WCS Origin."
}, {
    "Name": "Add",
    "imageFile": ["Add"],
    "dynFile": ["Add"],
    "folderPath": "Geometry/Points/Point/Action",
    "inDepth": "Add will return a Vector that is the sum of two other Vectors. In the example below, the sum of the WCS Z axis and X axis Vectors results in a Vector with coordinates of (1,0,1). The new Vector is represented as a Line."
}, {
    "Name": "AsVector",
    "imageFile": ["AsVector"],
    "dynFile": ["AsVector"],
    "folderPath": "Geometry/Points/Point/Action",
    "inDepth": "Point as Vector takes an input point and returns a vector with x,y, and z components equal to the cartesian coordinates of the point. This can also be thought of as creating a vector by two points, where the first point is the world origin and the second point is the input point. In the example below, we use PointBySphericalCoordinates to generate a point, then use AsVector to get a vector which we can control using spherical coordinates."
}, {
    "Name": "Project",
    "imageFile": ["Project"],
    "dynFile": ["Project"],
    "folderPath": "Geometry/Points/Point/Action",
    "inDepth": "Project will project a point along a given vector direction onto a specified geometry. The projection is only attempted in the positve direction of the vector. If the vector does not intersect the given geometry, it will return null. In the example below, we create a point using a code block to specify the x,y, and z coordinates. We use a sphere as the geometry to project onto, and the world XAxis as the projection Direction. The output is a point on the surface of the sphere that is projected from the original point."
}, {
    "Name": "PruneDuplicates",
    "imageFile": ["PruneDuplicates"],
    "dynFile": ["PruneDuplicates"],
    "folderPath": "Geometry/Points/Point/Action",
    "inDepth": "Prune Duplicates takes a list of points as an input, and will return a list with duplicate points removed. The tolerance input is used to determine how close two points need to be to be considered duplicates. If two points are closer than the tolerance, the first one in the list will be kept, and the other point removed. In the example, we generate a set of random points. We then use Prune Duplicates with a tolerance of one to remove any points that are closer than one unit to another point."
}, {
    "Name": "Subtract",
    "imageFile": ["Subtract"],
    "dynFile": ["Subtract"],
    "folderPath": "Geometry/Points/Point/Action",
    "inDepth": "Subtract will return a Vector that is the difference of two other Vectors. In the example below, the difference of the a Vector with coordinates (1,0,1) and WCS Z axis results in a Vector with coordinates of (1,0,0). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different subtracted vector. The Vectors are represented as Lines."
}, {
    "Name": "X",
    "imageFile": ["X"],
    "dynFile": ["X"],
    "folderPath": "Geometry/Points/Point/Query",
    "inDepth": "X returns a double representing a reference point's X coordinate value in the Revit conceptual design environment."
}, {
    "Name": "Y",
    "imageFile": ["Y"],
    "dynFile": ["Y"],
    "folderPath": "Geometry/Points/Point/Query",
    "inDepth": "Y returns a double representing a reference point's Y coordinate value in the Revit conceptual design environment."
}, {
    "Name": "Z",
    "imageFile": ["Z"],
    "dynFile": ["Z"],
    "folderPath": "Geometry/Points/Point/Query",
    "inDepth": "Z returns a double representing a reference point's Z coordinate value in the Revit conceptual design environment."
}, {
    "Name": "ByCoordinates",
    "imageFile": ["ByCoordinates"],
    "dynFile": ["ByCoordinates"],
    "folderPath": "Geometry/Points/UV/Create",
    "inDepth": "Reference points are created in the Revit conceptual design environment."
}, {
    "Name": "U",
    "imageFile": ["U"],
    "dynFile": ["U"],
    "folderPath": "Geometry/Points/UV/Query",
    "inDepth": "U will return the U value of a UV coordinate. In the example below, the U value of a Point location on the NurbsSurface is returned. The UV parameter is returned from the Surface.UVParamterAtPoint node."
}, {
    "Name": "V",
    "imageFile": ["V"],
    "dynFile": ["V"],
    "folderPath": "Geometry/Points/UV/Query",
    "inDepth": "V will return the V value of a UV coordinate. In the example below, the V value of a Point location on the NurbsSurface is returned. The UV parameter is returned from the Surface.UVParamterAtPoint node."
}, {
    "Name": "ByCoordinateSystemHeightRadii",
    "imageFile": ["ByCoordinateSystemHeightRadii"],
    "dynFile": ["ByCoordinateSystemHeightRadii"],
    "folderPath": "Geometry/Solids/Cone/Create",
    "inDepth": "Cone ByCoordinateSystemHeightRadii creates a truncated Cone geometry from two Radii, the starting Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders."
}, {
    "Name": "ByCoordinateSystemHeightRadius",
    "imageFile": ["ByCoordinateSystemHeightRadius"],
    "dynFile": ["ByCoordinateSystemHeightRadius"],
    "folderPath": "Geometry/Solids/Cone/Create",
    "inDepth": "Cone ByCoordinateSystemHeightRadius creates a Cone geometry from a Radius, the Cone Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with two Number Sliders."
}, {
    "Name": "ByPointsRadii",
    "imageFile": ["ByPointsRadii"],
    "dynFile": ["ByPointsRadii"],
    "folderPath": "Geometry/Solids/Cone/Create",
    "inDepth": "Cone ByPointsRadii creates a truncated Cone geometry from a Start Point, End Point, and two Radius values. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders controlling its Height and Radius sizes."
}, {
    "Name": "ByPointsRadius",
    "imageFile": ["ByPointsRadius"],
    "dynFile": ["ByPointsRadius"],
    "folderPath": "Geometry/Solids/Cone/Create",
    "inDepth": "ByPointsRadius will return a Cylinder from a start Point, end Point, and radius value. In the example below, adjusting the number sliders will change the point positions as well as the Cylinder's radius."
}, {
    "Name": "EndPoint",
    "imageFile": ["EndPoint"],
    "dynFile": ["EndPoint"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "End Point will return the end point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the end point of this curve by using an EndPoint node."
}, {
    "Name": "EndRadius",
    "imageFile": ["EndRadius"],
    "dynFile": ["EndRadius"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "End Radius will find the radius of the top circle of a truncated cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the End Radius back from the cone."
}, {
    "Name": "Height",
    "imageFile": ["Height"],
    "dynFile": ["Height"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "Text note height is returned as a double. The height value is relative to the view scale."
}, {
    "Name": "RadiusRatio",
    "imageFile": ["RadiusRatio"],
    "dynFile": ["RadiusRatio"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "Radius Ratio will find the ratio between the top and bottom radii of the cone. This is equivalent to taking the top radius and dividing it by the bottom radius. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Radius Ratio from the cone."
}, {
    "Name": "StartPoint",
    "imageFile": ["StartPoint"],
    "dynFile": ["StartPoint"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "Start Point will return the start point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the start point of this curve by using a StartPoint node."
}, {
    "Name": "StartRadius",
    "imageFile": ["StartRadius"],
    "dynFile": ["StartRadius"],
    "folderPath": "Geometry/Solids/Cone/Query",
    "inDepth": "Start Radius will find the radius of the base circle of a cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Start Radius back from the cone."
}, {
    "Name": "ByCorners",
    "imageFile": ["ByCorners"],
    "dynFile": ["ByCorners"],
    "folderPath": "Geometry/Solids/Cuboid/Create",
    "inDepth": "Cuboid By Corners creates a cuboid where the two input points are used as the opposite corners of the cuboid. In the example file, two points are randomly generated and used to create a cuboid."
}, {
    "Name": "ByLengths (origin, width, length, height)",
    "imageFile": ["ByLengths (origin, width, length, height)"],
    "dynFile": ["ByLengths (origin, width, length, height)"],
    "folderPath": "Geometry/Solids/Cuboid/Create",
    "inDepth": "This Cuboid By Lengths allows the user to input an origin point for the center of the cuboid, as well as the length, width and height of the cuboid. In the example file, we use three number sliders to input the length, width, and height, and generate a random point to use as the origin."
}, {
    "Name": "ByLengths (width, length, height)",
    "imageFile": ["ByLengths (width, length, height)"],
    "dynFile": ["ByLengths (width, length, height)"],
    "folderPath": "Geometry/Solids/Cuboid/Create",
    "inDepth": "Cuboid By Lengths creates a cuboid with the input width, legth, and height, and is centered at the origin. In the example, we use three number sliders to input the length, width and height."
}, {
    "Name": "ByLengths (cs, width, length, height)",
    "imageFile": ["ByLengths (cs, width, length, height)"],
    "dynFile": ["ByLengths (cs, width, length, height)"],
    "folderPath": "Geometry/Solids/Cuboid/Create",
    "inDepth": "This Cuboid By Lengths allows the user to input a Coordinate System. The cuboid will be created at the origin of the input Coordinate System, with the length, width, and heigh oriented according to the Coordinate System. In the example, we use three number sliders to input the length, width, and heigh, and generate random coordinates to use to create a Coordinate System."
}, {
    "Name": "Height",
    "imageFile": ["Height"],
    "dynFile": ["Height"],
    "folderPath": "Geometry/Solids/Cuboid/Query",
    "inDepth": "Text note height is returned as a double. The height value is relative to the view scale."
}, {
    "Name": "Length",
    "imageFile": ["Length"],
    "dynFile": ["Length"],
    "folderPath": "Geometry/Solids/Cuboid/Query",
    "inDepth": "Length returns the length of a curtain panel's boundary as a double. This can be used even if the curtain panel is not rectangular."
}, {
    "Name": "Width",
    "imageFile": ["Width"],
    "dynFile": ["Width"],
    "folderPath": "Geometry/Solids/Cuboid/Query",
    "inDepth": "Width returns the horizontal dimension of a rectangular curtain panel as a double."
}, {
    "Name": "ByPointsRadius",
    "imageFile": ["ByPointsRadius"],
    "dynFile": ["ByPointsRadius"],
    "folderPath": "Geometry/Solids/Cylinder/Create",
    "inDepth": "ByPointsRadius will return a Cylinder from a start Point, end Point, and radius value. In the example below, adjusting the number sliders will change the point positions as well as the Cylinder's radius."
}, {
    "Name": "ByRadiusHeight",
    "imageFile": ["ByRadiusHeight"],
    "dynFile": ["ByRadiusHeight"],
    "folderPath": "Geometry/Solids/Cylinder/Create",
    "inDepth": "ByRadiusHeight will return a Cylinder based on a CoordinateSystem. In the example below, a CoordinateSystem from an origin point and a YAxis vector is used to create Cylinder that appears rotated."
}, {
    "Name": "Axis",
    "imageFile": ["Axis"],
    "dynFile": ["Axis"],
    "folderPath": "Geometry/Solids/Cylinder/Query",
    "inDepth": "The Axis of the given cylinder."
}, {
    "Name": "Height",
    "imageFile": ["Height"],
    "dynFile": ["Height"],
    "folderPath": "Geometry/Solids/Cylinder/Query",
    "inDepth": "Text note height is returned as a double. The height value is relative to the view scale."
}, {
    "Name": "Radius",
    "imageFile": ["Radius"],
    "dynFile": ["Radius"],
    "folderPath": "Geometry/Solids/Cylinder/Query",
    "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
}, {
    "Name": "ByJoinedSurfaces",
    "imageFile": ["ByJoinedSurfaces"],
    "dynFile": ["ByJoinedSurfaces"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Solid by Joined Surfaces takes a list of surfaces as an input and will return a single solid defined by the surfaces. The surfaces must define a closed surface. In the example below, we start with a circle as a base geometry. The circle is patched to create a surface, and that surface is translated in the z-direction. We then extrude the circle to produce the sides. List.Create is used to make a list consisting of the base, side, and top surfaces, and then we use ByJoinedSurfaces to turn the list into a single closed solid."
}, {
    "Name": "ByLoft (crossSections)",
    "imageFile": ["ByLoft (crossSections)"],
    "dynFile": ["ByLoft (crossSections)"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Surface ByLoft with cross sections takes a list of curves as an input. It will produce a surface by lofting between the list of curves in order. In the example below we create two curves, a line and a sine curve. We use List.Create to combine these two curves into a list, which we use as an input for Surface ByLoft. The result is a surface that is lofted between a sine curve on one side, and a line on the other."
}, {
    "Name": "ByLoft (crossSections, guideCurves)",
    "imageFile": ["ByLoft (crossSections, guideCurves)"],
    "dynFile": ["ByLoft (crossSections, guideCurves)"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Surface by Loft with cross sections and guide curves takes a list of cross sections to loft between, and a separate list of guide curves to determine the profile of the loft. In the example below, we use two straight lines as the input cross sections. For the guide curves, we create one sine curve and one straight line. A number slider controls the distance between the sine curve and the straight line. The resulting loft interpolates between the sine curve and the straight line."
}, {
    "Name": "ByRevolve",
    "imageFile": ["ByRevolve"],
    "dynFile": ["ByRevolve"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Surface by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example"
}, {
    "Name": "BySweep",
    "imageFile": ["BySweep"],
    "dynFile": ["BySweep"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Surface by Sweep will create a surface by sweeping an input curve along a specfied path. In the example below, we use a sine curve in the y-direction as the profile curve. We rotate this curve by -90 degrees around the world z-axis to use as a path curve. Surface BySweep moves the profile curve along the path curve creating a surface."
}, {
    "Name": "BySweep2Rails",
    "imageFile": ["BySweep2Rails"],
    "dynFile": ["BySweep2Rails"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Surface by Sweep 2 Rails takes an input curve and uses two guide curves to sweep the profile curve along. In the example below, we use a half-circle as the input profile. We create two diverging lines to use as the rail curves for a BySweep2Rails node. The result is a surface with a half-circle profile that grows as the arc moves along the diverging lines."
}, {
    "Name": "ByUnion",
    "imageFile": ["ByUnion"],
    "dynFile": ["ByUnion"],
    "folderPath": "Geometry/Solids/Solid/Create",
    "inDepth": "Solid by Union will create a single new solid out of the union of a list of closed solids. The union is the combination of both solids, and the new solid will include all of the volume of the original solids. In the example below, we use a set of number sliders to control the position and radius of a sphere. We also use a default cuboid. We use a List.Create node to put both the cube and the sphere into a single list, which we use as the input for Solid ByUnion node."
}, {
    "Name": "Centroid",
    "imageFile": ["Centroid"],
    "dynFile": ["Centroid"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Centroid will return a point that is at the centroid of a solid. The centroid can be thought of as the center of mass of an solid object. Note that it is possible for the center of mass to exist outside the actual solid. In the example below, we use a set of circles to create a Solid ByLoft, and input the resulting solid into a Centroid node."
}, {
    "Name": "Chamfer",
    "imageFile": ["Chamfer"],
    "dynFile": ["Chamfer"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Chamfer will return a new solid with chamfered edges. The edges input specifies which edges to chamfer, while the offset input determines the extent of the chamfer. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the offset distance for the chamfer."
}, {
    "Name": "Difference",
    "imageFile": ["Difference"],
    "dynFile": ["Difference"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Difference will create a new solid by subtracting one solid from another. The 'solid' input indicates the solid to subtract from, while the 'tool' input is the solid that will be subtracted. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere subtracted from it."
}, {
    "Name": "DifferenceAll",
    "imageFile": ["DifferenceAll"],
    "dynFile": ["DifferenceAll"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Difference All will create a new solid by subtracting a list of solids from one single solid. The 'solid' input indicates the solid to subtract from, while the 'tools' input is the list of solids that will be subtracted. The solids in this list will be unioned together to create a single solid, which is then subtracted from the 'solid' input. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere. By using a sequence of numbers as the z-coordinate, we create a list of several spheres. If the spheres are intersecting the cube, then the result is a cube with the intersecting parts of the spheres subtracted from it."
}, {
    "Name": "Fillet",
    "imageFile": ["Fillet"],
    "dynFile": ["Fillet"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Fillet will return a new solid with rounded edges. The edges input specifies which edges to fillet, while the offset input determines the radius of the fillet. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the radius for each fillet."
}, {
    "Name": "ProjectInputOnto",
    "imageFile": ["ProjectInputOnto"],
    "dynFile": ["ProjectInputOnto"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Project Input Onto will project an input geometry onto a given surface along a given direction. In the example below, we first create a surface by using a BySweep2Rails. This is the surface we will project onto. We make a circle at the origin to use as the geometry to project, and simply use the world Z-direction as the direction vector for projection. The result is a circle projected onto the surface."
}, {
    "Name": "ThinShell",
    "imageFile": ["ThinShell"],
    "dynFile": ["ThinShell"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Thin Shell will create a new solid by offsetting the surfaces that make up the input solid. This can also be thought of as thickening the surfaces of the input solid. In the example below, we use a chamfered cube as our input solid. We have two number sliders to control the inner and outer thicknesses of the shell faces."
}, {
    "Name": "Union",
    "imageFile": ["Union"],
    "dynFile": ["Union"],
    "folderPath": "Geometry/Solids/Solid/Action",
    "inDepth": "Union will create a new solid by adding one solid to another. The 'solid' input indicates the solid to add to, while the 'tool' input is the solid that will be added. In the example below, we start with a default cube as the solid we are going to add to. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere added to it."
}, {
    "Name": "Area",
    "imageFile": ["Area"],
    "dynFile": ["Area"],
    "folderPath": "Geometry/Solids/Solid/Query",
    "inDepth": "Room area is returned as a double."
}, {
    "Name": "Volume",
    "imageFile": ["Volume"],
    "dynFile": ["Volume"],
    "folderPath": "Geometry/Solids/Solid/Query",
    "inDepth": "Volume will return the volume of a given solid. In the example below, we start with a cube, and then chamfer the edges to produce a new solid. We can use Volume to find the new volume of this solid."
}, {
    "Name": "ByBestFit",
    "imageFile": ["ByBestFit"],
    "dynFile": ["ByBestFit"],
    "folderPath": "Geometry/Solids/Sphere/Create",
    "inDepth": "Sphere by Best Fit will create a sphere based on a list of points as input. The sphere will be created to minimize the average distance from the list of points to the surface of the sphere. In the example below, we generate a set of random numbers to use as x,y, and z coordinates for a list of points. The number of points is controlled by an integer slider. The list of points is used as the input for a Sphere ByBestFit node."
}, {
    "Name": "ByCenterPointRadius",
    "imageFile": ["ByCenterPointRadius"],
    "dynFile": ["ByCenterPointRadius"],
    "folderPath": "Geometry/Solids/Sphere/Create",
    "inDepth": "Sphere by Center Point Radius will create a sphere centered at the input point, and with an input radius. In the example below, we use a code block to specify the coordinates of a Point created by coordinates, and we use a number slider to determine the radius of the sphere."
}, {
    "Name": "ByFourPoints",
    "imageFile": ["ByFourPoints"],
    "dynFile": ["ByFourPoints"],
    "folderPath": "Geometry/Solids/Sphere/Create",
    "inDepth": "ByFourPoints will return a Sphere from four input Points on the Surface. In the example below, two Spheres are created from a collection of six Points. Adjusting the X Position and Y Position sliders will change the size of each Sphere relative to the other. It is important to note that not any collection of four points will make a Sphere. It has to be possible for all Points to be on the Sphere's surface."
}, {
    "Name": "CenterPoint",
    "imageFile": ["CenterPoint"],
    "dynFile": ["CenterPoint"],
    "folderPath": "Geometry/Solids/Sphere/Query",
    "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
}, {
    "Name": "Radius",
    "imageFile": ["Radius"],
    "dynFile": ["Radius"],
    "folderPath": "Geometry/Solids/Sphere/Query",
    "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
}, {
    "Name": "ByControlPoints",
    "imageFile": ["ByControlPoints"],
    "dynFile": ["ByControlPoints"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Create",
    "inDepth": "Nurbs Surface By Control Points takes in a two dimensional array of control vertices and outputs a Nurbs Surface. This node also gives us the ability to calibrate the degree in the U and V directions. In this example, a 10 by 10 grid of points is created with a Code Block Range. The grid is then scaled in the Z-direction at random, modulating the output surface from the By Control Points node. "
}, {
    "Name": "ByControlPointsWeightsKnots",
    "imageFile": ["ByControlPointsWeightsKnots"],
    "dynFile": ["ByControlPointsWeightsKnots"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Create",
    "inDepth": "Creates a NurbsSurface with specified control vertices, knots, weights, and U V degrees. There are several restrictions on the data which, if broken, will cause the function to fail and will throw an exception. Degree: Both u- and v- degree should be >= 1 (piecewise-linear spline) and less than 26 (the maximum B-spline basis degree supported by ASM). Weights: All weight values (if supplied) should be strictly positive. Weights smaller than 1e-11 will be rejected and the function will fail. Knots: Both knot vectors should be non-decreasing sequences. Interior knot multiplicity should be no larger than degree + 1 at the start/end knot and degree at an internal knot (this allows surfaces with G1 discontinuities to be represented). Note that non-clamped knot vectors are supported, but will be converted to clamped ones, with the corresponding changes applied to the control point/weight data."
}, {
    "Name": "ByPoints",
    "imageFile": ["ByPoints"],
    "dynFile": ["ByPoints"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Create",
    "inDepth": "Revit will generate and contour a mesh from a list of supplied points. The points cannot be collinear."
}, {
    "Name": "ByPointsTangents",
    "imageFile": ["ByPointsTangents"],
    "dynFile": ["ByPointsTangents"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Create",
    "inDepth": "Creates a NurbsSurface with specified interpolated points and U and V degrees. The resultant surface will pass through all of the points. The number of tangents must match the number of points in the corresponding direction. The resultant surface will be degree 3 in both the U and V direction."
}, {
    "Name": "ByPointsTangentsKnotsDerivatives",
    "imageFile": ["ByPointsTangentsKnotsDerivatives"],
    "dynFile": ["ByPointsTangentsKnotsDerivatives"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Create",
    "inDepth": "Creates a NurbsSurface satisfying a collection of different surface characteristics. This is the most advanced surface fitting method. The resultant surface will pass through all of the points. The number of tangents must match the number of points in the corresponding direction. The resultant surface will be degree 3 in both the U and V direction. The corner derivatives should be second order (dP/dUdV) and should be supplied in this order [ lowU, lowV ], [ highU, lowV ], [ lowU, highV ], [ highU, highV ]."
}, {
    "Name": "ControlPoints",
    "imageFile": ["ControlPoints"],
    "dynFile": ["ControlPoints"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Action",
    "inDepth": "ControlPoints will return the ControlPoints of a NurbsSurface as Points in a List of Lists. In the example below, the ControlPoints are returned from a NurbsSurface created from a Patch."
}, {
    "Name": "UKnots",
    "imageFile": ["UKnots"],
    "dynFile": ["UKnots"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Action",
    "inDepth": "UKnots will return the Surface Knots in the U direction of a NurbsSurface. In the example below, the UKnots of the NurbsSurface are returned as a list of doubles."
}, {
    "Name": "VKnots",
    "imageFile": ["VKnots"],
    "dynFile": ["VKnots"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Action",
    "inDepth": "VKnots will return the Surface Knots in the V direction of a NurbsSurface. In the example below, the VKnots of the NurbsSurface are returned as a list of doubles."
}, {
    "Name": "Weights",
    "imageFile": ["Weights"],
    "dynFile": ["Weights"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Action",
    "inDepth": "Weights will return the Weights of a NurbsSurface as doubles in a List of Lists. In the example below, a NurbsSurface returns a list of Weights with a value of 1."
}, {
    "Name": "DegreeU",
    "imageFile": ["DegreeU"],
    "dynFile": ["DegreeU"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "DegreeU will return the degree of a NurbsSurface in the U direction. In the example below, a NurbsSurface created with Points and specified U/V degrees has a degree of 2 in the U direction. Adjusting the number sliders will change the U and V degree values."
}, {
    "Name": "DegreeV",
    "imageFile": ["DegreeV"],
    "dynFile": ["DegreeV"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "DegreeV will return the degree of a NurbsSurface in the V direction. In the example below, a NurbsSurface created with Points and specified U/V degrees has a degree of 2 in the V direction. Adjusting the number sliders will change the U and V degree values."
}, {
    "Name": "IsPeriodicInU",
    "imageFile": ["IsPeriodicInU"],
    "dynFile": ["IsPeriodicInU"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "Returns true if the Surface is periodic in the U direction."
}, {
    "Name": "IsPeriodicInV",
    "imageFile": ["IsPeriodicInV"],
    "dynFile": ["IsPeriodicInV"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "Returns true if the Surface is periodic in the V direction."
}, {
    "Name": "IsRational",
    "imageFile": ["IsRational"],
    "dynFile": ["IsRational"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "IsRational will return a boolean value based on whether a NurbsSurface is rational. In the example below, a NurbsSurface created by approximating a Surface returns a false value."
}, {
    "Name": "NumControlPointsU",
    "imageFile": ["NumControlPointsU"],
    "dynFile": ["NumControlPointsU"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "NumControlPointsU will count the control points in the U direction of a NurbsSurface and return an integer. In the example below, the NurbsSurface returns an integer of 22 for its U control points. The control points are returned as Points using NurbsSurface.ControlPoints."
}, {
    "Name": "NumControlPointsV",
    "imageFile": ["NumControlPointsV"],
    "dynFile": ["NumControlPointsV"],
    "folderPath": "Geometry/Surfaces/NurbsSurface/Query",
    "inDepth": "NumControlPointsV will count the control points in the V direction of a NurbsSurface and return an integer. In the example below, the NurbsSurface returns an integer of 12 for its V control points. The control points are returned as Points using NurbsSurface.ControlPoints."
}, {
    "Name": "ByJoinedSurfaces",
    "imageFile": ["ByJoinedSurfaces"],
    "dynFile": ["ByJoinedSurfaces"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "Solid by Joined Surfaces takes a list of surfaces as an input and will return a single solid defined by the surfaces. The surfaces must define a closed surface. In the example below, we start with a circle as a base geometry. The circle is patched to create a surface, and that surface is translated in the z-direction. We then extrude the circle to produce the sides. List.Create is used to make a list consisting of the base, side, and top surfaces, and then we use ByJoinedSurfaces to turn the list into a single closed solid."
}, {
    "Name": "ByLoft (crossSections, guideCurve)",
    "imageFile": ["ByLoft (crossSections, guideCurve)"],
    "dynFile": ["ByLoft (crossSections, guideCurve)"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "ByLoft (crossSections, guideCurve) will return a new PolySurface by lofting between curves in a list and guide Curve. In the example below, a new PolySurface is returned by lofting between two Circles. The returned PolySurface is distorted by adjusting the arc of the guideCurve input."
}, {
    "Name": "ByLoft (crossSections)",
    "imageFile": ["ByLoft (crossSections)"],
    "dynFile": ["ByLoft (crossSections)"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "Surface ByLoft with cross sections takes a list of curves as an input. It will produce a surface by lofting between the list of curves in order. In the example below we create two curves, a line and a sine curve. We use List.Create to combine these two curves into a list, which we use as an input for Surface ByLoft. The result is a surface that is lofted between a sine curve on one side, and a line on the other."
}, {
    "Name": "ByLoftGuides",
    "imageFile": ["ByLoftGuides"],
    "dynFile": ["ByLoftGuides"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "ByLoftGuides will return a PolySurface by lofting through a list of PolyCurves (crossSections). In the example below, a PolySurface is created by lofting through three arcs and an arc guideCurve. The arcs give the loft its cross section, and the guideCurve gives the loft a rail to follow."
}, {
    "Name": "BySolid",
    "imageFile": ["BySolid"],
    "dynFile": ["BySolid"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "BySolid will return a PolySurface from a Solid. In the example below, a Solid is returned as a PolySurface for it to be an acceptable input to Display.BySurfaceColors."
}, {
    "Name": "BySweep",
    "imageFile": ["BySweep"],
    "dynFile": ["BySweep"],
    "folderPath": "Geometry/Surfaces/PolySurface/Create",
    "inDepth": "Surface by Sweep will create a surface by sweeping an input curve along a specfied path. In the example below, we use a sine curve in the y-direction as the profile curve. We rotate this curve by -90 degrees around the world z-axis to use as a path curve. Surface BySweep moves the profile curve along the path curve creating a surface."
}, {
    "Name": "Chamfer",
    "imageFile": ["Chamfer"],
    "dynFile": ["Chamfer"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "Chamfer will return a new solid with chamfered edges. The edges input specifies which edges to chamfer, while the offset input determines the extent of the chamfer. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the offset distance for the chamfer."
}, {
    "Name": "EdgeCount",
    "imageFile": ["EdgeCount"],
    "dynFile": ["EdgeCount"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "EdgeCount will return the number of Edges on a PolySurface. In the example below, an extruded hexagon has an Edge count of 18. The edges are represented as Lines."
}, {
    "Name": "ExtractSolids",
    "imageFile": ["ExtractSolids"],
    "dynFile": ["ExtractSolids"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "ExtractSolids will return a Solid from a collection of PolySurfaces. In the example below, a Solid is returned from a collection of three surfaces that form a cylinder. Since the node takes a single PolySurface as an input, the three surfaces must be joined together before returning a Solid."
}, {
    "Name": "Fillet",
    "imageFile": ["Fillet"],
    "dynFile": ["Fillet"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "Fillet will return a new solid with rounded edges. The edges input specifies which edges to fillet, while the offset input determines the radius of the fillet. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the radius for each fillet."
}, {
    "Name": "LocateSurfacesByLine",
    "imageFile": ["LocateSurfacesByLine"],
    "dynFile": ["LocateSurfacesByLine"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "LocateSurfacesByLine will return all Surface(s) that a Line intersects. In the example below, a line is found to pass through an extruded hexagon at two places and returns two Surfaces. "
}, {
    "Name": "LocateSurfacesByPoint",
    "imageFile": ["LocateSurfacesByPoint"],
    "dynFile": ["LocateSurfacesByPoint"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "LocateSurfacesByPoint will return the first Surface intersected in the forward direction as defined by a Vector. In the example below, the Surface returned is intersected by a Vector originating at the Point. The Vector is represented as a Line."
}, {
    "Name": "SurfaceCount",
    "imageFile": ["SurfaceCount"],
    "dynFile": ["SurfaceCount"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "SurfaceCount will return the number of Surfaces in a PolySurface as an integer. In the example below, an extruded hexagon returns a count of 8. The node takes a single PolySurface as an input, so a collection of Surfaces will need to be joined before counting."
}, {
    "Name": "Surfaces",
    "imageFile": ["Surfaces"],
    "dynFile": ["Surfaces"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "Surfaces will return the Surfaces that make up a PolySurface. In the example below, a extruded hexagon will return eight individual Surfaces."
}, {
    "Name": "UnconnectedBoundaries",
    "imageFile": ["UnconnectedBoundaries"],
    "dynFile": ["UnconnectedBoundaries"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "UnconnectedBoundaries will return PolyCurves that represent open boundaries. In the example below, an extruded hexagon returns it's top and bottom boundaries as PolyCurves since they are unconnected."
}, {
    "Name": "VertexCount",
    "imageFile": ["VertexCount"],
    "dynFile": ["VertexCount"],
    "folderPath": "Geometry/Surfaces/PolySurface/Action",
    "inDepth": "VertexCount will return the number of Vertices of a PolySurface as an integer. In the example below, an extruded hexagon returns a Vertice count of 12. The Vertices are represented as Points."
}, {
    "Name": "ByLoft (crossSections)",
    "imageFile": ["ByLoft (crossSections)"],
    "dynFile": ["ByLoft (crossSections)"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface ByLoft with cross sections takes a list of curves as an input. It will produce a surface by lofting between the list of curves in order. In the example below we create two curves, a line and a sine curve. We use List.Create to combine these two curves into a list, which we use as an input for Surface ByLoft. The result is a surface that is lofted between a sine curve on one side, and a line on the other."
}, {
    "Name": "ByLoft (crossSections, guideCurves)",
    "imageFile": ["ByLoft (crossSections, guideCurves)"],
    "dynFile": ["ByLoft (crossSections, guideCurves)"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Loft with cross sections and guide curves takes a list of cross sections to loft between, and a separate list of guide curves to determine the profile of the loft. In the example below, we use two straight lines as the input cross sections. For the guide curves, we create one sine curve and one straight line. A number slider controls the distance between the sine curve and the straight line. The resulting loft interpolates between the sine curve and the straight line."
}, {
    "Name": "ByPatch",
    "imageFile": ["ByPatch"],
    "dynFile": ["ByPatch"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Patch will create a surface by filling in the interior of a closed curve. In the example below, we first create a closed Nurbs Curve by using a series of points created with cylindrical coordines. A number slider controls the number of points to create, while a boolean toggle node controls whether the Nurbs Curve is closed on not. We use the Nurbs Curve as the input to a Surface ByPatch node, creating a surface on the inside of the closed curve."
}, {
    "Name": "ByPerimeterPoints",
    "imageFile": ["ByPerimeterPoints"],
    "dynFile": ["ByPerimeterPoints"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Perimeter Points takes a list of points that defines the perimeter of a closed polygon, and creates a surface inside the resulting polygon. In the example below we create a series of points using cylindrical coordinates. The points are created at regular intervals around a cylinder with randomized inputs for the radius and elevation. The resulting list of points is used as the input for a Surface ByPerimeterPoints node."
}, {
    "Name": "ByRevolve",
    "imageFile": ["ByRevolve"],
    "dynFile": ["ByRevolve"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example"
}, {
    "Name": "ByRuledLoft",
    "imageFile": ["ByRuledLoft"],
    "dynFile": ["ByRuledLoft"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Ruled Loft takes an ordered list of curves as an input and lofts a straigth-line ruled surface between the curves. Compared to ByLoft, ByRuledLoft can be slightly faster, but the resulting surface is less smooth. In the example below, we start with a line along the X-axis. We translate this line into a series of lines that follow a sine curve in the y-direction. Using this resulting list of lines as the input for a Surface ByRuledLoft results in a surface with straight-line segments between the input curves."
}, {
    "Name": "BySweep",
    "imageFile": ["BySweep"],
    "dynFile": ["BySweep"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Sweep will create a surface by sweeping an input curve along a specfied path. In the example below, we use a sine curve in the y-direction as the profile curve. We rotate this curve by -90 degrees around the world z-axis to use as a path curve. Surface BySweep moves the profile curve along the path curve creating a surface."
}, {
    "Name": "BySweep2Rails",
    "imageFile": ["BySweep2Rails"],
    "dynFile": ["BySweep2Rails"],
    "folderPath": "Geometry/Surfaces/Surface/Create",
    "inDepth": "Surface by Sweep 2 Rails takes an input curve and uses two guide curves to sweep the profile curve along. In the example below, we use a half-circle as the input profile. We create two diverging lines to use as the rail curves for a BySweep2Rails node. The result is a surface with a half-circle profile that grows as the arc moves along the diverging lines."
}, {
    "Name": "ApproximateWithTolerance",
    "imageFile": ["ApproximateWithTolerance"],
    "dynFile": ["ApproximateWithTolerance"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Approximate with Tolerance will create a Nurbs Surface that approximates an input surface. The tolerance input determines how accurately the result will match the original surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ApproximateWithTolerance node, the result is an untrimmed Nurbs Surface with four sides."
}, {
    "Name": "CoordinateSystemAtParameter",
    "imageFile": ["CoordinateSystemAtParameter"],
    "dynFile": ["CoordinateSystemAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Coordinate System at Parameter uses U and V input parameters and returns a coordinate system. The x-axis, y-axis, and z-axis of the Coordinate System are determined by the Normal direction, U direction, and V direction, respectively. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CoordnateSystemAtParameter node."
}, {
    "Name": "CurvatureAtParameter",
    "imageFile": ["CurvatureAtParameter"],
    "dynFile": ["CurvatureAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Curvature At Parameter uses U and V input parameters and returns a coordinate system based on the normal, U direction, and V direction at the UV position on the surface. The Normal vector determines the z-axis, while the U and V directions determine the direction of the X and Y axes. The length of the axes are determined by the U and V curvature. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CurvatureAtParameter node."
}, {
    "Name": "DerivativesAtParameter",
    "imageFile": ["DerivativesAtParameter"],
    "dynFile": ["DerivativesAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Derivatives At Parameter uses U and V input parameters and returns the U and V derivaties of the surface at the input UV position on the surface. The derivatives are returned as a list of two vectors, with the first vector being the U derivative and the second vector being the V derivative. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to determine the derivatives with a DerivativesAtParameter node. "
}, {
    "Name": "FlipNormalDirection",
    "imageFile": ["FlipNormalDirection"],
    "dynFile": ["FlipNormalDirection"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Flip Normal Direction will flip the direction of the normal vectors of a surface. In the example below, we first create a surface by using a BySweep2Rails. The Normal direction of this surface points up in the positive z-direction. By usinging a FlipNormalDirection node, we create a new surface with the same geometry, but with the normals pointing down in the negative z-direction."
}, {
    "Name": "GaussianCurvatureAtParameter",
    "imageFile": ["GaussianCurvatureAtParameter"],
    "dynFile": ["GaussianCurvatureAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Gaussian Curvature At Parameter uses U and V input parameters and returns the curvature of the surface at the input UV position of the surface. The Gaussian Curvature is calculated as the product of the two principal curvatures (in the U and V directions). In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the gaussian curvature with a GaussianCurvatureAtParameter node."
}, {
    "Name": "GetIsoline",
    "imageFile": ["GetIsoline"],
    "dynFile": ["GetIsoline"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Get Isoline will return the isoline of a surface at an input U or V parameter. The input isoDirection is used to determine whether the U direction or V direction is used. An isoDirection of 0 corresponds to the U direction, while an isoDirection of 1 corresponds to the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders. The first slider controls the U or V direction of the isolines, while the second determines the parameter to find the isoline of."
}, {
    "Name": "Join",
    "imageFile": ["Join"],
    "dynFile": ["Join"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Combines this Surface and input Surface into a PolySurface."
}, {
    "Name": "NormalAtParameter",
    "imageFile": ["NormalAtParameter"],
    "dynFile": ["NormalAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Normal At Parameter uses U and V input parameters and returns the Normal vector of the surface at the input UV position on the surface. In the example below, we first create a surface by using a Sweep2Rails. We then use two number sliders to determine the U and V parameters to determine the Normal with a NormalAtParameter node."
}, {
    "Name": "NormalAtPoint",
    "imageFile": ["NormalAtPoint"],
    "dynFile": ["NormalAtPoint"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Normal At Point finds the Normal vector of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the normal at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the normal at."
}, {
    "Name": "Offset",
    "imageFile": ["Offset"],
    "dynFile": ["Offset"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
}, {
    "Name": "PerimeterCurves",
    "imageFile": ["PerimeterCurves"],
    "dynFile": ["PerimeterCurves"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Perimeter Curves will return the edge curves of an open surface as a list of curves. In the example below, we first create a surface by using a BySweep2Rails node. We then extract the perimeter edges by using a PerimeterCurves node. "
}, {
    "Name": "PointAtParameter",
    "imageFile": ["PointAtParameter"],
    "dynFile": ["PointAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Point At Parameter will return the point on a surface specified by U and V parameters. In the example below, we first create a surface by using a BySweep2Rails node. We then use two number sliders to control the U and V values of the parameter for a PointAtParameter node."
}, {
    "Name": "PrincipalCurvaturesAtParameter",
    "imageFile": ["PrincipalCurvaturesAtParameter"],
    "dynFile": ["PrincipalCurvaturesAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Principal Curvatures at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two numbers, with the first being the curvature in the U direction and the second being the curvature in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the curvatures using a PrincipalCurvaturesAtParameter node."
}, {
    "Name": "PrincipalDirectionsAtParameter",
    "imageFile": ["PrincipalDirectionsAtParameter"],
    "dynFile": ["PrincipalDirectionsAtParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Principal Directions at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two vectors, with the first being the direction vector in the U direction and the second being the direction vector in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the directions using a PrincipalDirectionsAtParameter node."
}, {
    "Name": "ProjectInputOnto",
    "imageFile": ["ProjectInputOnto"],
    "dynFile": ["ProjectInputOnto"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Project Input Onto will project an input geometry onto a given surface along a given direction. In the example below, we first create a surface by using a BySweep2Rails. This is the surface we will project onto. We make a circle at the origin to use as the geometry to project, and simply use the world Z-direction as the direction vector for projection. The result is a circle projected onto the surface."
}, {
    "Name": "SubtractFrom",
    "imageFile": ["SubtractFrom"],
    "dynFile": ["SubtractFrom"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Subtract From will create a new surface by subtracting the input trimming geometry from they input surface. In the example below, we first create a surface by using a BySweep2Rails. We then use a series of number slider to contrel the length, width, and height of a cuboid. By using a SubtractFrom node, we can trim the surface by subracting out the area that intersects with the cuboid."
}, {
    "Name": "TangentAtUParameter",
    "imageFile": ["TangentAtUParameter"],
    "dynFile": ["TangentAtUParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Tangent at U Parameter will return the tangent vector in the U direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the U tangent vector."
}, {
    "Name": "TangentAtVParameter",
    "imageFile": ["TangentAtVParameter"],
    "dynFile": ["TangentAtVParameter"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Tangent at U Parameter will return the tangent vector in the V direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the V tangent vector."
}, {
    "Name": "Thicken (thickness, both_sides)",
    "imageFile": ["Thicken (thickness, both_sides)"],
    "dynFile": ["Thicken (thickness, both_sides)"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Thicken Surface into a Solid, extruding in the direction of Surface normals. If both_sides parameter is true, surface is thickened on both sides."
}, {
    "Name": "Thicken (thickness)",
    "imageFile": ["Thicken (thickness)"],
    "dynFile": ["Thicken (thickness)"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Thicken Surface into a Solid, extruding in the direction of Surface normals on both sides of the Surface."
}, {
    "Name": "ToNurbsSurface",
    "imageFile": ["ToNurbsSurface"],
    "dynFile": ["ToNurbsSurface"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "Surface To Nurbs Surface takes a surface as input and returns a Nurbs Surface that approximates the input surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ToNurbsSurface node, the result is an untrimmed Nurbs Surface with four sides."
}, {
    "Name": "TrimWithEdgeLoops",
    "imageFile": ["TrimWithEdgeLoops"],
    "dynFile": ["TrimWithEdgeLoops"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "TrimWithEdgeLoops will return a new Surface trimmed from an input Surface. In the example below, two loops are trimmed out of a Surface, returning two new Surfaces highlighted in blue. The number slider will adjust the shape of the new Surfaces. The loops input will take a single PolyCurve or a list of them."
}, {
    "Name": "UVParameterAtPoint",
    "imageFile": ["UVParameterAtPoint"],
    "dynFile": ["UVParameterAtPoint"],
    "folderPath": "Geometry/Surfaces/Surface/Action",
    "inDepth": "UV Parameter At Point finds the UV position of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the UN parameter at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the UV parameter of."
}, {
    "Name": "Area",
    "imageFile": ["Area"],
    "dynFile": ["Area"],
    "folderPath": "Geometry/Surfaces/Surface/Query",
    "inDepth": "Room area is returned as a double."
}, {
    "Name": "Closed",
    "imageFile": ["Closed"],
    "dynFile": ["Closed"],
    "folderPath": "Geometry/Surfaces/Surface/Query",
    "inDepth": "Closed will return a boolean value based on whether a Surface is closed in it's U or V directions. In the example below, two extruded Surfaces are tested, and the extruded circle returns true. By adjusting the number slider, the extruded arc will close into a circle and also return true."
}, {
    "Name": "ClosedInU",
    "imageFile": ["ClosedInU"],
    "dynFile": ["ClosedInU"],
    "folderPath": "Geometry/Surfaces/Surface/Query",
    "inDepth": "ClosedInU will return a boolean value based on whether a Surface is closed in it's U direction. In the example below, an extruded circle that is closed in one direction returns false for being closed in U."
}, {
    "Name": "ClosedInV",
    "imageFile": ["ClosedInV"],
    "dynFile": ["ClosedInV"],
    "folderPath": "Geometry/Surfaces/Surface/Query",
    "inDepth": "ClosedInV will return a boolean value based on whether a Surface is closed in it's V direction. In the example below, an extruded circle that is closed in one direction returns true for being closed in V"
}, {
    "Name": "Perimeter",
    "imageFile": ["Perimeter"],
    "dynFile": ["Perimeter"],
    "folderPath": "Geometry/Surfaces/Surface/Query",
    "inDepth": "Perimeter will return the length of a Surface's perimeter as a double. In the example below, a complex NurbsSurface's perimeter returns a value of 36.432."
}, {
    "Name": "ByPoints",
    "imageFile": ["ByPoints"],
    "dynFile": ["ByPoints"],
    "folderPath": "Geometry/Tessellation/ConvexHull/Action",
    "inDepth": "Revit will generate and contour a mesh from a list of supplied points. The points cannot be collinear."
}, {
    "Name": "ByParametersOnSurface",
    "imageFile": ["ByParametersOnSurface"],
    "dynFile": ["ByParametersOnSurface"],
    "folderPath": "Geometry/Tessellation/Delaunay/Action",
    "inDepth": "ByParametersOnSurface will return a Voronoi representation of a surface's UV as a list of curves. In the example below, a Voronoi representation is created on a surface using a UV system of 50 random values. In order for the Voronoi to stop at the edges of the surface, the returned curves must be intersected with the surface."
}, {
    "Name": "ByPoints",
    "imageFile": ["ByPoints"],
    "dynFile": ["ByPoints"],
    "folderPath": "Geometry/Tessellation/Delaunay/Action",
    "inDepth": "Revit will generate and contour a mesh from a list of supplied points. The points cannot be collinear."
}, {
    "Name": "ByParametersOnSurface",
    "imageFile": ["ByParametersOnSurface"],
    "dynFile": ["ByParametersOnSurface"],
    "folderPath": "Geometry/Tessellation/Voronoi/Action",
    "inDepth": "ByParametersOnSurface will return a Voronoi representation of a surface's UV as a list of curves. In the example below, a Voronoi representation is created on a surface using a UV system of 50 random values. In order for the Voronoi to stop at the edges of the surface, the returned curves must be intersected with the surface."
}, {
    "Name": "ExportCSV",
    "imageFile": ["ExportCSV"],
    "dynFile": ["ExportCSV"],
    "folderPath": "ImportExport/Data/Action",
    "inDepth": "Write a list of lists into a file using a comma-separated values format. Outer list represents rows, inner lists represent columns."
}, {
    "Name": "ExportExcel",
    "imageFile": ["ExportExcel"],
    "dynFile": ["ExportExcel"],
    "folderPath": "ImportExport/Data/Action",
    "inDepth": "Write data to a Microsoft Excel spreadsheet. Data is written by row with sublists to be written in successive rows. Rows and columns are zero-indexed; for example, the value in the data list at [0,0] will be written to cell A1. Null values and empty lists are written to Excel as empty cells. This node requires Microsoft Excel to be installed."
}, {
    "Name": "ImportCSV",
    "imageFile": ["ImportCSV"],
    "dynFile": ["ImportCSV"],
    "folderPath": "ImportExport/Data/Action",
    "inDepth": "Imports data from a CSV (comma separated values) file, put the items into a list and transpose it if needed."
}, {
    "Name": "ImportExcel",
    "imageFile": ["ImportExcel"],
    "dynFile": ["ImportExcel"],
    "folderPath": "ImportExport/Data/Action",
    "inDepth": "Read data from a Microsoft Excel spreadsheet. Data is read by row and returned in a series of lists by row. Rows and columns are zero-indexed; for example, the value in cell A1 will appear in the data list at [0,0]. This node requires Microsoft Excel to be installed."
}, {
    "Name": "AppendText",
    "imageFile": ["AppendText"],
    "dynFile": ["AppendText"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Append the text content to a file specified by the path."
}, {
    "Name": "ChangePathExtension",
    "imageFile": ["ChangePathExtension"],
    "dynFile": ["ChangePathExtension"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Changes the extension of a file path."
}, {
    "Name": "CombinePath",
    "imageFile": ["CombinePath"],
    "dynFile": ["CombinePath"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Combines multiple strings into a single file path."
}, {
    "Name": "CopyDirectory",
    "imageFile": ["CopyDirectory"],
    "dynFile": ["CopyDirectory"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Copies a directory to a destination location."
}, {
    "Name": "CopyFile",
    "imageFile": ["CopyFile"],
    "dynFile": ["CopyFile"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Copies a file, given the file, destination path and overwrite choice."
}, {
    "Name": "DeleteDirectory",
    "imageFile": ["DeleteDirectory"],
    "dynFile": ["DeleteDirectory"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Deletes a directory. Recursive option allows for the node to dig down into subdirectories."
}, {
    "Name": "DeleteFile",
    "imageFile": ["DeleteFile"],
    "dynFile": ["DeleteFile"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Deletes the specified file."
}, {
    "Name": "DirectoryExists",
    "imageFile": ["DirectoryExists"],
    "dynFile": ["DirectoryExists"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Determines if a directory exists at the given path."
}, {
    "Name": "Directory From Path",
    "imageFile": ["Directory From Path"],
    "dynFile": ["Directory From Path"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Creates a directory object from a path."
}, {
    "Name": "DirectoryName",
    "imageFile": ["DirectoryName"],
    "dynFile": ["DirectoryName"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Directory Name will return the director of a file or director path. In the example below, we use a DirectorPath node to extract the directory from a file path. In addition to FileName and Extension, this allows us to break apart a file path into separate components."
}, {
    "Name": "Directory Path",
    "imageFile": ["Directory Path"],
    "dynFile": ["Directory Path"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Directory Path allows the user to select a directory from their computer. To set the directory path, click the 'Browse...' button on the Directory Path node, then navigate to the desired directory. If this node is added to a previously saved .dyn file, this node will default to the directory of the .dyn file."
}, {
    "Name": "FileExists",
    "imageFile": ["FileExists"],
    "dynFile": ["FileExists"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Determines if a file exists at the given path."
}, {
    "Name": "FileExtension",
    "imageFile": ["FileExtension"],
    "dynFile": ["FileExtension"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Returns the extension from a file path."
}, {
    "Name": "File From Path",
    "imageFile": ["File From Path"],
    "dynFile": ["File From Path"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Creates a file object from a path."
}, {
    "Name": "FileHasExtension",
    "imageFile": ["FileHasExtension"],
    "dynFile": ["FileHasExtension"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Determines whether or not a file path contains an extension."
}, {
    "Name": "FileName",
    "imageFile": ["FileName"],
    "dynFile": ["FileName"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "File Name will return the file name from an input file path. A boolean input provides to option to return the file name with or without the extension. In addition to DirectoryName and Extension, this allows us to break apart a file path into separate components."
}, {
    "Name": "File Path",
    "imageFile": ["File Path"],
    "dynFile": ["File Path"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "File Path allows the user to select a file from their computer. To set the file path, click the 'Browse...' button on the File Path node, then navigate to the desired file."
}, {
    "Name": "GetDirectoryContents",
    "imageFile": ["GetDirectoryContents"],
    "dynFile": ["GetDirectoryContents"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "GetDirectoryContents will retrieve the contents of a directory and subdirectories if that option is selected."
}, {
    "Name": "MoveDirectory",
    "imageFile": ["MoveDirectory"],
    "dynFile": ["MoveDirectory"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Moves a directory to a new location."
}, {
    "Name": "MoveFile",
    "imageFile": ["MoveFile"],
    "dynFile": ["MoveFile"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Moves a specified file to a new location."
}, {
    "Name": "ReadText (file)",
    "imageFile": ["ReadText (file)"],
    "dynFile": ["ReadText (file)"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "Reads a text file and returns the contents as a string."
}, {
    "Name": "WriteText",
    "imageFile": ["WriteText"],
    "dynFile": ["WriteText"],
    "folderPath": "ImportExport/File System/Action",
    "inDepth": "WriteText will write a string to a specified file. If the file does not exists, this node will create the file. To create newlines in the output file, we can use the escape character '\\r\\n'. In the example below, we have a list of strings that we want to write as three separate lines in a text file. We join the list into a single string using '\\r\\n' as the separator. We then use a WriteText node to write this to a text file."
}, {
    "Name": "Dimensions",
    "imageFile": ["Dimensions"],
    "dynFile": ["Dimensions"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "Dimensions will return the width and height of an input image in pixels. In the example below, we first use a File Path node and a File.FromPath to create a file object that points to an image. Image.ReadFromFile is then used to create an image object based on the file. A Dimensions node shows us that this image has a width and height of 270 pixels."
}, {
    "Name": "FromPixels (colors)",
    "imageFile": ["FromPixels (colors)"],
    "dynFile": ["FromPixels (colors)"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "From Pixels will create an image object from an input two-dimensional array of colors. In the example below, we first use a code block to generate a range of numbers from 0 to 255. A Color.ByARGB node is used to create colors from this range, and the lacing of this node is set to Cross Product to create a two-dimensional array. We then use an Image.FromPixels node to create an image. A Watch Image node can be used to preview the image created."
}, {
    "Name": "FromPixels (colors, width, height)",
    "imageFile": ["FromPixels (colors, width, height)"],
    "dynFile": ["FromPixels (colors, width, height)"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "From Pixels with width and height will create an image from an input flat list of colors, where each color will become one pixel. The width multiplied by the height should equal the total number of colors. In the example below, we first create a list of colors using a ByARGB node. A code block creates a range of values from 0 to 255, which when connected to the r and g inputs produces a series of colors from black to yellow. We create a image with a width of 8. A Count node and Division node are used to determine the height of the image. A Watch Image node can be used to preview the image created."
}, {
    "Name": "Pixels",
    "imageFile": ["Pixels"],
    "dynFile": ["Pixels"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "Pixels will return a list of colors from an input image as a two-dimensional array. The Pixels node has two additional inputs to specify the number of x and y samples to use to extract pixels from. In the example below, we read an image using a ReadFromFile node. This image is then input into a Pixels node to extract the pixel colors."
}, {
    "Name": "ReadFromFile",
    "imageFile": ["ReadFromFile"],
    "dynFile": ["ReadFromFile"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "Read From File takes a file as input. The file should be a text file that has data separated by commas. The different lines in the file correspond to the outer list, while the individual values in each line correspond to the inner lists. In the example below, we first use a File Path node and a File.FromPath node to create a file object that points to a text file. Then we use a ReadFromFile node to create a list from the CSV file."
}, {
    "Name": "WriteToFile",
    "imageFile": ["WriteToFile"],
    "dynFile": ["WriteToFile"],
    "folderPath": "ImportExport/Image/Action",
    "inDepth": "WriteToFile will return a List of Lists that is written to an Excel file. The sheet name, start row, and start column of where to write the data can be defined as inputs as well as whether existing data will be overwritten. In the example below, a List of Lists containing a number sequence is written to sampleexcel.xlsx starting at row 0 (or 1 in Excel) and column 1 (or B in Excel). The Excel file now has nine new columns with data in two existing rows. Screenshots of sampleexcel.xlsx before and after writing are overlaid to show the data in Excel's format."
}, {
    "Name": "Web Request",
    "imageFile": ["Web Request"],
    "dynFile": ["Web Request"],
    "folderPath": "ImportExport/Web/Action",
    "inDepth": "Web Request will return the content of a webpage from an input URL as a string. In the example below, a web request is made to http://www.google.com and its HTML content is returned."
}, {
    "Name": "Boolean",
    "imageFile": ["Boolean"],
    "dynFile": ["Boolean"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "The Boolean node allows the user to toggle between two boolean values 'true' or 'false' by selecting the appropriate radio button. "
}, {
    "Name": "Input",
    "imageFile": ["Input"],
    "dynFile": ["Input"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "Input will create an input port for a custom node. The syntax for an input node is input_name : datatype = default_value(optional) and an optional custom comment. In the example below, x and y inputs are created with double data type, default values of 2 and 10, and a custom comment. It is important to note that this node is only available while creating a custom node."
}, {
    "Name": "Integer Slider",
    "imageFile": ["Integer Slider"],
    "dynFile": ["Integer Slider"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "An Integer Slider works in the same way as a Number Slider but only outputs integers. The Integer Slider in the example definition allows us to control the list length, ensuring that we always have whole-number of list outputs. "
}, {
    "Name": "Number",
    "imageFile": ["Number"],
    "dynFile": ["Number"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "Room numbers are returned as strings."
}, {
    "Name": "Number Slider",
    "imageFile": ["Number Slider"],
    "dynFile": ["Number Slider"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "The Number Slider is a customizable, tactile node that allows us to interface with the data driving our Dynamo definitions. Here, the number slider is paired with a code block to create a dynamic list sequence with a variable step size."
}, {
    "Name": "Output",
    "imageFile": ["Output"],
    "dynFile": ["Output"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "Output will create an output port for a custom node. The syntax for an output node is simply its name, along with an optional custom comment. In the example below, an output named Percentage is created with a custom comment. It is important to note that this node is only available while creating a custom node."
}, {
    "Name": "String",
    "imageFile": ["String"],
    "dynFile": ["String"],
    "folderPath": "Input/Basic/Action",
    "inDepth": "The String node allows a user to enter a string value. A string can also be created with a Code Block by surrounding the string in quotes. In the example below, we use a String node and a Code Block to create the strings 'Hello' and 'World'. A String.Join node is used to combine the two strings together. A second String node is used with a blank space to act as the separator, resulting in the output string 'Hello World'."
}, {
    "Name": "AddTimeSpan",
    "imageFile": ["AddTimeSpan"],
    "dynFile": ["AddTimeSpan"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "AddTimeSpan will return a new dateTime with a timeSpan added to it. In the example below, one day and eight hours is added to the dateTime for Now, returning a date that is one day and eight hours ahead."
}, {
    "Name": "ByDate",
    "imageFile": ["ByDate"],
    "dynFile": ["ByDate"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "ByDate will return a dateTime from year, month, and day inputs. In the example below, a new dateTime of August 08, 2006 is created from those respective inputs."
}, {
    "Name": "ByDateAndTime",
    "imageFile": ["ByDateAndTime"],
    "dynFile": ["ByDateAndTime"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "ByDateAndTime will return a dateTime from year, month, day, hour, minute, second, and millisecond inputs. In the example below, a new dateTime of August 08, 2006 4:24PM is created from those respective inputs."
}, {
    "Name": "Components",
    "imageFile": ["Components"],
    "dynFile": ["Components"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "Components will return the Days, Hours, Minutes, etc of a TimeSpan. In the example below, a TimeSpan of 5:16:21 returns 0 Days, 5 Hours, 6 Minutes, 21 Seconds, and 0 Milliseconds."
}, {
    "Name": "Date",
    "imageFile": ["Date"],
    "dynFile": ["Date"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "Date will return only the date (year, month, day) from a dateTime. In the example below, only the date, August 08 2006, is extracted from a dateTime, August 08, 2006 4:24PM."
}, {
    "Name": "Date Time",
    "imageFile": ["Date Time"],
    "dynFile": ["Date Time"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "DateTime will create a datetime object with the specified input month, day, year, and time. The format must be in the form: 'January 01, 1900 12:00 AM' The month must be capitalized and written out in full. The day must be two digits, the year must be four digits."
}, {
    "Name": "DayOfWeek",
    "imageFile": ["DayOfWeek"],
    "dynFile": ["DayOfWeek"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "DayOfWeek will return only the day from a dateTime. In the example below, only the day, Tuesday, is extracted from a dateTime, August 08, 2006 4:24PM."
}, {
    "Name": "DayOfYear",
    "imageFile": ["DayOfYear"],
    "dynFile": ["DayOfYear"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "DayOfYear will return the day of the year from a dateTime as a number. In the example below, the dateTime, August 08, 2006 4:24PM, is day 220 of the year."
}, {
    "Name": "DaysInMonth",
    "imageFile": ["DaysInMonth"],
    "dynFile": ["DaysInMonth"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "DaysInMonth will return the number of days in a month of a certain year. In the example below, August 2006 returns 31 days."
}, {
    "Name": "Format",
    "imageFile": ["Format"],
    "dynFile": ["Format"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "Return a specified date and time as a string, in the specified format. Utilizes format strings, for a description search for MSDN datetime format."
}, {
    "Name": "FromString",
    "imageFile": ["FromString"],
    "dynFile": ["FromString"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "FromString will return a TimeSpan from a String. In the example below, a String \"5:6:21\" will return a TimeSpan of 5 Hours, 6 Minutes, and 21 Seconds."
}, {
    "Name": "IsDaylightSavingsTime",
    "imageFile": ["IsDaylightSavingsTime"],
    "dynFile": ["IsDaylightSavingsTime"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "IsDaylightSavingsTime will return a boolean value based on whether the dateTime falls within Daylight Saving Time. In the example below, a dateTime of November 14, 2016 12:36PM returns false."
}, {
    "Name": "IsLeapYear",
    "imageFile": ["IsLeapYear"],
    "dynFile": ["IsLeapYear"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "IsLeapYear will return a boolean value based on whether a dateTime falls within a Leap Year. In the example below, a dateTime of 2016 returns true!"
}, {
    "Name": "SubtractTimeSpan",
    "imageFile": ["SubtractTimeSpan"],
    "dynFile": ["SubtractTimeSpan"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "SubtractTimeSpan will return a new dateTime by subtracting a timeSpan from a dateTime. In the example below, a timeSpan of one day and eight hours is subtracted from a dateTime of Now, returning November 13, 2016 4:40AM."
}, {
    "Name": "TimeOfDay",
    "imageFile": ["TimeOfDay"],
    "dynFile": ["TimeOfDay"],
    "folderPath": "Input/DateTime/Action",
    "inDepth": "TimeOfDay will return the time past midnight of a dateTime. In the example below, a dateTime of Now returns 12:40:32 or roughly 12:40PM."
}, {
    "Name": "MaxValue",
    "imageFile": ["MaxValue"],
    "dynFile": ["MaxValue"],
    "folderPath": "Input/DateTime/Query",
    "inDepth": "MaxValue will return the maximum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
}, {
    "Name": "MinValue",
    "imageFile": ["MinValue"],
    "dynFile": ["MinValue"],
    "folderPath": "Input/DateTime/Query",
    "inDepth": "MinValue will return the minimum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
}, {
    "Name": "Now",
    "imageFile": ["Now"],
    "dynFile": ["Now"],
    "folderPath": "Input/DateTime/Query",
    "inDepth": "Now will return the current system date and time. The example file below showed Now as returning November 14, 2016 12:48PM when it was created."
}, {
    "Name": "Today",
    "imageFile": ["Today"],
    "dynFile": ["Today"],
    "folderPath": "Input/DateTime/Query",
    "inDepth": "Today will return the current date. The example file below showed Today as returning November 14, 2016 12:00AM when it was created."
}, {
    "Name": "ByLatitudeAndLongitude",
    "imageFile": ["ByLatitudeAndLongitude"],
    "dynFile": ["ByLatitudeAndLongitude"],
    "folderPath": "Input/Location/Create",
    "inDepth": "ByLatitudeAndLongitude will return a Location from input latitude and longitude values (doubles) and a input name (string). In the example below, a Location is created from latitude 45.5231, longitude -122.679565, and a name: Portland."
}, {
    "Name": "Latitude",
    "imageFile": ["Latitude"],
    "dynFile": ["Latitude"],
    "folderPath": "Input/Location/Query",
    "inDepth": "Latitude will return the latitude value from a Location. In the example below, a latitude of 45.5231 is returned from input Location."
}, {
    "Name": "Longitude",
    "imageFile": ["Longitude"],
    "dynFile": ["Longitude"],
    "folderPath": "Input/Location/Query",
    "inDepth": "Longitude will return the longitude value from a Location. In the example below, a longitude of -122.679565 is returned from the input Location."
}, {
    "Name": "Name",
    "imageFile": ["Name"],
    "dynFile": ["Name"],
    "folderPath": "Input/Location/Query",
    "inDepth": "Add in-depth information about Name..."
}, {
    "Name": "Identity",
    "imageFile": ["Identity"],
    "dynFile": ["Identity"],
    "folderPath": "Input/Object/Action",
    "inDepth": "Identity will return what is passed in. In the example below, the Identity node is used to preview each piece of geometry created inside a Code Block."
}, {
    "Name": "IsNull",
    "imageFile": ["IsNull"],
    "dynFile": ["IsNull"],
    "folderPath": "Input/Object/Action",
    "inDepth": "IsNull will return a boolean value based on whether an object is null. In the example below, a grid of circles is drawn with varying radii based on the Red level in a bitmap. Where there is no Red value, no circle is drawn and returns a null in the list of circles. Passing this list through IsNull returns a list of boolean values, with true representing every location of a null value. This list of booleans can be used with List.FilterByBoolMask to return a list without nulls."
}, {
    "Name": "Type",
    "imageFile": ["Type"],
    "dynFile": ["Type"],
    "folderPath": "Input/Object/Action",
    "inDepth": "Type returns a structural element's family type as well as its parent family."
}, {
    "Name": "Add",
    "imageFile": ["Add"],
    "dynFile": ["Add"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Add will return a Vector that is the sum of two other Vectors. In the example below, the sum of the WCS Z axis and X axis Vectors results in a Vector with coordinates of (1,0,1). The new Vector is represented as a Line."
}, {
    "Name": "ByDateDifference",
    "imageFile": ["ByDateDifference"],
    "dynFile": ["ByDateDifference"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "ByDateDifference will return the difference of two DateTimes as a new TimeSpan. In the example below, the difference between Now and November 14, 2000 11:57AM was returned as 5844 Days, and roughly 4 Seconds."
}, {
    "Name": "Components",
    "imageFile": ["Components"],
    "dynFile": ["Components"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Components will return the Days, Hours, Minutes, etc of a TimeSpan. In the example below, a TimeSpan of 5:16:21 returns 0 Days, 5 Hours, 6 Minutes, 21 Seconds, and 0 Milliseconds."
}, {
    "Name": "Create",
    "imageFile": ["Create"],
    "dynFile": ["Create"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Create will return a new TimeSpan based on days, hours, minutes, seconds, and milliseconds. In the example below, we create the TimeSpan 2.03:30:00, or 2 Days, 3 Hours, and 30 Minutes."
}, {
    "Name": "FromString",
    "imageFile": ["FromString"],
    "dynFile": ["FromString"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "FromString will return a TimeSpan from a String. In the example below, a String \"5:6:21\" will return a TimeSpan of 5 Hours, 6 Minutes, and 21 Seconds."
}, {
    "Name": "Negate",
    "imageFile": ["Negate"],
    "dynFile": ["Negate"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Negate will return the negative of a TimeSpan. In the example below, a TimeSpan of 2 Days, 3 Hours, and 30 minutes is made negative (-2.03:30:00)."
}, {
    "Name": "Scale",
    "imageFile": ["Scale"],
    "dynFile": ["Scale"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Scale will return a new TimeSpan scaled by a factor. In the example below, a TimeSpan (2.03:30:00) is scaled by a factor of 2 (4.07:00:00)."
}, {
    "Name": "Subtract",
    "imageFile": ["Subtract"],
    "dynFile": ["Subtract"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "Subtract will return a Vector that is the difference of two other Vectors. In the example below, the difference of the a Vector with coordinates (1,0,1) and WCS Z axis results in a Vector with coordinates of (1,0,0). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different subtracted vector. The Vectors are represented as Lines."
}, {
    "Name": "TotalDays",
    "imageFile": ["TotalDays"],
    "dynFile": ["TotalDays"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "TotalDays will return the number of days in a TimeSpan as a double. In the example below, the total number of days returned from the TimeSpan 2.03:00:00 is ~2.1458333."
}, {
    "Name": "TotalHours",
    "imageFile": ["TotalHours"],
    "dynFile": ["TotalHours"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "TotalHours will return the number of hours in a TimeSpan as a double. In the example below, the total number of hours returned from the TimeSpan 2.03:00:00 is 51.5."
}, {
    "Name": "TotalMilliseconds",
    "imageFile": ["TotalMilliseconds"],
    "dynFile": ["TotalMilliseconds"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "TotalMilliseconds will return the number of milliseconds in a TimeSpan as a double. In the example below, the total number of milliseconds returned from the TimeSpan 2.03:00:00 is 185400000."
}, {
    "Name": "TotalMinutes",
    "imageFile": ["TotalMinutes"],
    "dynFile": ["TotalMinutes"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "TotalMinutes will return the number of minutes in a TimeSpan as a double. In the example below, the total number of minutes returned from the TimeSpan 2.03:00:00 is 3090."
}, {
    "Name": "TotalSeconds",
    "imageFile": ["TotalSeconds"],
    "dynFile": ["TotalSeconds"],
    "folderPath": "Input/TimeSpan/Action",
    "inDepth": "TotalSeconds will return the number of seconds in a TimeSpan as a double. In the example below, the total number of seconds returned from the TimeSpan 2.03:00:00 is 185400."
}, {
    "Name": "MaxValue",
    "imageFile": ["MaxValue"],
    "dynFile": ["MaxValue"],
    "folderPath": "Input/TimeSpan/Query",
    "inDepth": "MaxValue will return the maximum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
}, {
    "Name": "MinValue",
    "imageFile": ["MinValue"],
    "dynFile": ["MinValue"],
    "folderPath": "Input/TimeSpan/Query",
    "inDepth": "MinValue will return the minimum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
}, {
    "Name": "Zero",
    "imageFile": ["Zero"],
    "dynFile": ["Zero"],
    "folderPath": "Input/TimeSpan/Query",
    "inDepth": "Zero will return a new TimeSpan with no elapsed time. In the example below, a TimeSpan of Zero is displayed as 00:00:00."
}, {
    "Name": "List Create",
    "imageFile": ["List Create"],
    "dynFile": ["List Create"],
    "folderPath": "List/Generate/Create",
    "inDepth": "Create a multi-dimension list from input lists."
}, {
    "Name": "Range",
    "imageFile": ["Range"],
    "dynFile": ["Range"],
    "folderPath": "List/Generate/Create",
    "inDepth": "Range will produce a list of numbers between the specified Start and End inputs. The numbers will increase from the Start input according to the Step. In the example below, we start with 1 and end with 25. By using a step of 2 the result is odd numbers between 1 and 25."
}, {
    "Name": "Sequence",
    "imageFile": ["Sequence"],
    "dynFile": ["Sequence"],
    "folderPath": "List/Generate/Create",
    "inDepth": "Sequence will produce a list of numbers. The list begins at the Start input, and then increments by the Step input. The Amount input determines the number of items in the list. In the example, we create a list of 25 numbers, starting at 1 and incrementing by 2."
}, {
    "Name": "Combinations",
    "imageFile": ["Combinations"],
    "dynFile": ["Combinations"],
    "folderPath": "List/Generate/Action",
    "inDepth": "Combinations will return a nested list that includes all possible combinations of the items in the input list with a given length. For combinations, the order of the elements does not matter, so the output list {0,1} is considered the same combination as {1,0}. If 'replace' is set to true, the items will be replaced back into the original list, allowing for elements to be used repeatedly in a combination. In the example below, we use a code block to generate a range of numbers from 0 to 5, stepping by one. We use Combinations with an input length of 3 to generate all the different ways to combine 3 of those numbers. A boolean toggle allows to select whether numbers are replaced or not."
}, {
    "Name": "Cycle",
    "imageFile": ["Cycle"],
    "dynFile": ["Cycle"],
    "folderPath": "List/Generate/Action",
    "inDepth": "Cycle will take an input list and return a new list comprised of the input list repeated according the input 'amount'. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Cycle node with an input amount of 3. The result is a list with 18 elements, consisting of 3 cycles of the original list."
}, {
    "Name": "Join",
    "imageFile": ["Join"],
    "dynFile": ["Join"],
    "folderPath": "List/Generate/Action",
    "inDepth": "Concatenates all given lists into a single list."
}, {
    "Name": "OfRepeatedItem",
    "imageFile": ["OfRepeatedItem"],
    "dynFile": ["OfRepeatedItem"],
    "folderPath": "List/Generate/Action",
    "inDepth": "Of Repeated Item will create a list by repeated a given item a certain number of times specified by the 'amount' input. In the example below, we create a list consisting of the number 4 repeated ten times."
}, {
    "Name": "Permutations",
    "imageFile": ["Permutations"],
    "dynFile": ["Permutations"],
    "folderPath": "List/Generate/Action",
    "inDepth": "Permutations will create a nested list consisting of all permutations of a specified length from a given input list. In the example below, we use a code block to create a range of numbers from 0 to 5, stepping by one. We then use a Permutation node with an length input of 3 to generate all permutations of three elements from the range {0,1,2,3,4,5}."
}, {
    "Name": "Empty",
    "imageFile": ["Empty"],
    "dynFile": ["Empty"],
    "folderPath": "List/Generate/Query",
    "inDepth": "Empty will return an empty list. In the example, a list is created with several integers and an empty list."
}, {
    "Name": "AllFalse",
    "imageFile": ["AllFalse"],
    "dynFile": ["AllFalse"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "AllFalse only returns <strong>true</strong> if <em>every</em> item in a list is false."
}, {
    "Name": "AllIndicesOf",
    "imageFile": ["AllIndicesOf"],
    "dynFile": ["AllIndicesOf"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Given an item, returns the zero-based indices of all its occurrences in the list. If the item cannot be found, an empty list is returned."
}, {
    "Name": "AllTrue",
    "imageFile": ["AllTrue"],
    "dynFile": ["AllTrue"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "AllTrue only returns <strong>true</strong> if <em>every</em> item in a list is false."
}, {
    "Name": "Contains",
    "imageFile": ["Contains"],
    "dynFile": ["Contains"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Bounding Box Contains tests if a specified Point is inside of a Bounding Box. Because the Point in this example is at (5,5,5), and our Origin Sphere’s Radius is larger than 5, the Contains node will return True."
}, {
    "Name": "Count",
    "imageFile": ["Count"],
    "dynFile": ["Count"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Count will return an integer that represents the number of Indices in an IndexGroup. In the example below, Index counts are returned for Mesh faces with three and four edges."
}, {
    "Name": "CountFalse",
    "imageFile": ["CountFalse"],
    "dynFile": ["CountFalse"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "CountFalse returns the amount of false <strong>(boolean)</strong> values in the input list or lists."
}, {
    "Name": "CountTrue",
    "imageFile": ["CountTrue"],
    "dynFile": ["CountTrue"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "CountTrue returns the amount of true <strong>(boolean)</strong> values in the input list or lists."
}, {
    "Name": "DiagonalLeft",
    "imageFile": ["DiagonalLeft"],
    "dynFile": ["DiagonalLeft"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "DiagonalLeft will return a new list of lists of elements along each diagonal in the list matrix from top right to the lower left. In the example below, a list created by DiagonalLeft is compared to it's source list."
}, {
    "Name": "DiagonalRight",
    "imageFile": ["DiagonalRight"],
    "dynFile": ["DiagonalRight"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "DiagonalRight will return a new list of lists of values along each diagonal in the list matrix from lower right to the top left. In the example below, a list created by DiagonalRight is compared to it's source list."
}, {
    "Name": "Equals",
    "imageFile": ["Equals"],
    "dynFile": ["Equals"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Equals will return a boolean value that is true if ObjectA is equal to ObjectB. In the example below, the radii (doubles) of two circles are compared. Adjusting the sliders can change the circles' radii, making them equal or unequal."
}, {
    "Name": "FirstIndexOf",
    "imageFile": ["FirstIndexOf"],
    "dynFile": ["FirstIndexOf"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "First Index Of will search through a given list and return the index of the first instance of the input item to search for. In the example below, we first generate list of ten random numbers between 0 and 4. By using a FirstIndexOf node, we can search for a specific item, and get the index of the first time that item is found in the last."
}, {
    "Name": "FirstItem",
    "imageFile": ["FirstItem"],
    "dynFile": ["FirstItem"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "First Item simply returns the first item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use FirstItem node to return the first item of the list. "
}, {
    "Name": "GetItemAtIndex",
    "imageFile": ["GetItemAtIndex"],
    "dynFile": ["GetItemAtIndex"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Get Item At Index takes an input list, and an integer and returns the item from the list found at the input index. In the example below, we first use a code block to generate a range of numbers from zero to 5, stepping by one. We can then extract a single element at a specified index by using a GetItemAtIndex node."
}, {
    "Name": "IndexOf",
    "imageFile": ["IndexOf"],
    "dynFile": ["IndexOf"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "IndexOf will search a given string for a second input string. If the second string is found, this node will return the index of the first character of the first occurrence of the string.  By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the character 'o', This letter occurs twice in the string, but only the index of the first occurrence is returned by the IndexOf node."
}, {
    "Name": "IsEmpty",
    "imageFile": ["IsEmpty"],
    "dynFile": ["IsEmpty"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "IsEmpty will return a boolean value based on whether the Bounding Box is empty or not."
}, {
    "Name": "IsHomogeneous",
    "imageFile": ["IsHomogeneous"],
    "dynFile": ["IsHomogeneous"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "IsHomogeneous will return a boolean value based on whether the elements in a list are all of the same type. In the example below, a simple list of numbers is compared to the same list with a string inserted. The original list is homogeneous (numbers) and the new list is not homogeneous (numbers and a string)."
}, {
    "Name": "IsRectangular",
    "imageFile": ["IsRectangular"],
    "dynFile": ["IsRectangular"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "IsRectangular returns a boolean value based on whether a curtain panel is rectangular or not. Certain CurtainPanel query nodes, such as Height and Width, require that a curtain panel is rectangular."
}, {
    "Name": "IsUniformDepth",
    "imageFile": ["IsUniformDepth"],
    "dynFile": ["IsUniformDepth"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "IsUniformDepth will return a boolean value based on whether the list's depth is consistent (the number of lists inside each list). In the example below, two lists are compared (one of uniform depth and one not) to show the difference. The non-uniform list contains two lists, one of which has two more inside of that. The lists at [0] and [1] are not equal in depth."
}, {
    "Name": "LastItem",
    "imageFile": ["LastItem"],
    "dynFile": ["LastItem"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Last Item simply returns the last item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use LastItem node to return the last item of the list. "
}, {
    "Name": "MaximumItem",
    "imageFile": ["MaximumItem"],
    "dynFile": ["MaximumItem"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Maximum Item will search through a list of values and return the item with the maximum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MaximumItem node to find the largest item in the list."
}, {
    "Name": "MinimumItem",
    "imageFile": ["MinimumItem"],
    "dynFile": ["MinimumItem"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Minimum Item will search through a list of values and return the item with the minimum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MinimumItem node to find the smallest item in the list."
}, {
    "Name": "Rank",
    "imageFile": ["Rank"],
    "dynFile": ["Rank"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Counts how many levels are in a list"
}, {
    "Name": "SetDifference",
    "imageFile": ["SetDifference"],
    "dynFile": ["SetDifference"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "SetDifference will return a new list based on the objects that one list contains and another does not. In the example below, a list of 0 to 9 counting by 1 is compared to a list of 0 to 18 counting by 2. Odd numbers below 10 are returned because they are contained in List1, but not in List2."
}, {
    "Name": "SetIntersection",
    "imageFile": ["SetIntersection"],
    "dynFile": ["SetIntersection"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "SetIntersection will return a new list based on the objects that both lists both contain. In the example below, a list of 0 to 9 counting by 1 is compared to a list of 0 to 18 counting by 2. Even numbers below 10 are returned because they are contained in List1 and List2."
}, {
    "Name": "SetUnion",
    "imageFile": ["SetUnion"],
    "dynFile": ["SetUnion"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "SetUnion will return a new list by combining the objects of two lists using an equality comparer (eliminate duplicate values). In the example below, a list of 0 to 9 counting by 1 is combined with a list of 0 to 18 counting by 2. The resulting list counts contains all elements from List1 and List2 with duplicates (0, 2, 4, etc) eliminated."
}, {
    "Name": "TrueForAll",
    "imageFile": ["TrueForAll"],
    "dynFile": ["TrueForAll"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Checks to see if the condition (in the predicate input) is true for ALL of the items in the list. You need to connect a node to the predicate input that returns a boolean."
}, {
    "Name": "TrueForAny",
    "imageFile": ["TrueForAny"],
    "dynFile": ["TrueForAny"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Checks to see if the condition (in the predicate input) is true for ANY of the items in the list. You need to connect a node to the predicate input that returns a boolean."
}, {
    "Name": "UniqueItems",
    "imageFile": ["UniqueItems"],
    "dynFile": ["UniqueItems"],
    "folderPath": "List/Inspect/Action",
    "inDepth": "Unique Item will remove all duplicate items from a input list. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9, with many of them repeated multiple times. After using Unique Item, we are left with a list in which each integer only occurs once. The order of the output list will be according to the first found instance of an item. "
}, {
    "Name": "CartesianProduct",
    "imageFile": ["CartesianProduct"],
    "dynFile": ["CartesianProduct"],
    "folderPath": "List/Match/Action",
    "inDepth": "Applies a combinator to each pair in the cartesian product of two sequences."
}, {
    "Name": "Combine",
    "imageFile": ["Combine"],
    "dynFile": ["Combine"],
    "folderPath": "List/Match/Action",
    "inDepth": "Combine will join multiple inputs together into a single string. In the example below, we use a Director Path to select a director. We specify a file name by using a Code Block. We then use a Combine node to join the director path and file name together into a file path."
}, {
    "Name": "LaceLongest",
    "imageFile": ["LaceLongest"],
    "dynFile": ["LaceLongest"],
    "folderPath": "List/Match/Action",
    "inDepth": "Applies a combinator to each pair resulting from a longest lacing of the input lists. All lists have their last element repeated to match the length of the longest input."
}, {
    "Name": "LaceShortest",
    "imageFile": ["LaceShortest"],
    "dynFile": ["LaceShortest"],
    "folderPath": "List/Match/Action",
    "inDepth": "Applies a combinator to each pair resulting from a shortest lacing of the input lists. All lists are truncated to the length of the shortest input."
}, {
    "Name": "Map",
    "imageFile": ["Map"],
    "dynFile": ["Map"],
    "folderPath": "List/Match/Action",
    "inDepth": "Map will return the position of a number in a range as a double. In the example below, a value of 4 is mapped to a range of 2 to 6. Since 4 is halfway between 2 and 6, a value of 0.5 is returned."
}, {
    "Name": "AddItemToEnd",
    "imageFile": ["AddItemToEnd"],
    "dynFile": ["AddItemToEnd"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Add Item to End will insert a specified item at the end of a given list. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the end of that list using AddItemToEnd."
}, {
    "Name": "AddItemToFront",
    "imageFile": ["AddItemToFront"],
    "dynFile": ["AddItemToFront"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Add Item to Front will insert a specified item at the beginning of a given list. The new item will have index 0, while the original items will all be shifted by an index of 1. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the front of that list using AddItemToFront."
}, {
    "Name": "Chop",
    "imageFile": ["Chop"],
    "dynFile": ["Chop"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Chop will split a given list into smaller lists according to a list of input integer lengths. It returns a nested list with the first list containing a number of elements equal to the first number of the list input into 'lengths', the second list containing a number of elements equal to the second number of the list input into 'lengths' and so on. Chop will repeat the last number in the 'lengths' input until all elements from the input list are chopped. In the example below, we use a code block to generate a range of numbers between 0 and 5, stepping by one. This list has 6 elements in it. We use a second code block to create a list of lengths to chop the first list into."
}, {
    "Name": "Clean",
    "imageFile": ["Clean"],
    "dynFile": ["Clean"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Clean will return a list without nulls and empty lists. In the example below, a list is cleaned of two null values, returning only the integers. The preserveIndices input can be toggled by a boolean value to keep the indices that once contained nulls."
}, {
    "Name": "Deconstruct",
    "imageFile": ["Deconstruct"],
    "dynFile": ["Deconstruct"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Deconstruct will take an input list and separate the first item in the list from the remainder. This node has two outputs. The first output is the first item of the original list. The second output is a list with the remaining elements from the original list. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Deconstruct node to separate the first item from the remainder. The result is the item '0' as one output, and a list of the range from 1 to 5 as a second output."
}, {
    "Name": "DropEveryNthItem",
    "imageFile": ["DropEveryNthItem"],
    "dynFile": ["DropEveryNthItem"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Drop Every Nth Item will remove items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will removie items with indices 2, 5, 8, etc. Changing the offset to 1 would instead remove items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To keep selected items instead of removing, see 'TakeEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then remove every other number by using 2 as the input for 'n'."
}, {
    "Name": "DropItems",
    "imageFile": ["DropItems"],
    "dynFile": ["DropItems"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Drop Items will remove the input 'amount' number of items from the list. If the 'amount' is positive, the numbers will be removed from the beginning of the list. If the 'amount' is negative, the items will be removed from the end of the list.  In the example below, we first create a list using Range, then drop the first item in the list by using Drop Item with an 'amount' of 1."
}, {
    "Name": "Filter",
    "imageFile": ["Filter"],
    "dynFile": ["Filter"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Filters a sequence by a given condition such that for an arbitrary element x, condition(x) = True or False."
}, {
    "Name": "FilterByBoolMask",
    "imageFile": ["FilterByBoolMask"],
    "dynFile": ["FilterByBoolMask"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Filter By Bool Mask takes two lists as inputs. The first list will be split into two separate lists according to a corresponding list of boolean (True or False) values. Items from the 'list' input that correspond to a True in the 'mask' input will go to the output labelled 'in', while those items that correspond to a 'False' value will go the 'out' output. In the example below, we use a modulus operator (%) and an equality operator (==) to test each item in the list for divisibility by three. The result after FilterByBoolMask is two lists, the first containing the items that are divisible by 3, and the second containing items that are not divisible by 3. "
}, {
    "Name": "Flatten",
    "imageFile": ["Flatten"],
    "dynFile": ["Flatten"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Flatten will take a nested list and flatten levels of the list by combining the first levels into a single level. The 'amt' input determines how many levels to flatten. Flatten starts from the first branch. In the example below, we first generate a range of numbers from 1 to 5, stepping by one. This creates a list of 5 elements. We use this list as the input for the lengths of a cuboid, producing a list of 5 cuboids. By exploding the cuboids, we get a list of 6 faces for each cuboid. We now have 5 lists of 6 faces, for a total of 30 elements. We go one step further by finding the edges of each face. The result is 5 lists of 6 lists of 4 edges, or a total of 120 elements. By using a Flatten node, we take the first level, the initial 5 different lists, and combine that into a single list. The resulting output is 30 lists of 4 edges. "
}, {
    "Name": "Insert",
    "imageFile": ["Insert"],
    "dynFile": ["Insert"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Insert will insert a given string into a base string at a specified index. In the example below, we start with the base string 'Hello World'. We use a second string 'Hi!' as the string to insert. An integery slider is used to control the index at which the second string will be inserted into the base string."
}, {
    "Name": "Reduce",
    "imageFile": ["Reduce"],
    "dynFile": ["Reduce"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Reduces a list into a new value by combining each element with an accumulated result."
}, {
    "Name": "RemoveIfNot",
    "imageFile": ["RemoveIfNot"],
    "dynFile": ["RemoveIfNot"],
    "folderPath": "List/Modify/Action",
    "inDepth": "RemoveIfNot will return a list with everything removed except a specified type. In the example below, a list is returned with one Line and the Point elements removed."
}, {
    "Name": "RemoveItemAtIndex",
    "imageFile": ["RemoveItemAtIndex"],
    "dynFile": ["RemoveItemAtIndex"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Remove Item At Index will take an input list of items, and create a new list by removing the items at specified indices. In the example below we start with a range of numbers from zero to five. We then remove the item with index 3."
}, {
    "Name": "ReplaceByCondition",
    "imageFile": ["ReplaceByCondition"],
    "dynFile": ["ReplaceByCondition"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Replace By Condition will take a given list and evaluate each item with a given condition. If the condition evaluates to 'true', the corresponding item will be replaced in the output list with the item specified in the replaceWith input. In the example below, we use a Formula node and enter the formula x%2==0, which finds the remainder of a given item after dividing by 2, and then checks to see if that remainder is equal to zero. This formula will return 'true' for even integers. Note that the input x is left blank. Using this formula as the condition in a ReplaceByCondition node results in an output list where each even number is replaced by the specified item, in this case the integer 10."
}, {
    "Name": "ReplaceItemAtIndex",
    "imageFile": ["ReplaceItemAtIndex"],
    "dynFile": ["ReplaceItemAtIndex"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Replace Item At Index will take an input list, a list of indices at which to replace items, and a new item to replace with. In the example below, we start with a range of numbers from zero to five. We then use a ReplaceItemAtIndex node to replace the item at index 3 with a new item, in this case the integer 10."
}, {
    "Name": "RestOfItems",
    "imageFile": ["RestOfItems"],
    "dynFile": ["RestOfItems"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Rest Of Items will remove the first element from a list and return the remaining elements in a new list. In the example below, we start with a range of numbers from zero to five. After using a RestOfItems node, the output list is a range of numbers from one to five. The first element from the original list has been removed."
}, {
    "Name": "Scan",
    "imageFile": ["Scan"],
    "dynFile": ["Scan"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Reduces a list into a new value by combining each element with an accumulated result, produces a list of successive reduced values."
}, {
    "Name": "Slice",
    "imageFile": ["Slice"],
    "dynFile": ["Slice"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Slice will return a sublist from an input last. The start input specifies which index the output list will start with. The end input specifies when to stop taking elements from the input. This end index is not included in the output list. In the example below, using a start index of 2 and an end input of 5 results in a new list consisting of the items with indices 2,3, and 4 from the orginal list."
}, {
    "Name": "Sublists",
    "imageFile": ["Sublists"],
    "dynFile": ["Sublists"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Sublists will take a input list and return a series of sublists based on the input range and offset. The range determines which elements of the input list to put into the first sublist. The offset is applied to the range, and the new range will determine the second sublist. This process repeats, increasing the range by the given offset until the resulting sublist is empty. In the example below, we start with a range of numbers from zero to nine. The range 0 to 5 is used as the sublist range, and we use an offset of 2. In the output of nested sublists, the first list contains the elements with indicies in the range 0..5, the second list contains the elements with indicies 2..7. As this is repeated, the subsequent sublists get shorter as the end of the range becomes larger than the length of the initial list."
}, {
    "Name": "TakeEveryNthItem",
    "imageFile": ["TakeEveryNthItem"],
    "dynFile": ["TakeEveryNthItem"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Drop Every Nth Item will produce a new list keeping items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will keep items with indices 2, 5, 8, etc. Changing the offset to 1 would instead keep items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To remove selected items instead of keeping them, see 'DropEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then keep every other number by using 2 as the input for 'n'."
}, {
    "Name": "TakeItems",
    "imageFile": ["TakeItems"],
    "dynFile": ["TakeItems"],
    "folderPath": "List/Modify/Action",
    "inDepth": "Take Items will return a new list with the input number of elements taking from the beginning of the input list. In the example below, we start with a range of numbers from zero to nine. We use an integer slider to specify the amount of elements to take from the original list. With an input of 4, the output list will be the first 4 elemenst from the original list."
}, {
    "Name": "GroupByFunction",
    "imageFile": ["GroupByFunction"],
    "dynFile": ["GroupByFunction"],
    "folderPath": "List/Organize/Action",
    "inDepth": "GroupByFunction will return a new list grouped by a function. In the example below, two different lists are grouped using List.GetItemAtIndex as the function. This function creates groups (a new list) from each top level index."
}, {
    "Name": "GroupByKey",
    "imageFile": ["GroupByKey"],
    "dynFile": ["GroupByKey"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Group By Key takes an input list of items to group, and a list of keys to determine how the first list is grouped. The list of keys should have the same number of elements as the input list. Items in the original list that correspond to matching keys will be grouped together in an output list. In the example below, we use a range of numbers between 0 and 9 as the input list. We also generate a list of 10 random numbers between 0 and 4 to use as the keys. GroupByKey outputs a nested list of elements, grouped according to the corresponding key. It also outputs a list of the unique keys."
}, {
    "Name": "MaximumItemByKey",
    "imageFile": ["MaximumItemByKey"],
    "dynFile": ["MaximumItemByKey"],
    "folderPath": "List/Organize/Action",
    "inDepth": "MaximumItemByKey will return the largest item in a list based on a key. In the example below, a series of three circles with increasing radii are compared using radius as the key. The circle at (5,0,0) is returned as it has the largest radius."
}, {
    "Name": "MinimumItemByKey",
    "imageFile": ["MinimumItemByKey"],
    "dynFile": ["MinimumItemByKey"],
    "folderPath": "List/Organize/Action",
    "inDepth": "MinimumItemByKey will return the smallest item in a list based on a key. In the example below, a series of three circles with increasing radii are compared using radius as the key. The circle at the origin is returned as it has the smallest radius."
}, {
    "Name": "NormalizeDepth",
    "imageFile": ["NormalizeDepth"],
    "dynFile": ["NormalizeDepth"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Returns multidimensional list according the rank given."
}, {
    "Name": "Reorder",
    "imageFile": ["Reorder"],
    "dynFile": ["Reorder"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Reorder will return a new list based on a different order of the original list's indices. In the example below, a new list is created by manually changing the index order."
}, {
    "Name": "Reverse",
    "imageFile": ["Reverse"],
    "dynFile": ["Reverse"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Reverse will return a new Vector pointing in the opposite direction from its input. In the example below, a Vector of (1,0,1) will return a Vector of (-1,0,-1). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different reversed vector. The Vectors are represented as Lines."
}, {
    "Name": "ShiftIndices",
    "imageFile": ["ShiftIndices"],
    "dynFile": ["ShiftIndices"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Shift Indices will shift the position of the items in a list by the 'amount' input. A positive amount will shift the numbers up, while a negative amount will shift the indices backwards. The items wrap around, causing items at the back of the list to wrap to the beginning. In the example we first generate a list with Range, then shift the indices forward by 3."
}, {
    "Name": "Shuffle",
    "imageFile": ["Shuffle"],
    "dynFile": ["Shuffle"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Shuffle will take an input list and randomize the order of the items. In the example, we first generate a list using Range, and then use Shuffle to produce a randomized list."
}, {
    "Name": "Sort",
    "imageFile": ["Sort"],
    "dynFile": ["Sort"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Sort will sort a list of items according to the built-in ordering for the data type. For example, a list of numbers will be sorted into numerical order from least to greatest, while a list of strings will be sorted alphabetically. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9. Sort then creates a sorted list from least to greatest."
}, {
    "Name": "SortByFunction",
    "imageFile": ["SortByFunction"],
    "dynFile": ["SortByFunction"],
    "folderPath": "List/Organize/Action",
    "inDepth": "SortByFunction will return a list sorted by a function. In the example below, a line is drawn through a list of randomly placed points that have been sorted with different functions. The first curve through an unsorted list is non-directional. Sorting the list using the X or Y component of each point results in directional lines progressing across X or Y."
}, {
    "Name": "SortByKey",
    "imageFile": ["SortByKey"],
    "dynFile": ["SortByKey"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Sort By Key takes an input list to sort, and a list of corresponding sortable keys. Sort By Key will sort the list of keys in ascending order, and will rearrange the input list to correspond to the new order of the sorted keys. This node outputs both the rearranged list, and the sorted list of keys. In the example below, we use a range from zero to nine as our input list. For the list of keys, we generate a list of 10 random numbers between zero and four. The list of keys is sorted numerically, while the range from 0 to 9 is rearranged according to the order of the corresponding elements from the list of keys."
}, {
    "Name": "SortIndexByValue",
    "imageFile": ["SortIndexByValue"],
    "dynFile": ["SortIndexByValue"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Sorts a list by the items and return their indices."
}, {
    "Name": "Transpose",
    "imageFile": ["Transpose"],
    "dynFile": ["Transpose"],
    "folderPath": "List/Organize/Action",
    "inDepth": "Transpose will take a list a lists and swap the rows and columns. For example, a list that contains 5 sub-lists of 10 items each would be transposed to 10 lists of 5 items each. In the example, we generate two Random Lists, and then use List.Create to combine them. The result is two lists with 3 and 4 items. Transpose switches this to 4 lists of 2 items each. Notice that since one of the original lists was longer than the other, Transpose inserted a null value for the unpaired item."
}, {
    "Name": "Abs (number)",
    "imageFile": ["Abs (number)"],
    "dynFile": ["Abs (number)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Abs will return the absolute value of an input value. In the example below, we use a number slider to control the input to an Abs node."
}, {
    "Name": "Abs (integer)",
    "imageFile": ["Abs (integer)"],
    "dynFile": ["Abs (integer)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Abs will return the absolute value of an input value. In the example below, we use an integer slider to control the input to an Abs node."
}, {
    "Name": "Acos",
    "imageFile": ["Acos"],
    "dynFile": ["Acos"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Acos will return the inverse cosine, also known as the ArcCosine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Acos node."
}, {
    "Name": "Asin",
    "imageFile": ["Asin"],
    "dynFile": ["Asin"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Asin will return the inverse sine, also known as the ArcSine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Asin node."
}, {
    "Name": "Atan",
    "imageFile": ["Atan"],
    "dynFile": ["Atan"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Atan will return the inverse sine, also known as the ArcTangent, of an input number. This output angle is returned in degrees. In the example below we use a number slider to control the input to an Atan node."
}, {
    "Name": "Atan2",
    "imageFile": ["Atan2"],
    "dynFile": ["Atan2"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Atan2 will return the inverse sine, also known as the ArcTangen, of the ratio of an input numerator and denomnator. This output angle is returned in degrees. In the example below we use two number sliders to control the inputs to an Atan2 node."
}, {
    "Name": "Average",
    "imageFile": ["Average"],
    "dynFile": ["Average"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Average will return the average (arithmetic mean) of a list of numbers. In the example below, we first use three number sliders to create three numbers to find the average of. We then use a List.Create node combine these three numbers into a list that we can then use as the input for an Average node."
}, {
    "Name": "Ceiling",
    "imageFile": ["Ceiling"],
    "dynFile": ["Ceiling"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Ceiling will find the nearest integer that greater than an input number. This can also be thought of as rounding up to the nearest integer. In the example below, we use a number slider to control the input to a Ceiling node."
}, {
    "Name": "Cos",
    "imageFile": ["Cos"],
    "dynFile": ["Cos"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Cos will return the cosine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Cos node."
}, {
    "Name": "Cosh",
    "imageFile": ["Cosh"],
    "dynFile": ["Cosh"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Cosh will return the hyperbolic cosine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Cosh node."
}, {
    "Name": "DivRem",
    "imageFile": ["DivRem"],
    "dynFile": ["DivRem"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "DivRem will return the remainder of an input number after dividing by a given divisor. This is also known as Modulus, and is equivalent to the operator '%'. In the example below, we use two number sliders to set the dividend and divisor for a DivRem node."
}, {
    "Name": "EvaluateFormula",
    "imageFile": ["EvaluateFormula"],
    "dynFile": ["EvaluateFormula"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Evaluates an NCalc formula with given parameter mappings."
}, {
    "Name": "Exp",
    "imageFile": ["Exp"],
    "dynFile": ["Exp"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Exp is the exponential function with a base of 'e'. The input number is applied as an exponent to the constant 'e'. In the example below we use a number slider to control the input number to an Exp node. "
}, {
    "Name": "Factorial",
    "imageFile": ["Factorial"],
    "dynFile": ["Factorial"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Factorial will return the factorial of an input positive integer. If a decimal value is input, factorial will first round the input to the nearest integer. In the example below we use a number slider to control the input to a Factorial node."
}, {
    "Name": "Floor",
    "imageFile": ["Floor"],
    "dynFile": ["Floor"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Floor will find the nearest integer that less than an input number. This can also be thought of as rounding down to the nearest integer. In the example below, we use a number slider to control the input to a Floo node."
}, {
    "Name": "Formula",
    "imageFile": ["Formula"],
    "dynFile": ["Formula"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Evaluates mathematical formulas. Uses NCalc: http://ncalc.codeplex.com/"
}, {
    "Name": "Log (number, logBase)",
    "imageFile": ["Log (number, logBase)"],
    "dynFile": ["Log (number, logBase)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Log with logBase allows the use to specify the base to use for a logarithm with the logBase input. In the example below, we use two number sliders, one to control the input number to find the logarithm of and a second number slider to set the base of the logarithm."
}, {
    "Name": "Log (number)",
    "imageFile": ["Log (number)"],
    "dynFile": ["Log (number)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Log will return the natural log (base e) of an input number. In the example below, we use a number slider to control the input to a Log node."
}, {
    "Name": "Log10",
    "imageFile": ["Log10"],
    "dynFile": ["Log10"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Log10 will return the log base 10 of an input number. In the example below, we use a number slider to control the input to a Log10 node."
}, {
    "Name": "Map",
    "imageFile": ["Map"],
    "dynFile": ["Map"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Map will return the position of a number in a range as a double. In the example below, a value of 4 is mapped to a range of 2 to 6. Since 4 is halfway between 2 and 6, a value of 0.5 is returned."
}, {
    "Name": "MapTo",
    "imageFile": ["MapTo"],
    "dynFile": ["MapTo"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "MapTo will get the position of a number in a range (similar to the Map node), then map that position to a target range. A number in the target range is returned based on the position value. In the example below, the number 3 returns a position of 0.5 between a range of 2 and 4. That position value of 0.5 in a target range of 20 to 100 returns the number 60."
}, {
    "Name": "Max (int1, int2)",
    "imageFile": ["Max (int1, int2)"],
    "dynFile": ["Max (int1, int2)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Max will return the greater of two input integers. In the example below, we use two integer sliders to control the inputs to a Max node."
}, {
    "Name": "Max (value1, value2)",
    "imageFile": ["Max (value1, value2)"],
    "dynFile": ["Max (value1, value2)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Max will return the greater of two input number. In the example below, we use two number sliders to control the inputs to a Max node."
}, {
    "Name": "Min (int1, int2)",
    "imageFile": ["Min (int1, int2)"],
    "dynFile": ["Min (int1, int2)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Min will return the lesser of two input integers. In the example below, we use two integer sliders to control the inputs to a Min node."
}, {
    "Name": "Min (value1, value2)",
    "imageFile": ["Min (value1, value2)"],
    "dynFile": ["Min (value1, value2)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Min will return the lesser of two input number. In the example below, we use two number sliders to control the inputs to a Min node."
}, {
    "Name": "Pow",
    "imageFile": ["Pow"],
    "dynFile": ["Pow"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Pow will return the result of an input number raised to an input power. In the example below, we use two number sliders to control the two inputs to a Pow node."
}, {
    "Name": "Rand",
    "imageFile": ["Rand"],
    "dynFile": ["Rand"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Rand will generate a random number in the range 0 to 1. Each instance of Rand will produce a different random number, but the number for a specific instance will remain constant."
}, {
    "Name": "Random (value1, value2)",
    "imageFile": ["Random (value1, value2)"],
    "dynFile": ["Random (value1, value2)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Random with two value inputs allows the user to control the range of the generated random number. It will produce a random number between the two input values. In the example below, we use two number sliders to control the two inputs into a Random node."
}, {
    "Name": "Random (seed)",
    "imageFile": ["Random (seed)"],
    "dynFile": ["Random (seed)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Random with a given seed allows the user to input a seed number to produce a pseudo-random number. Every Rand node with the same seed number will produce the same pseudo-random number. In the example below, we use an integer slider as the input seed into a Rand node."
}, {
    "Name": "RandomList",
    "imageFile": ["RandomList"],
    "dynFile": ["RandomList"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "RandomList will generate a list of random numbers in the range 0 to 1. The amount of random to generate is controlled by a number slider."
}, {
    "Name": "RemapRange",
    "imageFile": ["RemapRange"],
    "dynFile": ["RemapRange"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "RemapRange will take a list of numbers and produce a linear scaling of those numbers into a new specified range. The minimum value of the original list is mapped to the newMin input, while the maximum value of the orginila list is mapped to the newMax input. The remaining numbers are scaled to maintain the distribution ratio. In the example below, we use a RandomList node to generate a list of numbers to remap. We use two number sliders to control the new minimum and maximum values of the resulting list."
}, {
    "Name": "Round (number, digits)",
    "imageFile": ["Round (number, digits)"],
    "dynFile": ["Round (number, digits)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Round with digits allows the user to select the number of decimal places to round the input number to. An input of zero will round to the nearest whole number. Values less than zero are not permitted. In the example below, we use a Rand node to generate a random number. An integer slider is used to control the 'digits' input in a Round node."
}, {
    "Name": "Round (number)",
    "imageFile": ["Round (number)"],
    "dynFile": ["Round (number)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Round will round the input number to the nearest integer. In the example below, we use a number slider to control the input to a Round node."
}, {
    "Name": "Sign (number)",
    "imageFile": ["Sign (number)"],
    "dynFile": ["Sign (number)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
}, {
    "Name": "Sign (integer)",
    "imageFile": ["Sign (integer)"],
    "dynFile": ["Sign (integer)"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
}, {
    "Name": "Sin",
    "imageFile": ["Sin"],
    "dynFile": ["Sin"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sin will return the sine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Sin node."
}, {
    "Name": "Sinh",
    "imageFile": ["Sinh"],
    "dynFile": ["Sinh"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sinh will return the hyperbolic sine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Sinh node."
}, {
    "Name": "Sqrt",
    "imageFile": ["Sqrt"],
    "dynFile": ["Sqrt"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sqrt will return the square root of an input number. Sqrt will only accept positive numbers. In the example below we use a number slider to control the input to a Sqrt node."
}, {
    "Name": "Sum",
    "imageFile": ["Sum"],
    "dynFile": ["Sum"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Sum will find the sum of the values of an input list. In the example below, we use three number sliders to create three numbers. We then use a List.Create node to combine them into a list that can be used as the input to a Sum node."
}, {
    "Name": "Tan",
    "imageFile": ["Tan"],
    "dynFile": ["Tan"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Tan will return the tangent of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Tan node."
}, {
    "Name": "Tanh",
    "imageFile": ["Tanh"],
    "dynFile": ["Tanh"],
    "folderPath": "Math/Functions/Action",
    "inDepth": "Tanh will return the hyperbolic tangent of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Tanh node."
}, {
    "Name": "E",
    "imageFile": ["E"],
    "dynFile": ["E"],
    "folderPath": "Math/Functions/Query",
    "inDepth": "E will return the constant e = 2.71828..."
}, {
    "Name": "GoldenRatio",
    "imageFile": ["GoldenRatio"],
    "dynFile": ["GoldenRatio"],
    "folderPath": "Math/Functions/Query",
    "inDepth": "GoldenRatio will return the golden ratio constant, also known as 'phi', equal to 1.61803... "
}, {
    "Name": "PI",
    "imageFile": ["PI"],
    "dynFile": ["PI"],
    "folderPath": "Math/Functions/Query",
    "inDepth": "Pi will return the constant pi = 3.14159265..."
}, {
    "Name": "PiTimes2",
    "imageFile": ["PiTimes2"],
    "dynFile": ["PiTimes2"],
    "folderPath": "Math/Functions/Query",
    "inDepth": "PiTimes2 will return the constant pi multiplied by 2 = 6.28318..."
}, {
    "Name": "And",
    "imageFile": ["And"],
    "dynFile": ["And"],
    "folderPath": "Math/Logic/Action",
    "inDepth": "And will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the And node. Each input must be a single boolean value. And will return 'true' if all of the inputs are true, otherwise it will return 'false'. In the example below, we have three boolean toggles used as inputs for an And node. When all three are set to 'true', And will return 'true'."
}, {
    "Name": "Or",
    "imageFile": ["Or"],
    "dynFile": ["Or"],
    "folderPath": "Math/Logic/Action",
    "inDepth": "Or will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the Or node. Each input must be a single boolean value. Or will return 'true' if at least one of the inputs are true, otherwise if all inputs are 'false', it will return 'false'. In the example below, we have three boolean toggles used as inputs for an Or node. When all three are set to 'false', Or will return 'false'."
}, {
    "Name": "Xor",
    "imageFile": ["Xor"],
    "dynFile": ["Xor"],
    "folderPath": "Math/Logic/Action",
    "inDepth": "Xor will accept two boolean values, or two lists of boolean values and determines whether the values are the same or different. Xor compares two values and returns 'true' if exactly one of the inputs is 'true'. If both values are 'true' or if both values are 'false', Xor will return 'false'. In the example below, we start with two lists of boolean values. Together, these lists represent the four possible combinations of true and false values. Notice that unlike And and Or nodes, Xor only allows two values."
}, {
    "Name": "!=",
    "imageFile": ["NotEqualTo"],
    "dynFile": ["NotEqualTo"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "!= is the Not Equal To operator. It takes two input values and returns true if the two values are not equal to each other and returns false if the two values are equal. In the example below, we use two number sliders to control the inputs to a != operator."
}, {
    "Name": "%",
    "imageFile": ["Modulo", "Modulo - Ex 2"],
    "dynFile": ["Modulo", "Modulo - Ex 2"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "% is the Modulo operator. It returns the remainder of the x input after being divided by the y input. In the example below, we use two number sliders to control the inputs to a % operator."
}, {
    "Name": "&&",
    "imageFile": ["And"],
    "dynFile": ["And"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "&& is the And operator. It takes two boolean values as input and returns true if both values are true. If one or both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the && operator."
}, {
    "Name": "*",
    "imageFile": ["Multiply"],
    "dynFile": ["Multiply"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "* is the multiplication operator. It will return the product of the two input numbers. In the example below, we use two number sliders to control the inputs to the * operator."
}, {
    "Name": "+",
    "imageFile": ["Add"],
    "dynFile": ["Add"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "+ is the addition operator. It will return the sum ofy the two input numbers. In the example below, we use two number sliders to control the inputs to the + operator."
}, {
    "Name": "-",
    "imageFile": ["Subtract"],
    "dynFile": ["Subtract"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "- is the subtraction operator. It will return the result of the y input subtracted from the x input. In the example below, we use two number sliders to control the inputs to the - operator."
}, {
    "Name": "/",
    "imageFile": ["Divide"],
    "dynFile": ["Divide"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "/ is the division operator. It will return the result of the x input divided by the y input. In the example below, we use two number sliders to control the inputs to the / operator."
}, {
    "Name": "<",
    "imageFile": ["LessThan"],
    "dynFile": ["LessThan"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "< is the Less Than operator. If the x input is less than the y input, it will return true. If x is greater than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the < operator."
}, {
    "Name": "<=",
    "imageFile": ["LessThanOrEqualTo"],
    "dynFile": ["LessThanOrEqualTo"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "<= is the Less Than Or Equal To operator. If the x input is less than the y input, or if the two values are equal, it will return true. If x is greater than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the <= operator."
}, {
    "Name": "==",
    "imageFile": ["EqualTo"],
    "dynFile": ["EqualTo"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "== is the Equal To operator. If the x input is equal to the y input, it will return true. If the two values are not equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the == operator."
}, {
    "Name": ">",
    "imageFile": ["GreaterThan"],
    "dynFile": ["GreaterThan"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "> is the Greater Than operator. If the x input is greater than the y input, it will return true. If x is less than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the > operator."
}, {
    "Name": ">=",
    "imageFile": ["GreaterThanOrEqualTo"],
    "dynFile": ["GreaterThanOrEqualTo"],
    "folderPath": "Math/Operators/Action",
    "inDepth": ">= is the Greater Than Or Equal To operator. If the x input is greater than the y input, or if the two values are equal, it will return true. If x is less than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the >= operator."
}, {
    "Name": "Not",
    "imageFile": ["Not"],
    "dynFile": ["Not"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "Not (also written as exclamation point) will return the opposite of an input boolean value. In the example below, we use a boolean toggle node as the input to a Not operator."
}, {
    "Name": "||",
    "imageFile": ["Or"],
    "dynFile": ["Or"],
    "folderPath": "Math/Operators/Action",
    "inDepth": "|| is the Or operator. It takes two boolean values as input and returns true if one or both values are true. If both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the || operator."
}, {
    "Name": "Convert Between Units",
    "imageFile": ["Convert Between Units"],
    "dynFile": ["Convert Between Units"],
    "folderPath": "Math/Units/Action",
    "inDepth": "Convert Between Units will return a converted value based on input and output units. In the example below, 4 meters is converted to feet returning a value of ~13.1234."
}, {
    "Name": "DegreesToRadians",
    "imageFile": ["DegreesToRadians"],
    "dynFile": ["DegreesToRadians"],
    "folderPath": "Math/Units/Action",
    "inDepth": "DegreesToRadians will convert an input angle from degrees to radians. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a DegreesToRadians node."
}, {
    "Name": "Number From Feet and Inches",
    "imageFile": ["Number From Feet and Inches"],
    "dynFile": ["Number From Feet and Inches"],
    "folderPath": "Math/Units/Action",
    "inDepth": "Number From Feet and Inches will return a double from feet and inches inputs. In the example below, 2ft 1in returns a double of 2.08333"
}, {
    "Name": "RadiansToDegrees",
    "imageFile": ["RadiansToDegrees"],
    "dynFile": ["RadiansToDegrees"],
    "folderPath": "Math/Units/Action",
    "inDepth": "RadiansToDegrees will convert an input angle from radians to degrees. In the example below, we use a number slider to control the input angle to a RadiansToDegrees node."
}, {
    "Name": "Unit Types",
    "imageFile": ["Unit Types"],
    "dynFile": ["Unit Types"],
    "folderPath": "Math/Units/Action",
    "inDepth": "Select a unit of measurement."
}, {
    "Name": "If",
    "imageFile": ["If", "If - Ex 2"],
    "dynFile": ["If", "If - Ex 2"],
    "folderPath": "Script/Control Flow/Action",
    "inDepth": "If acts as a conditional control node. The 'test' input takes a boolean value, while the 'true' and 'false' inputs can accept any data type. If the test value is 'true', the node will return the item from the 'true' input, if test is 'false', the node will return the item from the 'false' input. In the example below, we first generate a list of random numbers between zero and 99. The number of items in the list is controlled by an integer slider. We use a code block with the formula 'x%a==0' to test for divisibility by a second number, determined by a second number slider. This generates a list of boolean values corresponding to whether the items in the random list are divisible by the number determined by the second integer slider. This list of boolean values is used as the 'test' input for an If node. We use a default Sphere as the 'true' input, and a default Cuboid as the 'false' input. The result from the If node is a list of either spheres or cuboids. Finally, we use a Translate node to spread the list of geometries apart.\n\nIF replicates on all nodes AS THOUGH SET TO SHORTEST. You can see the reason for this in the attached examples, especially when looking at what the results are when LONGEST is applied to a formula node and the \"short\" branch of the conditional is passes through. These changes were also made to allow predictable behavior when using single boolean inputs or a list of booleans."
}, {
    "Name": "LoopWhile",
    "imageFile": ["LoopWhile"],
    "dynFile": ["LoopWhile"],
    "folderPath": "Script/Control Flow/Action",
    "inDepth": "LoopWhile will return the result of a looped function until the constraints are met. In the example below, a simple loop is created to add 10, starting with 1, until the result is larger than 100. loopWhile accepts variables for its init input and functions for the continueWhile and loopBody inputs. continueWhile defines the constraints of the loop, which in this example is a < function and an argument of 100. loopBody defines what the loop does, which in this example is an + function with an argument of 10."
}, {
    "Name": "Pause",
    "imageFile": ["Pause.gif"],
    "dynFile": ["Pause"],
    "folderPath": "Script/Control Flow/Action",
    "inDepth": "Pause will return the result of a node after pausing the thread for a specified amount of time. In the example below, a circle is extruded into a surface 5 seconds after the thread is run. To use the time delay, the program should be run in Manual."
}, {
    "Name": "ScopeIf",
    "imageFile": ["ScopeIf"],
    "dynFile": ["ScopeIf"],
    "folderPath": "Script/Control Flow/Action",
    "inDepth": "ScopeIf will return the input of either the True or False input depending on what boolean value is toggled in the test input. In the example file below, a large and small list of numbers is plugged into the true and false inputs. By sending the result of ScopeIfThrough a point creation node, we can toggle between two different sizes of point grids."
}, {
    "Name": "Code Block",
    "imageFile": ["Code Block"],
    "dynFile": ["Code Block"],
    "folderPath": "Script/Editor/Action",
    "inDepth": "The Code Block is universal and can be useful in all definitions. With this node, we can fully customize the Dynamo functionality and experience by coding directly into the graph. In this example, we see a range of possible uses including Numbers, Strings, Booleans for item based code, and Ranges and Sequences for creating lists of values."
}, {
    "Name": "Python Script",
    "imageFile": ["Python Script"],
    "dynFile": ["Python Script"],
    "folderPath": "Script/Editor/Action",
    "inDepth": "Python Script will return the result of the node's inputs passed through an embedded IronPython script. In the example below, a cube created from Cuboid.ByCorners is arrayed and translated by a Python script that loops through both X and Y. Double clicking the node will bring up an editor for the script."
}, {
    "Name": "Python Script From String",
    "imageFile": ["Python Script From String"],
    "dynFile": ["Python Script From String"],
    "folderPath": "Script/Editor/Action",
    "inDepth": "Python Script From String will return the result of the node's inputs passed through a string Python script. In the example below, a Python script is retrieved from a text file and converted into a string. A cube created from Cuboid.ByCorners is arrayed and translated by the Python script by looping through both X and Y."
}, {
    "Name": "Function Apply",
    "imageFile": ["Function Apply"],
    "dynFile": ["Function Apply"],
    "folderPath": "Script/Evaluate/Action",
    "inDepth": "Function.Apply will return the result of a function with supplied arguments. In the example below, arguments of a point and vector are applied to a translate function returning a translated point."
}, {
    "Name": "Function Compose",
    "imageFile": ["Function Compose"],
    "dynFile": ["Function Compose"],
    "folderPath": "Script/Evaluate/Action",
    "inDepth": "Function.Compose will return a single function from multiple functions. In the example below, the modulus and divide functions are composed into a single function to apply to a list."
}, {
    "Name": "Concat",
    "imageFile": ["Concat"],
    "dynFile": ["Concat"],
    "folderPath": "String/Generate/Action",
    "inDepth": "Concat will concatenate multiple strings together into a single string. The number of input strings can be changed by using the '+' and '-' buttons on the Concat node. In the example below, we start with two separate strings 'Hello' and 'World'. They are concatenated together to 'HelloWorld' using the Concat node."
}, {
    "Name": "Join",
    "imageFile": ["Join"],
    "dynFile": ["Join"],
    "folderPath": "String/Generate/Action",
    "inDepth": "Join will concatenate a series of strings together into a single string using a specified separator string between them. In the example below, we use an underscore character as the separator. We create three strings to concatenate together. The number of string inputs this node will accept can be changed by using the '+' and '-' buttons on the node."
}, {
    "Name": "String from Array",
    "imageFile": ["String from Array"],
    "dynFile": ["String from Array"],
    "folderPath": "String/Generate/Action",
    "inDepth": "Convert an array to a string representation."
}, {
    "Name": "String from Object",
    "imageFile": ["String from Object"],
    "dynFile": ["String from Object"],
    "folderPath": "String/Generate/Action",
    "inDepth": "String representation of input object."
}, {
    "Name": "AllIndicesOf",
    "imageFile": ["AllIndicesOf"],
    "dynFile": ["AllIndicesOf"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Returns all the 0 based indices of the character in the string."
}, {
    "Name": "Contains",
    "imageFile": ["Contains"],
    "dynFile": ["Contains"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Bounding Box Contains tests if a specified Point is inside of a Bounding Box. Because the Point in this example is at (5,5,5), and our Origin Sphere’s Radius is larger than 5, the Contains node will return True."
}, {
    "Name": "CountOccurrences",
    "imageFile": ["CountOccurrences"],
    "dynFile": ["CountOccurrences"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Count Occurrences will search a given string for a second input string, and will return the number of times that second string is found within the first string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we using the string 'Hello World' and search for the string 'L'. Because ignoreCase is set to true, the CountOccurrences finds the given string three times within 'Hello World'."
}, {
    "Name": "EndsWith",
    "imageFile": ["EndsWith"],
    "dynFile": ["EndsWith"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Ends With will return a boolean value based on whether a given string ends with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'orld' as the string to search for. Because 'Hello World' ends in the string 'orld', the EndsWith node returns true."
}, {
    "Name": "IndexOf",
    "imageFile": ["IndexOf"],
    "dynFile": ["IndexOf"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "IndexOf will search a given string for a second input string. If the second string is found, this node will return the index of the first character of the first occurrence of the string.  By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the character 'o', This letter occurs twice in the string, but only the index of the first occurrence is returned by the IndexOf node."
}, {
    "Name": "LastIndexOf",
    "imageFile": ["LastIndexOf"],
    "dynFile": ["LastIndexOf"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Last Index Of will search a given string for a second input string. If the second string is found, this node will return the index of the last occurrence. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the string 'o'. This string is found twice within the base string, and the index of the final occurrence of the string is returned."
}, {
    "Name": "Length",
    "imageFile": ["Length"],
    "dynFile": ["Length"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Length returns the length of a curtain panel's boundary as a double. This can be used even if the curtain panel is not rectangular."
}, {
    "Name": "StartsWith",
    "imageFile": ["StartsWith"],
    "dynFile": ["StartsWith"],
    "folderPath": "String/Inspect/Action",
    "inDepth": "Starts With will return a boolean value based on whether a given string starts with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'h' as the string to search for. Because 'Hello World' starts with the string 'h' and ignoreCase is set to true, the StartsWith node returns true."
}, {
    "Name": "Center",
    "imageFile": ["Center"],
    "dynFile": ["Center"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Polygon Center finds the center of a given polygon by taking the average value of the corners. For concave polygons, it's possible that the center may actually lie outside the polygon. In the example below, we first generate a list of random angles and radii to use as inputs to Point By Cylindrical Coordinates. By sorting the angles first, we ensure that the resulting polygon will be connected in order of increasing angle, and therefore will not be self-intersecting. We can then use Center to take the average of the points and find the polygon center."
}, {
    "Name": "ChangeCase",
    "imageFile": ["ChangeCase"],
    "dynFile": ["ChangeCase"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Change Case takes a string and a boolean value as input. If the boolean input is 'true', it will change the input string to upper case. If the boolean input is false, it will change the input string to lower case. In the example below, we use an example string 'Hello World' as the input string, and a boolean toggle to specify whether to change the string to all upper case or all lower case letters."
}, {
    "Name": "Insert",
    "imageFile": ["Insert"],
    "dynFile": ["Insert"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Insert will insert a given string into a base string at a specified index. In the example below, we start with the base string 'Hello World'. We use a second string 'Hi!' as the string to insert. An integery slider is used to control the index at which the second string will be inserted into the base string."
}, {
    "Name": "PadLeft",
    "imageFile": ["PadLeft"],
    "dynFile": ["PadLeft"],
    "folderPath": "String/Modify/Action",
    "inDepth": "PadLeft will increase the width of an input string according to the newWidth input by adding the padChars input on the left side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
}, {
    "Name": "PadRight",
    "imageFile": ["PadRight"],
    "dynFile": ["PadRight"],
    "folderPath": "String/Modify/Action",
    "inDepth": "PadRight will increase the width of an input string according to the newWidth input by adding the padChars input on the right side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
}, {
    "Name": "Remove",
    "imageFile": ["Remove"],
    "dynFile": ["Remove"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Remove takes a string as input, and will remove characters from that string starting at the 'startIndex' input. The number of characters to be removed is specified by the 'count' index. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control the startIndex and count of the characters to be removed by a Remove node."
}, {
    "Name": "Replace",
    "imageFile": ["Replace"],
    "dynFile": ["Replace"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Replace will search a given string for a second input string. If that string is found, it will be replaced by a third input string. This node is case sensitive. In the example below, we start with the string 'Hello World'. The string 'o' is used as the string to search for, and a third string 'Hi!' is input as the string to replace with. Because the letter 'o' occurs twice within the original string, it is replaced in both occurrence with the string 'Hi!'."
}, {
    "Name": "Split",
    "imageFile": ["Split"],
    "dynFile": ["Split"],
    "folderPath": "String/Modify/Action",
    "inDepth": "The Geometry Split Node functions similarly to the Geometry Trim Node. It inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, and returns all of the fragments of Geometry. In this example, a Cone is Split with a similar Cone. Although all fragments are returned by the Geometry Split Node, one is previewed in the example file."
}, {
    "Name": "Substring",
    "imageFile": ["Substring"],
    "dynFile": ["Substring"],
    "folderPath": "String/Modify/Action",
    "inDepth": "Substring takes an input string and returns a sub string based on the start index and length inputs. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control where to start the substring and how many characters to take."
}, {
    "Name": "ToLower",
    "imageFile": ["ToLower"],
    "dynFile": ["ToLower"],
    "folderPath": "String/Modify/Action",
    "inDepth": "To Lower will convert an input string to lower case letters. In the example below we start with the string 'Hello World'. By using a ToLower node, we change this string to 'hello world'."
}, {
    "Name": "ToNumber",
    "imageFile": ["ToNumber"],
    "dynFile": ["ToNumber"],
    "folderPath": "String/Modify/Action",
    "inDepth": "To Number will convert an input string to a number data type. This node requires a string that has the format of a number. In the example below, we can see that the string 'Hello World' cannot be converted to a number, while the string '5.2' can be converted to number 5.2 "
}, {
    "Name": "ToUpper",
    "imageFile": ["ToUpper"],
    "dynFile": ["ToUpper"],
    "folderPath": "String/Modify/Action",
    "inDepth": "To Upper will convert an input string to upper case letters. In the example below we start with the string 'Hello World'. By using a ToUpper node, we change this string to 'HELLO WORLD'."
}, {
    "Name": "TrimLeadingWhitespace",
    "imageFile": ["TrimLeadingWhitespace"],
    "dynFile": ["TrimLeadingWhitespace"],
    "folderPath": "String/Modify/Action",
    "inDepth": "TrimLeadingWhitespace will remove the whitespace at the beginning of an input string. In the example below, we start with the string '     Hello World', which has several leading and trailing spaces. By using TrimLeadingWhitespace, we can remove the spaces at the beginning of the string."
}, {
    "Name": "TrimTrailingWhitespace",
    "imageFile": ["TrimTrailingWhitespace"],
    "dynFile": ["TrimTrailingWhitespace"],
    "folderPath": "String/Modify/Action",
    "inDepth": "TrimTrailingWhitespace will remove the whitespace at the end of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrimTrailingWhitespace, we can remove the spaces at the end of the string."
}, {
    "Name": "TrimWhitespace",
    "imageFile": ["TrimWhitespace"],
    "dynFile": ["TrimWhitespace"],
    "folderPath": "String/Modify/Action",
    "inDepth": "TrimWhitespace will remove all the whitespace of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrigWhitespace, we can remove the spaces at the beginning and end of the string, as well as the space between 'Hello' and 'World'."
}
]
