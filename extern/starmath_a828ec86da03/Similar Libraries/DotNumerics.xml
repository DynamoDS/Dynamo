<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNumerics</name>
    </assembly>
    <members>
        <member name="M:DotNumerics.Optimization.LBFGSB.SUBSM.Run(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double,System.Int32,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32@)">
             <param name="N">
             is an integer variable.
             On entry n is the dimension of the problem.
             On exit n is unchanged.
            </param>
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric corrections
             used to define the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="NSUB">
             is an integer variable.
             On entry nsub is the number of free variables.
             On exit nsub is unchanged.
            </param>
             <param name="IND">
             is an integer array of dimension nsub.
             On entry ind specifies the coordinate indices of free variables.
             On exit ind is unchanged.
            </param>
             <param name="L">
             is a double precision array of dimension n.
             On entry l is the lower bound of x.
             On exit l is unchanged.
            </param>
             <param name="U">
             is a double precision array of dimension n.
             On entry u is the upper bound of x.
             On exit u is unchanged.
            </param>
             <param name="NBD">
             is a integer array of dimension n.
             On entry nbd represents the type of bounds imposed on the
             variables, and must be specified as follows:
             nbd(i)=0 if x(i) is unbounded,
             1 if x(i) has only a lower bound,
             2 if x(i) has both lower and upper bounds, and
             3 if x(i) has only an upper bound.
             On exit nbd is unchanged.
            </param>
             <param name="X">
             is a double precision array of dimension n.
             On entry x specifies the Cauchy point xcp. 
             On exit x(i) is the minimizer of Q over the subspace of
             free variables. 
            </param>
             <param name="D">
             = -(Z'BZ)^(-1) r.
             
             The formula for the Newton direction, given the L-BFGS matrix
             and the Sherman-Morrison formula, is
             
             d = (1/theta)r + (1/theta*2) Z'WK^(-1)W'Z r.
             
             where
             K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
             [L_a -R_z           theta*S'AA'S ]
             
             Note that this procedure for computing d differs 
             from that described in [1]. One can show that the matrix K is
             equal to the matrix M^[-1]N in that paper.
             
             n is an integer variable.
             On entry n is the dimension of the problem.
             On exit n is unchanged.
             
             m is an integer variable.
             On entry m is the maximum number of variable metric corrections
             used to define the limited memory matrix.
             On exit m is unchanged.
             
             nsub is an integer variable.
             On entry nsub is the number of free variables.
             On exit nsub is unchanged.
             
             ind is an integer array of dimension nsub.
             On entry ind specifies the coordinate indices of free variables.
             On exit ind is unchanged.
             
             l is a double precision array of dimension n.
             On entry l is the lower bound of x.
             On exit l is unchanged.
             
             u is a double precision array of dimension n.
             On entry u is the upper bound of x.
             On exit u is unchanged.
             
             nbd is a integer array of dimension n.
             On entry nbd represents the type of bounds imposed on the
             variables, and must be specified as follows:
             nbd(i)=0 if x(i) is unbounded,
             1 if x(i) has only a lower bound,
             2 if x(i) has both lower and upper bounds, and
             3 if x(i) has only an upper bound.
             On exit nbd is unchanged.
             
             x is a double precision array of dimension n.
             On entry x specifies the Cauchy point xcp. 
             On exit x(i) is the minimizer of Q over the subspace of
             free variables. 
             
             d is a double precision array of dimension n.
             On entry d is the reduced gradient of Q at xcp.
             On exit d is the Newton direction of Q. 
             
             ws and wy are double precision arrays;
             theta is a double precision variable;
             col is an integer variable;
             head is an integer variable.
             On entry they store the information defining the
             limited memory BFGS matrix:
             ws(n,m) stores S, a set of s-vectors;
             wy(n,m) stores Y, a set of y-vectors;
             theta is the scaling factor specifying B_0 = theta I;
             col is the number of variable metric corrections stored;
             head is the location of the 1st s- (or y-) vector in S (or Y).
             On exit they are unchanged.
             
             iword is an integer variable.
             On entry iword is unspecified.
             On exit iword specifies the status of the subspace solution.
             iword = 0 if the solution is in the box,
             1 if some bound is encountered.
             
             wv is a double precision working array of dimension 2m.
             
             wn is a double precision array of dimension 2m x 2m.
             On entry the upper triangle of wn stores the LEL^T factorization
             of the indefinite matrix
             
             K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
             [L_a -R_z           theta*S'AA'S ]
             where E = [-I  0]
             [ 0  I]
             On exit wn is unchanged.
             
             iprint is an INTEGER variable that must be set by the user.
             It controls the frequency and type of output generated:
             iprint.LT.0    no output is generated;
             iprint=0    print only one line at the last iteration;
             0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
             iprint=99   print details of every iteration except n-vectors;
             iprint=100  print also the changes of active set and final x;
             iprint.GT.100  print details of every iteration including x and g;
             When iprint .GT. 0, the file iterate.dat will be created to
             summarize the iteration.
             
             info is an integer variable.
             On entry info is unspecified.
             On exit info = 0       for normal return,
             = nonzero for abnormal return 
             when the matrix K is ill-conditioned.
             
             Subprograms called:
             
             Linpack dtrsl.
             
             
             References:
             
             [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
             memory algorithm for bound constrained optimization'',
             SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
             
             
             
             *  *  *
             
             NEOS, November 1994. (Latest revision June 1996.)
             Optimization Technology Center.
             Argonne National Laboratory and Northwestern University.
             Written by
             Ciyou Zhu
             in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
             
             
             ************
             
             
             
             
             
            </param>
             <param name="WS">
             and wy are double precision arrays;
            </param>
             <param name="THETA">
             is a double precision variable;
            </param>
             <param name="COL">
             is an integer variable;
            </param>
             <param name="HEAD">
             is an integer variable.
             On entry they store the information defining the
             limited memory BFGS matrix:
             ws(n,m) stores S, a set of s-vectors;
             wy(n,m) stores Y, a set of y-vectors;
             theta is the scaling factor specifying B_0 = theta I;
             col is the number of variable metric corrections stored;
             head is the location of the 1st s- (or y-) vector in S (or Y).
             On exit they are unchanged.
            </param>
             <param name="IWORD">
             is an integer variable.
             On entry iword is unspecified.
             On exit iword specifies the status of the subspace solution.
             iword = 0 if the solution is in the box,
             1 if some bound is encountered.
            </param>
             <param name="WV">
             is a double precision working array of dimension 2m.
            </param>
             <param name="WN">
             is a double precision array of dimension 2m x 2m.
             On entry the upper triangle of wn stores the LEL^T factorization
             of the indefinite matrix
             
             K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
             [L_a -R_z           theta*S'AA'S ]
             where E = [-I  0]
             [ 0  I]
             On exit wn is unchanged.
            </param>
             <param name="IPRINT">
             is an INTEGER variable that must be set by the user.
             It controls the frequency and type of output generated:
             iprint.LT.0    no output is generated;
             iprint=0    print only one line at the last iteration;
             0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
             iprint=99   print details of every iteration except n-vectors;
             iprint=100  print also the changes of active set and final x;
             iprint.GT.100  print details of every iteration including x and g;
             When iprint .GT. 0, the file iterate.dat will be created to
             summarize the iteration.
            </param>
             <param name="INFO">
             is an integer variable.
             On entry info is unspecified.
             On exit info = 0       for normal return,
             = nonzero for abnormal return 
             when the matrix K is ill-conditioned.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.LinearLeastSquares">
            <summary>
            Computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(|| A*X - B||)
            involving an M-by-N matrix A. The problem can be solved using: 1) A QR or LQ
            factorization, 2) Complete orthogonal factorization, 3) Using singular value decomposition (SVD).  
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.#ctor">
             <summary>
            Initializes a new instance of the LinearLeastSquares class.
             </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.QRorLQSolve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Solves overdetermined or underdetermined real linear systems
            involving an M-by-N matrix A, using a QR or LQ
            factorization of A.  It is assumed that A has full rank.
            </summary>
            <param name="A">The A matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.COFSolve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(|| A*X - B||) 
            using a complete orthogonal factorization of A.
            The matrix A can be rank-deficient.
            </summary>
            <param name="A">The A matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.COFSolve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix,System.Double)">
            <summary>
            Computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(|| A*X - B||) 
            using a complete orthogonal factorization of A.
            The matrix A can be rank-deficient.
            </summary>
            <param name="A">The A matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <param name="rcond">
            The parameter rcond is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number .LT. 1/rcond.
            </param>
            <returns>A matrix containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.SVDdcSolve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(|| A*X - B||) 
            using the singular value decomposition (SVD) of A.
            The matrix A can be rank-deficient.
            </summary>
            <param name="A">The A matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.SVDdcSolve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix,System.Double)">
            <summary>
            Computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(|| A*X - B||) 
            using the singular value decomposition (SVD) of A.
            The matrix A can be rank-deficient.
            </summary>
            <param name="A">The A matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <param name="rcond">
            rcond is used to determine the effective rank of A.
            Singular values S(i) .LE. rcond*S(1) are treated as zero.
            </param>
            <returns>A matrix containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearLeastSquares.CalculateLIWORK(System.Int32,System.Int32)">
            <summary>
            Calcula LIWORK para ser usado en IWORK. Este programa se encuentra en el foro de preguntas de Lapack
            </summary>
            <param name="ARows">Number of A rows </param>
            <param name="AColumns">Number of A columns </param>
            <returns>LIWORK </returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMR2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMR2 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMR2.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMR2 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q or Q' from the Left
             = 'R': apply Q or Q' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply Q  (No transpose)
             = 'T': apply Q' (Transpose)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGERQF in the last k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGERQF.
            </param>
             <param name="C">
             * Q  if SIDE = 'R' and TRANS = 'N', or
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L',
             (M) if SIDE = 'R'
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGL2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGL2 generates an m by n real matrix Q with orthonormal rows,
             which is defined as the first m rows of a product of k elementary
             reflectors of order n
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGELQF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGL2.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGL2 generates an m by n real matrix Q with orthonormal rows,
             which is defined as the first m rows of a product of k elementary
             reflectors of order n
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGELQF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. N .GE. M.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. M .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the i-th row must contain the vector which defines
             the elementary reflector H(i), for i = 1,2,...,k, as returned
             by DGELQF in the first k rows of its array argument A.
             On exit, the m-by-n matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGELQF.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (M)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGHR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGHR generates a real orthogonal matrix Q which is defined as the
             product of IHI-ILO elementary reflectors of order N, as returned by
             DGEHRD:
             
             Q = H(ilo) H(ilo+1) . . . H(ihi-1).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGHR.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGHR generates a real orthogonal matrix Q which is defined as the
             product of IHI-ILO elementary reflectors of order N, as returned by
             DGEHRD:
             
             Q = H(ilo) H(ilo+1) . . . H(ihi-1).
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix Q. N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             ILO and IHI must have the same values as in the previous call
             of DGEHRD. Q is equal to the unit matrix except in the
             submatrix Q(ilo+1:ihi,ilo+1:ihi).
             1 .LE. ILO .LE. IHI .LE. N, if N .GT. 0; ILO=1 and IHI=0, if N=0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the vectors which define the elementary reflectors,
             as returned by DGEHRD.
             On exit, the N-by-N orthogonal matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (N-1)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEHRD.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. IHI-ILO.
             For optimum performance LWORK .GE. (IHI-ILO)*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLATRS">
             <summary>
             -- LAPACK auxiliary routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             June 30, 1992
             Purpose
             =======
             
             DLATRS solves one of the triangular systems
             
             A *x = s*b  or  A'*x = s*b
             
             with scaling to prevent overflow.  Here A is an upper or lower
             triangular matrix, A' denotes the transpose of A, x and b are
             n-element vectors, and s is a scaling factor, usually less than
             or equal to 1, chosen so that the components of x will be less than
             the overflow threshold.  If the unscaled problem will not cause
             overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
             is singular (A(j,j) = 0 for some j), then s is set to 0 and a
             non-trivial solution to A*x = 0 is returned.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLATRS.Run(System.String,System.String,System.String,System.String,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLATRS solves one of the triangular systems
             
             A *x = s*b  or  A'*x = s*b
             
             with scaling to prevent overflow.  Here A is an upper or lower
             triangular matrix, A' denotes the transpose of A, x and b are
             n-element vectors, and s is a scaling factor, usually less than
             or equal to 1, chosen so that the components of x will be less than
             the overflow threshold.  If the unscaled problem will not cause
             overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
             is singular (A(j,j) = 0 for some j), then s is set to 0 and a
             non-trivial solution to A*x = 0 is returned.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the matrix A is upper or lower triangular.
             = 'U':  Upper triangular
             = 'L':  Lower triangular
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             Specifies the operation applied to A.
             = 'N':  Solve A * x = s*b  (No transpose)
             = 'T':  Solve A'* x = s*b  (Transpose)
             = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             Specifies whether or not the matrix A is unit triangular.
             = 'N':  Non-unit triangular
             = 'U':  Unit triangular
            </param>
             <param name="NORMIN">
             (input) CHARACTER*1
             Specifies whether CNORM has been set or not.
             = 'Y':  CNORM contains the column norms on entry
             = 'N':  CNORM is not set on entry.  On exit, the norms will
             be computed and stored in CNORM.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             *x = s*b  or  A'*x = s*b
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max (1,N).
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the right hand side b of the triangular system.
             On exit, X is overwritten by the solution vector x.
            </param>
             <param name="SCALE">
             (output) DOUBLE PRECISION
             The scaling factor s for the triangular system
             A * x = s*b  or  A'* x = s*b.
             If SCALE = 0, the matrix A is singular or badly scaled, and
             the vector x is an exact or approximate solution to A*x = 0.
            </param>
             <param name="CNORM">
             (input or output) DOUBLE PRECISION array, dimension (N)
             
             If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
             contains the norm of the off-diagonal part of the j-th column
             of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
             to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
             must be greater than or equal to the 1-norm.
             
             If NORMIN = 'N', CNORM is an output argument and CNORM(j)
             returns the 1-norm of the offdiagonal part of the j-th column
             of A.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -k, the k-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASRT">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             Sort the numbers in D in increasing order (if ID = 'I') or
             in decreasing order (if ID = 'D' ).
             
             Use Quick Sort, reverting to Insertion sort on arrays of
             size .LE. 20. Dimension of STACK limits N to about 2**32.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASRT.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             Sort the numbers in D in increasing order (if ID = 'I') or
             in decreasing order (if ID = 'D' ).
             
             Use Quick Sort, reverting to Insertion sort on arrays of
             size .LE. 20. Dimension of STACK limits N to about 2**32.
             
            </summary>
             <param name="ID">
             (input) CHARACTER*1
             = 'I': sort D in increasing order;
             = 'D': sort D in decreasing order.
            </param>
             <param name="N">
             (input) INTEGER
             The length of the array D.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the array to be sorted.
             On exit, D has been sorted into increasing order
             (D(1) .LE. ... .LE. D(N) ) or into decreasing order
             (D(1) .GE. ... .GE. D(N) ), depending on ID.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD3">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD3 finds all the square roots of the roots of the secular
             equation, as defined by the values in D and Z.  It makes the
             appropriate calls to DLASD4 and then updates the singular
             vectors by matrix multiplication.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
             DLASD3 is called from DLASD1.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD3.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD3 finds all the square roots of the roots of the secular
             equation, as defined by the values in D and Z.  It makes the
             appropriate calls to DLASD4 and then updates the singular
             vectors by matrix multiplication.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
             DLASD3 is called from DLASD1.
             
            </summary>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block.  NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block.  NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has N = NL + NR + 1 rows and
             M = N + SQRE .GE. N columns.
            </param>
             <param name="K">
             (input) INTEGER
             The size of the secular equation, 1 =.LT. K = .LT. N.
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension(K)
             On exit the square roots of the roots of the secular equation,
             in ascending order.
            </param>
             <param name="Q">
             (workspace) DOUBLE PRECISION array,
             dimension at least (LDQ,K).
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. K.
            </param>
             <param name="DSIGMA">
             (input) DOUBLE PRECISION array, dimension(K)
             The first K elements of this array contain the old roots
             of the deflated updating problem.  These are the poles
             of the secular equation.
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU, N)
             The last N - K columns of this matrix contain the deflated
             left singular vectors.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. N.
            </param>
             <param name="U2">
             (input/output) DOUBLE PRECISION array, dimension (LDU2, N)
             The first K columns of this matrix contain the non-deflated
             left singular vectors for the split problem.
            </param>
             <param name="LDU2">
             (input) INTEGER
             The leading dimension of the array U2.  LDU2 .GE. N.
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array, dimension (LDVT, M)
             The last M - K columns of VT' contain the deflated
             right singular vectors.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. N.
            </param>
             <param name="VT2">
             (input/output) DOUBLE PRECISION array, dimension (LDVT2, N)
             The first K columns of VT2' contain the non-deflated
             right singular vectors for the split problem.
            </param>
             <param name="LDVT2">
             (input) INTEGER
             The leading dimension of the array VT2.  LDVT2 .GE. N.
            </param>
             <param name="IDXC">
             (input) INTEGER array, dimension ( N )
             The permutation used to arrange the columns of U (and rows of
             VT) into three groups:  the first group contains non-zero
             entries only at and above (or before) NL +1; the second
             contains non-zero entries only at and below (or after) NL+2;
             and the third is dense. The first column of U and the row of
             VT are treated separately, however.
             
             The rows of the singular vectors found by DLASD4
             must be likewise permuted before the matrix multiplies can
             take place.
            </param>
             <param name="CTOT">
             (input) INTEGER array, dimension ( 4 )
             A count of the total number of the various types of columns
             in U (or rows in VT), as described in IDXC. The fourth column
             type is any column which has been deflated.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (K)
             The first K elements of this array contain the components
             of the deflation-adjusted updating row vector.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR2.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <param name="WANTT">
             (input) LOGICAL
             If .TRUE., then the Hessenberg matrix H is fully updated
             so that the quasi-triangular Schur factor may be
             computed (in cooperation with the calling subroutine).
             If .FALSE., then only enough of H is updated to preserve
             the eigenvalues.
            </param>
             <param name="WANTZ">
             (input) LOGICAL
             If .TRUE., then the orthogonal matrix Z is updated so
             so that the orthogonal Schur factor may be computed
             (in cooperation with the calling subroutine).
             If .FALSE., then Z is not referenced.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H and (if WANTZ is .TRUE.) the
             order of the orthogonal matrix Z.
            </param>
             <param name="KTOP">
             (input) INTEGER
             It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
             KBOT and KTOP together determine an isolated block
             along the diagonal of the Hessenberg matrix.
            </param>
             <param name="KBOT">
             (input) INTEGER
             It is assumed without a check that either
             KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
             determine an isolated block along the diagonal of the
             Hessenberg matrix.
            </param>
             <param name="NW">
             (input) INTEGER
             Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On input the initial N-by-N section of H stores the
             Hessenberg matrix undergoing aggressive early deflation.
             On output H has been transformed by an orthogonal
             similarity transformation, perturbed, and the returned
             to Hessenberg form that (it is to be hoped) has some
             zero subdiagonal entries.
            </param>
             <param name="LDH">
             (input) integer
             Leading dimension of H just as declared in the calling
             subroutine.  N .LE. LDH
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
             IF WANTZ is .TRUE., then on output, the orthogonal
             similarity transformation mentioned above has been
             accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
             If WANTZ is .FALSE., then Z is unreferenced.
            </param>
             <param name="LDZ">
             (input) integer
             The leading dimension of Z just as declared in the
             calling subroutine.  1 .LE. LDZ.
            </param>
             <param name="NS">
             (output) integer
             The number of unconverged (ie approximate) eigenvalues
             returned in SR and SI that may be used as shifts by the
             calling subroutine.
            </param>
             <param name="ND">
             (output) integer
             The number of converged eigenvalues uncovered by this
             subroutine.
            </param>
             <param name="SR">
             (output) DOUBLE PRECISION array, dimension KBOT
            </param>
             <param name="SI">
             (output) DOUBLE PRECISION array, dimension KBOT
             On output, the real and imaginary parts of approximate
             eigenvalues that may be used for shifts are stored in
             SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
             SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
             The real and imaginary parts of converged eigenvalues
             are stored in SR(KBOT-ND+1) through SR(KBOT) and
             SI(KBOT-ND+1) through SI(KBOT), respectively.
            </param>
             <param name="V">
             (workspace) DOUBLE PRECISION array, dimension (LDV,NW)
             An NW-by-NW work array.
            </param>
             <param name="LDV">
             (input) integer scalar
             The leading dimension of V just as declared in the
             calling subroutine.  NW .LE. LDV
            </param>
             <param name="NH">
             (input) integer scalar
             The number of columns of T.  NH.GE.NW.
            </param>
             <param name="T">
             (workspace) DOUBLE PRECISION array, dimension (LDT,NW)
            </param>
             <param name="LDT">
             (input) integer
             The leading dimension of T just as declared in the
             calling subroutine.  NW .LE. LDT
            </param>
             <param name="NV">
             (input) integer
             The number of rows of work array WV available for
             workspace.  NV.GE.NW.
            </param>
             <param name="WV">
             (workspace) DOUBLE PRECISION array, dimension (LDWV,NW)
            </param>
             <param name="LDWV">
             (input) integer
             The leading dimension of W just as declared in the
             calling subroutine.  NW .LE. LDV
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension LWORK.
             On exit, WORK(1) is set to an estimate of the optimal value
             of LWORK for the given values of N, NW, KTOP and KBOT.
            </param>
             <param name="LWORK">
             (input) integer
             The dimension of the work array WORK.  LWORK = 2*NW
             suffices, but greater efficiency may result from larger
             values of LWORK.
             
             If LWORK = -1, then a workspace query is assumed; DLAQR2
             only estimates the optimal workspace size for the given
             values of N, NW, KTOP and KBOT.  The estimate is returned
             in WORK(1).  No error message related to LWORK is issued
             by XERBLA.  Neither H nor Z are accessed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED0">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED0 computes all eigenvalues and corresponding eigenvectors of a
             symmetric tridiagonal matrix using the divide and conquer method.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED0.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED0 computes all eigenvalues and corresponding eigenvectors of a
             symmetric tridiagonal matrix using the divide and conquer method.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             = 0:  Compute eigenvalues only.
             = 1:  Compute eigenvectors of original dense symmetric matrix
             also.  On entry, Q contains the orthogonal matrix used
             to reduce the original matrix to tridiagonal form.
             = 2:  Compute eigenvalues and eigenvectors of tridiagonal
             matrix.
            </param>
             <param name="QSIZ">
             (input) INTEGER
             The dimension of the orthogonal matrix used to reduce
             the full matrix to tridiagonal form.  QSIZ .GE. N if ICOMPQ = 1.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the main diagonal of the tridiagonal matrix.
             On exit, its eigenvalues.
            </param>
             <param name="E">
             (input) DOUBLE PRECISION array, dimension (N-1)
             The off-diagonal elements of the tridiagonal matrix.
             On exit, E has been destroyed.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
             On entry, Q must contain an N-by-N orthogonal matrix.
             If ICOMPQ = 0    Q is not referenced.
             If ICOMPQ = 1    On entry, Q is a subset of the columns of the
             orthogonal matrix used to reduce the full
             matrix to tridiagonal form corresponding to
             the subset of the full matrix which is being
             decomposed at this time.
             If ICOMPQ = 2    On entry, Q will be the identity matrix.
             On exit, Q contains the eigenvectors of the
             tridiagonal matrix.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  If eigenvectors are
             desired, then  LDQ .GE. max(1,N).  In any case,  LDQ .GE. 1.
            </param>
             <param name="QSTORE">
             (workspace) DOUBLE PRECISION array, dimension (LDQS, N)
             Referenced only when ICOMPQ = 1.  Used to store parts of
             the eigenvector matrix when the updating matrix multiplies
             take place.
            </param>
             <param name="LDQS">
             (input) INTEGER
             The leading dimension of the array QSTORE.  If ICOMPQ = 1,
             then  LDQS .GE. max(1,N).  In any case,  LDQS .GE. 1.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array,
             If ICOMPQ = 0 or 1, the dimension of WORK must be at least
             1 + 3*N + 2*N*lg N + 2*N**2
             ( lg( N ) = smallest integer k
             such that 2^k .GE. N )
             If ICOMPQ = 2, the dimension of WORK must be at least
             4*N + N**2.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array,
             If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
             6 + 6*N + 5*N*lg N.
             ( lg( N ) = smallest integer k
             such that 2^k .GE. N )
             If ICOMPQ = 2, the dimension of IWORK must be at least
             3 + 5*N.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  The algorithm failed to compute an eigenvalue while
             working on the submatrix lying in rows and columns
             INFO/(N+1) through mod(INFO,N+1).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEHRD">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEHRD reduces a real general matrix A to upper Hessenberg form H by
             an orthogonal similarity transformation:  Q' * A * Q = H .
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEHRD.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEHRD reduces a real general matrix A to upper Hessenberg form H by
             an orthogonal similarity transformation:  Q' * A * Q = H .
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that A is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to DGEBAL; otherwise they should be
             set to 1 and N respectively. See Further Details.
             1 .LE. ILO .LE. IHI .LE. N, if N .GT. 0; ILO=1 and IHI=0, if N=0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the N-by-N general matrix to be reduced.
             On exit, the upper triangle and the first subdiagonal of A
             are overwritten with the upper Hessenberg matrix H, and the
             elements below the first subdiagonal, with the array TAU,
             represent the orthogonal matrix Q as a product of elementary
             reflectors. See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The scalar factors of the elementary reflectors (see Further
             Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
             zero.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The length of the array WORK.  LWORK .GE. max(1,N).
             For optimum performance LWORK .GE. N*NB, where NB is the
             optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGBTRF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGBTRF computes an LU factorization of a real m-by-n band matrix A
             using partial pivoting with row interchanges.
             
             This is the blocked version of the algorithm, calling Level 3 BLAS.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGBTRF.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGBTRF computes an LU factorization of a real m-by-n band matrix A
             using partial pivoting with row interchanges.
             
             This is the blocked version of the algorithm, calling Level 3 BLAS.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="KL">
             (input) INTEGER
             The number of subdiagonals within the band of A.  KL .GE. 0.
            </param>
             <param name="KU">
             (input) INTEGER
             The number of superdiagonals within the band of A.  KU .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
             On entry, the matrix A in band storage, in rows KL+1 to
             2*KL+KU+1; rows 1 to KL of the array need not be set.
             The j-th column of A is stored in the j-th column of the
             array AB as follows:
             AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku).LE.i.LE.min(m,j+kl)
             
             On exit, details of the factorization: U is stored as an
             upper triangular band matrix with KL+KU superdiagonals in
             rows 1 to KL+KU+1, and the multipliers used during the
             factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
             See below for further details.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. 2*KL+KU+1.
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (min(M,N))
             The pivot indices; for 1 .LE. i .LE. min(M,N), row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: if INFO = +i, U(i,i) is exactly zero. The factorization
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.ComplexVector">
            <summary>
            Represents a Complex Vector.
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.ComplexVector._Data">
            <summary>
            Los datos del vector
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.ComplexVector._Type">
            <summary>
            El tipo de vector.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the VectorComplex class of the given size.
            </summary>
            <param name="length">The vector length</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.#ctor(DotNumerics.LinearAlgebra.VectorType,System.Int32)">
            <summary>
            Initializes a new instance of the Vector class of the given size and type.
            </summary>
            <param name="type">The vector type</param>
            <param name="length">length">The vector length</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.#ctor(DotNumerics.Complex[])">
            <summary>
            Initializes a new instance of the Vector class that contains elements 
            copied from the specified array.
            </summary>
            <param name="data">The array whose elements are copied to the vector.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.#ctor(DotNumerics.LinearAlgebra.VectorType,DotNumerics.Complex[])">
            <summary>
            Initializes a new instance of the Vector class that contains elements
            copied from the specified array.
            </summary>
            <param name="type">The vector type</param>
            <param name="data">The array whose elements are copied to the vector.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_Addition(DotNumerics.LinearAlgebra.ComplexVector,DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Vector addition.
            </summary>
            <param name="A">The left side vector of the addition operator.</param>
            <param name="B">The right side vector of the addition operator.</param>
            <returns>A vector that represents the result of the addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_UnaryNegation(DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Unary minus.
            </summary>
            <param name="v">The vector.</param>
            <returns>Vector r[i] = -this[i]</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_Subtraction(DotNumerics.LinearAlgebra.ComplexVector,DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Vector subtraction.
            </summary>
            <param name="A"> The left side vector of the subtraction operator.</param>
            <param name="B">The right side vector of the subtraction operator.</param>
            <returns>A vector that represents the result of the vector subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_Multiply(DotNumerics.Complex,DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Scalar-Vector multiplication.
            </summary>
            <param name="c"> The left side complex number of the multiplication operator.</param>
            <param name="A">The right side vector of the multiplication operator.</param>
            <returns>A vector that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_Multiply(DotNumerics.LinearAlgebra.ComplexVector,DotNumerics.Complex)">
            <summary>
            Vector-Scalar multiplication.
            </summary>
            <param name="A">The left side vector of the multiplication operator.</param>
            <param name="c"> The right side complex number of the multiplication operator.</param>
            <returns>A vector that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Transpose">
            <summary>
            Transposed vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.op_Implicit(DotNumerics.LinearAlgebra.ComplexVector)~DotNumerics.LinearAlgebra.ComplexMatrix">
            <summary>
            Implicit Vector to Matrix conversion.
            </summary>
            <param name="V">The Vector</param>
            <returns>The Matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Add(DotNumerics.Complex)">
            <summary>
            Add a complex number to all elements of this vector.
            </summary>
            <param name="c">The complex number.</param>
            <returns>
            VectorComplex r[i] = this[i] + c
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.AddInplace(DotNumerics.Complex)">
            <summary>
            In place add a scalar to all elements of this vector.
            </summary>
            <param name="c">The complex number.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Add(DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Add a VectorComplex.
            </summary>
            <param name="B">The vector B.</param>
            <returns>
            VectorComplex r[i] = this[i] + B[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.AddInplace(DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            In place add a VectorComplex.
            </summary>
            <param name="B">The vector B.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Subtract(DotNumerics.Complex)">
            <summary>
            Subtract a scalar to all elements of this vector.
            </summary>
            <param name="c">The complex number.</param>
            <returns>
            VectorComplex r[i] = this[i] - c
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.SubtractInplace(DotNumerics.Complex)">
            <summary>
            In place subtract a scalar to all elements of this vector.
            </summary>
            <param name="c">The complex number.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Subtract(DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            Subtract a VectorComplex.
            </summary>
            <param name="B">The vector B.</param>
            <returns>
            VectorComplex r[i] = this[i] - B[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.SubtractInplace(DotNumerics.LinearAlgebra.ComplexVector)">
            <summary>
            In place add a VectorComplex.
            </summary>
            <param name="B">The vector B.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Multiply(DotNumerics.Complex)">
            <summary>
            Multiply a scalar to all elements of this vector.
            </summary>
            <param name="c">The complex number.</param>
            <returns>
            VectorComplex r[i] = this[i] * c
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.MultiplyInplace(DotNumerics.Complex)">
            <summary>
            In place multiply this vector with a scalar.
            </summary>
            <param name="scalar">The scalar </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.UnaryMinus">
            <summary>
            Unary minus this vector.
            </summary>
            <returns>
            Vector r[i] = -this[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.UnaryMinusInplace">
            <summary>
            In place unary minus of this vector.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Conjugate">
            <summary>
            Conjugate this vector.
            </summary>
            <returns>
            Vector r[i] = Real(this[i]) - Imaginary(this[i])
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.ConjugateInplace">
            <summary>
            In place conjugation of this vector.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.Norm1">
            <summary>
            Calculate the 1-norm of the vector.
            </summary>
            <returns>
            r = sum(abs(this[i]))
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexVector.VectorToString">
            <summary>
            Returns the equivalent string representation of the vector.
            </summary>
            <returns>The string representation of the vector.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexVector.Data">
            <summary>
            Los datos del vector
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexVector.Length">
            <summary>
            Returns the number of rows.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexVector.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.BaseMatrix">
            <summary>
            Represents a Base Matrix.
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.IMatrix`1">
            <summary>
            Interface for a Matrix
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.IMatrix`1.CopyToArray">
            <summary>
             Copy the elements of this matrix to a rectangular array.
            </summary>
            <returns>A rectangular array.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.IMatrix`1.CopyToJaggedArray">
            <summary>
             Copy the elements of this matrix to a jagged array.
            </summary>
            <returns>A jagged array</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.IMatrix`1.RowCount">
            <summary>
            Returns the number of rows.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.IMatrix`1.ColumnCount">
            <summary>
            Returns the number of columns.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.IMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets or set the value of a element of this Matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The Matrix element at (row, column).</returns>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.BaseMatrix._Data">
            <summary>
            Los datos de la matriz, los datos se almacenan en un un array unidimensional,
            Los elementos se almacenan por columnas, esto para que sean compatible con los Arrays de Fortran
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.BaseMatrix._RowCount">
            <summary>
            El numero de renglones
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.BaseMatrix._ColumnCount">
            <summary>
            El numero de columnas
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BaseMatrix class of the given size.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the BaseMatrix class of the given size using a array
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="data">The data, the data is copied.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the BaseMatrix class of the given size.
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.#ctor(System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the BaseMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="data">The data</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.CheckMatrixDimensions(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>Check if size(this) == size(B) </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.ElementsAbs">
            <summary>
            aij=Math.Abs(aij)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.ElemntsDiv(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Element-by-element division: aij = aij/bij
            </summary>
            <param name="B">The B Matrix.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.ElemntsMult(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Element-by-element multiplication: aij = aij*bij
            </summary>
            <param name="B">The B Matrix.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Add(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Addition C=A+B
            </summary>
            <param name="B">The Matrix</param>
            <returns>C=A+B</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.MultiplyInplace(System.Double)">
            <summary>
            In place scalar-matrix multiplication, A=s*A
            </summary>
            <param name="s">The scalar</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Multiply(System.Double)">
            <summary>
            Scalar-matrix multiplication, C=s*A
            </summary>
            <param name="s">The scalar</param>
            <returns>C=s*A</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Multiply(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Matrix-Matrix multiplication, C=A*B
            </summary>
            <param name="B">The matrix.</param>
            <returns>C=A*B</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Subtract(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Matrix subtraction, C=A-B
            </summary>
            <param name="B">The Matrix</param>
            <returns>C=A-B</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.UnaryMinusInplace">
            <summary>
            In place unary minus -A
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Inverse">
            <summary>
            Calculates the inverse of the matrix.
            </summary>
            <returns>The inverse of the matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Determinant">
            <summary>
            Calculates the determinant of the matrix.
            </summary>
            <returns>The determinant of the matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetColumnVectors">
            <summary>
            Gets the column vectors of this matrix.
            </summary>
            <returns>The columns vectors.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetColumnVector(System.Int32)">
            <summary>
             Gets a column vector of this matrix at the selected position.
            </summary>
            <param name="columnIndex">The column index (zero-based).</param>
            <returns>The column vector.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetColumnArray(System.Int32)">
            <summary>
             Gets a column array of this matrix at the selected position.
            </summary>
            <param name="columnIndex">The column index (zero-based).</param>
            <returns>The column array.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetRowVectors">
            <summary>
            Gets the row vectors of this matrix.
            </summary>
            <returns>The row vectors.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetRowVector(System.Int32)">
            <summary>
             Gets a row vector of this matrix at the selected position.
            </summary>
            <param name="rowIndex">The row index (zero-based).</param>
            <returns>The row vector.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.GetRowArray(System.Int32)">
            <summary>
             Gets a row array of this matrix at the selected position.
            </summary>
            <param name="rowIndex">The row index (zero-based).</param>
            <returns>The row array.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.MatrixToString">
            <summary>
            Returns the equivalent string representation of the matrix.
            </summary>
            <returns>The string representation of the  matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.MatrixToString(System.String)">
            <summary>
            Returns the equivalent string representation of the matrix.
            </summary>
            <param name="format">A numeric format string.</param>
            <returns>The string representation of the  matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Norm1">
            <summary>
            One Norm for the matrix.
            </summary>
            <returns>The maximum column sum.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.NormInf">
            <summary>
            Infinity Norm for the matrix.
            </summary>
            <returns>The maximum row sum.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.FrobeniusNorm">
            <summary>Frobenius norm</summary>
            <returns>The square root of sum of squares of all elements.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Hypot(System.Double,System.Double)">
            <summary>sqrt(a^2 + b^2) without under/overflow.</summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.ElementsSum">
            <summary>
            Sum of elements =SUMij(A[i,j])
            </summary>
            <returns>The sum of elements.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.Transpose">
            <summary>
            Transposed matrix.
            </summary>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.op_Multiply(DotNumerics.LinearAlgebra.BaseMatrix,DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Matrix multiplication.
            </summary>
            <param name="A"> The left side matrix of the multiplication operator.</param>
            <param name="B">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the matrix multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.op_Addition(DotNumerics.LinearAlgebra.BaseMatrix,DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.op_Subtraction(DotNumerics.LinearAlgebra.BaseMatrix,DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.CopyToArray">
            <summary>
            Copy all elements of this matrix to a rectangular 2D array.
            </summary>
            <returns>A rectangular 2D array.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseMatrix.CopyToJaggedArray">
            <summary>
            Copy all elements of this matrix to a jagged array.
            </summary>
            <returns>A jagged array.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.Data">
            <summary>
            Los datos de la matriz
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.RowCount">
            <summary>
            Returns the number of rows.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.ColumnCount">
            <summary>
            Returns the number of columns.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.IsSquare">
            <summary>
            Gets a value indicating if the matrix is square.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or set the value of a element of this matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The matrix element at (row, column).</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseMatrix.Trace">
            <summary>Returns the trace of the matrix.</summary>
            <returns>Sum of the diagonal elements.</returns>
        </member>
        <member name="T:DotNumerics.Complex">
            <summary>
            Represents a Complex number.
            </summary>
        </member>
        <member name="M:DotNumerics.Complex.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the Complex class.
            </summary>
            <param name="real">The real part of the Complex number.</param>
            <param name="imaginary">The imaginary part of the complex number. </param>
        </member>
        <member name="M:DotNumerics.Complex.op_Addition(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Complex addition.
            </summary>
            <param name="z1">The left side of the addition operator.</param>
            <param name="z2">The right side matrix of the addition operator.</param>
            <returns>A value that represents the result of the addition.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_UnaryPlus(DotNumerics.Complex)">
            <summary>
            Unary addition.
            </summary>
            <param name="c">The value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_UnaryNegation(DotNumerics.Complex)">
            <summary>
            Unary minus.
            </summary>
            <param name="c">The value</param>
            <returns> -value</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Subtraction(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Complex subtraction.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Multiply(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Complex multiplication.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Multiply(System.Double,DotNumerics.Complex)">
            <summary>
            Complex multiplication.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Multiply(DotNumerics.Complex,System.Double)">
            <summary>
            Complex multiplication.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Division(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Complex division.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Equality(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Equality operator.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.op_Inequality(DotNumerics.Complex,DotNumerics.Complex)">
            <summary>
            Inequality operator.
            </summary>
            <param name="z1">The left side of the operator.</param>
            <param name="z2">The right side of the operator.</param>
            <returns>A value that represents the result of the operation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specific object are equals.
            </summary>
            <param name="obj">Another object to compare to.</param>
            <returns>true if obj and this instance are the same type and represent the same value;
            otherwise, false.</returns>
        </member>
        <member name="M:DotNumerics.Complex.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="M:DotNumerics.Complex.ToString">
            <summary>
            Converts this instance to its equivalent string representation.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:DotNumerics.Complex.ToString(System.String)">
            <summary>
            Converts this instance to its equivalent string representation,
            using the specified format.
            </summary>
            <param name="format">A numeric format string.</param>
            <returns>The string representation of the value of this instance as specified by format.</returns>
        </member>
        <member name="M:DotNumerics.Complex.ToString(System.String,System.IFormatProvider)">
            <summary>
             Converts the numeric value of this instance to its equivalent string representation
             using the specified format and culture-specific format information.
            </summary>
            <param name="format">
            A numeric format string.
            </param>
            <param name="formatProvider">
            An System.IFormatProvider that supplies culture-specific formatting information.
            </param>
            <returns>
            The string representation of the value of this instance as specified by format and provider.
            </returns>
        </member>
        <member name="P:DotNumerics.Complex.Real">
            <summary>
            Gets or sets the real value of the complex number.
            </summary>
        </member>
        <member name="P:DotNumerics.Complex.Imaginary">
            <summary>
            Gets or sets the imaginary value of the complex number.
            </summary>
        </member>
        <member name="P:DotNumerics.Complex.Conjugate">
            <summary>
            Returns the conjugate of this complex number. 
            </summary>
        </member>
        <member name="P:DotNumerics.Complex.Modulus">
            <summary>
            Gets the modulus or absolute value of this complex number. 
            </summary>
        </member>
        <member name="P:DotNumerics.Complex.Argument">
            <summary>
            Gets or stes the argument of a this complex number. 
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.OdeImplicitRungeKutta5">
            <summary>
            Solves an initial-value problem for stiff ordinary differential equations using 
            the implicit Runge-Kutta method of order 5.
            dy(i)/dt = f(i,t,y(1),y(2),...,y(N)). 
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.xBaseOdeRungeKutta">
             <summary>
            Represents a base class for the Runge-Kutta classes. 
             </summary>
        </member>
        <member name="T:DotNumerics.ODE.xOdeBase">
             <summary>
            Represents the base class for the Odes. 
             </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._NEquations">
            <summary>
            The number of equations
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._T0">
            <summary>
            The initial independent variable value.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._Y0">
            <summary>
            The initial conditions.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._Y">
            <summary>
            Array used to set the initial values and to return the solution in some ODE solvers.
            This array must be initialized equal to the initial values in the first call.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._InvokeSetInitialValues">
            <summary>
            Indicated if the SetInitialValues method need to be invoked.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._InvokeInitializeODEs">
            <summary>
            Indicated if the InitializeODEs method need to be invoked.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._Errors">
            <summary>
            Array containing the exception messages.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._ITolAdamsGears">
            <summary>
            For AdamsMoulton and  OdeGearsBDF:
            
            MeITol = An indicator for the type of error control.
            
              ITOL         RTOL       ATOL          EWT(i)
            MeITol =1     scalar     scalar     RTOL*ABS(Y(i)) + ATOL
            MeITol =2     scalar     array      RTOL*ABS(Y(i)) + ATOL(i)
            MeITol =3     array      scalar     RTOL(i)*ABS(Y(i)) + ATOL
            MeITol =4     array      array      RTOL(i)*ABS(Y(i)) + ATOL(i)
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._ITolRK">
             <summary>
            For Runge-Kutta
            
             ITol = An indicator for the type of error control.
             
             ITOL=0: BOTH RTOL AND ATOL ARE SCALARS.
             ITOL=1: BOTH RTOL AND ATOL ARE VECTORS. 
             </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._RelTol">
            <summary>
            A relative error tolerance parameter.
            The input parameters ITOL, RTOL, and ATOL determine
            the error control performed by the solver.  The solver will
            control the vector e = (e(i)) of estimated local errors
            in Y, according to an inequality of the form
            rms-norm of ( e(i)/EWT(i) )   .le.   1,
            where       EWT(i) = RTOL(i)*abs(Y(i)) + ATOL(i),
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._RelTolArray">
            <summary>
            A relative error tolerance parameter, either a scalar or an array of length NEQ. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._AbsTol">
            <summary>
            An absolute error tolerance parameter
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._AbsTolArray">
            <summary>
            An absolute error tolerance parameter(array of length NEQ)
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._RWork">
            <summary>
            MeRWork= A real working array (double precision)
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._Lrw">
            <summary>
            MeLrw= The length of the array RWORK
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._IWork">
            <summary>
            MeIWork= An integer work array.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._Liw">
            <summary>
            MeLiw= the length of the array IWORK
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._RPar">
            <summary>
            User-specified array used to communicate real parameters
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xOdeBase._IPar">
            <summary>
            User-specified array used to communicate integer parameter
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.xOdeBase.SetInitialValues(System.Double,System.Double[])">
            <summary>
            Sets the initial values for the differential equations.
            </summary>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <remarks>
            This method should be invoked before to start the integration.
            When this method is invoked, the ODE solver is restarted.
            </remarks>
        </member>
        <member name="M:DotNumerics.ODE.xOdeBase.InitializeSizeDependentVariables(System.Int32)">
            <summary>
            InitializeInternal the size dependent variables:
            Number of equations, Relative tolerances,  Absolute tolerances, Working space
            </summary>
            <param name="numEquations">The number of equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.xOdeBase.InitializeWorkingSpace">
            <summary>
            Inicializa elespacio nesesitado por la surutinas. Se requiere que estend dedfinidas las proiedades
            que definen dicho espacio, por ejemplo el numero de equaciones.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.xOdeBase.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.xOdeBase.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="P:DotNumerics.ODE.xOdeBase.RelTolArray">
            <summary>
            A relative error tolerance array ( length numEquations).
            </summary>
            <remarks>
            If ErrorToleranceType = ErrorToleranceEnum.Array the estimated local error in Y(i) is controlled to be less than RelTolArray[I]*Abs(Y(I))+AbsTolArray[i].
            </remarks>
        </member>
        <member name="P:DotNumerics.ODE.xOdeBase.RelTol">
            <summary>
            A relative error tolerance parameter.
            </summary>
            <remarks>
            If ErrorToleranceType = ErrorToleranceEnum.Scalar the estimated local error in Y(i) is controlled to be less than RelTol*Abs(Y[i]) + AbsTol.
            </remarks>
        </member>
        <member name="P:DotNumerics.ODE.xOdeBase.AbsTol">
            <summary>
            An absolute error tolerance parameter
            </summary>
            <remarks>
            If ErrorToleranceType = ErrorToleranceEnum.Scalar the estimated local error in Y(i) is controlled to be less than RelTol*Abs(Y[i]) + AbsTol.
            </remarks>
        </member>
        <member name="P:DotNumerics.ODE.xOdeBase.AbsTolArray">
            <summary>
            An absolute error tolerance array (length numEquations). 
            </summary>
            <remarks>
            If ErrorToleranceType = ErrorToleranceEnum.Array the estimated local error in Y(i) is controlled to be less than RelTolArray[I]*Abs(Y(I))+AbsTolArray[i].
            </remarks>
        </member>
        <member name="P:DotNumerics.ODE.xOdeBase.ErrorToleranceType">
            <summary>
            Specifies the type of the relative error and absolute error tolerances. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xBaseOdeRungeKutta._RKSolOut">
            <summary>
            The Sub for the solution.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xBaseOdeRungeKutta._Solution">
            <summary>
            The array containing the solution of the ODEs [T, Y1,Y2,...]
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xBaseOdeRungeKutta._IOut">
            <summary>
            SWITCH FOR CALLING THE SUBROUTINE SOLOUTR:
            IOUT=0: SUBROUTINE IS NEVER CALLED
            IOUT=1: SUBROUTINE IS USED FOR OUTPUT.
            IOUT=2: DENSE OUTPUT IS PERFORMED IN SOLOUTR
            (IN THIS CASE WORK(5) MUST BE SPECIFIED)
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.xBaseOdeRungeKutta._IDID">
            <summary>
            REPORTS ON SUCCESSFULNESS UPON RETURN:
            IDID= 1  COMPUTATION SUCCESSFUL,
            IDID= 2  COMPUT. SUCCESSFUL (INTERRUPTED BY SOLOUTR)
            IDID=-1  INPUT IS NOT CONSISTENT,
            IDID=-2  LARGER NMAX IS NEEDED,
            IDID=-3  STEP SIZE BECOMES TOO SMALL.
            IDID=-4  PROBLEM IS PROBABLY STIFF (INTERRUPTED).
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.xBaseOdeRungeKutta.Solve(System.Double[],System.Double[])">
            <summary>
             Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions ( at t0). N is the number of differential equations.</param>
            <param name="tspan">A vector specifying the interval of integration (t0,..,tf).</param>
            <returns>
            A matrix that contains the solution of the differential equations [T, y1,..,yN]. 
            The first column contains the time points and each row corresponds to the solution at a time returned in the corresponding row.
            </returns>
        </member>
        <member name="M:DotNumerics.ODE.xBaseOdeRungeKutta.Solve(System.Double[],System.Double,System.Double,System.Double)">
            <summary>
            Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <param name="t0">The initial independent variable value.</param>
            <param name="deltaT">The step for the interval of integration (t0, t0+deltaT, t0+2*deltaT,...,tf).</param>
            <param name="tf">The final independent variable value.</param>
            <returns>
            A matrix that contains the solution of the differential equations [T, y1,..,yN]. 
            The first column contains the time points and each row corresponds to the solution at a time returned in the corresponding row.
            </returns>
        </member>
        <member name="M:DotNumerics.ODE.xBaseOdeRungeKutta.Solve(System.Double[],System.Double,System.Double,System.Double,DotNumerics.ODE.OdeSolution)">
            <summary>
            Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <param name="t0">The initial independent variable value.</param>
            <param name="deltaT">The step for the interval of integration (t0, t0+deltaT, t0+2*deltaT,...,tf).</param>
            <param name="tf">The final independent variable value.</param>
            <param name="solution">A delegate where to return the solution.</param>
        </member>
        <member name="M:DotNumerics.ODE.xBaseOdeRungeKutta.Solve(System.Double[],System.Double[],DotNumerics.ODE.OdeSolution)">
            <summary>
             Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions ( at t0). N is the number of differential equations.</param>
            <param name="tspan">A vector specifying the interval of integration (t0,..,tf).</param>
            <param name="solution">A delegate where to return the solution.</param>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeH">
            <summary>
            INITIAL STEP SIZE GUESS;
            FOR STIFF EQUATIONS WITH INITIAL TRANSIENT, 
            H=1.D0/(NORM OF F'), USUALLY 1.D-3 OR 1.D-5, IS GOOD.
            THIS CHOICE IS NOT VERY IMPORTANT, THE STEP SIZE IS
            QUICKLY ADAPTED. (IF H=0.D0, THE CODE PUTS H=1.D-6). 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeIJAC">
            <summary>
            SWITCH FOR THE COMPUTATION OF THE JACOBIAN:
            IJAC=0: JACOBIAN IS COMPUTED INTERNALLY BY FINITE
            DIFFERENCES, SUBROUTINE "JAC" IS NEVER CALLED.
            IJAC=1: JACOBIAN IS SUPPLIED BY SUBROUTINE JAC.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeMLJAC">
            <summary>
            SWITCH FOR THE BANDED STRUCTURE OF THE JACOBIAN:
            MLJAC=N: JACOBIAN IS A FULL MATRIX. THE LINEAR
            ALGEBRA IS DONE BY FULL-MATRIX GAUSS-ELIMINATION.
            0.LE.MLJAC.LT.N: MLJAC IS THE LOWER BANDWITH OF JACOBIAN 
            MATRIX (.GE. NUMBER OF NON-ZERO DIAGONALS BELOW
            THE MAIN DIAGONAL).
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeMUJAC">
            <summary>
            UPPER BANDWITH OF JACOBIAN  MATRIX (.GE. NUMBER OF NON-
            ZERO DIAGONALS ABOVE THE MAIN DIAGONAL).
            NEED NOT BE DEFINED IF MLJAC=N.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeIMAS">
            <summary>
            GIVES INFORMATION ON THE MASS-MATRIX:
            IMAS=0: M IS SUPPOSED TO BE THE IDENTITY
            MATRIX, MAS IS NEVER CALLED.
            IMAS=1: MASS-MATRIX  IS SUPPLIED.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeMLMAS">
            <summary>
            SWITCH FOR THE BANDED STRUCTURE OF THE MASS-MATRIX:
            MLMAS=N: THE FULL MATRIX CASE. THE LINEAR
            ALGEBRA IS DONE BY FULL-MATRIX GAUSS-ELIMINATION.
            0.LE.MLMAS.LT.N: MLMAS IS THE LOWER BANDWITH OF THE
            MATRIX (.GE. NUMBER OF NON-ZERO DIAGONALS BELOW
            THE MAIN DIAGONAL).
            MLMAS IS SUPPOSED TO BE .LE. MLJAC. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.OdeImplicitRungeKutta5.MeMUMAS">
            <summary>
            UPPER BANDWITH OF MASS-MATRIX (.GE. NUMBER OF NON-
            ZERO DIAGONALS ABOVE THE MAIN DIAGONAL).
            NEED NOT BE DEFINED IF MLMAS=N.
            MUMAS IS SUPPOSED TO BE .LE. MUJAC.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.#ctor">
            <summary>
            Initializes a new instance of the OdeImplicitRungeKutta5 class.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.#ctor(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32)">
            <summary>
            Initializes a new instance of the OdeImplicitRungeKutta5 class.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.#ctor(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Initializes a new instance of the OdeImplicitRungeKutta5 class.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.InitializeODEs(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeImplicitRungeKutta5.InitializeODEs(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.TIMER.Run(System.Double@)">
             <param name="TTIME">
             is an output variable which specifies the user time.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.CAUCHY.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double[],System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Int32@,System.Double)">
             <param name="N">
             is an integer variable.
             On entry n is the dimension of the problem.
             On exit n is unchanged.
            </param>
             <param name="X">
             is a double precision array of dimension n.
             On entry x is the starting point for the GCP computation.
             On exit x is unchanged.
            </param>
             <param name="L">
             is a double precision array of dimension n.
             On entry l is the lower bound of x.
             On exit l is unchanged.
            </param>
             <param name="U">
             is a double precision array of dimension n.
             On entry u is the upper bound of x.
             On exit u is unchanged.
            </param>
             <param name="NBD">
             is an integer array of dimension n.
             On entry nbd represents the type of bounds imposed on the
             variables, and must be specified as follows:
             nbd(i)=0 if x(i) is unbounded,
             1 if x(i) has only a lower bound,
             2 if x(i) has both lower and upper bounds, and
             3 if x(i) has only an upper bound. 
             On exit nbd is unchanged.
            </param>
             <param name="G">
             is a double precision array of dimension n.
             On entry g is the gradient of f(x).  g must be a nonzero vector.
             On exit g is unchanged.
            </param>
             <param name="IORDER">
             is an integer working array of dimension n.
             iorder will be used to store the breakpoints in the piecewise
             linear path and free variables encountered. On exit,
             iorder(1),...,iorder(nleft) are indices of breakpoints
             which have not been encountered; 
             iorder(nleft+1),...,iorder(nbreak) are indices of
             encountered breakpoints; and
             iorder(nfree),...,iorder(n) are indices of variables which
             have no bound constraits along the search direction.
            </param>
             <param name="IWHERE">
             is an integer array of dimension n.
             On entry iwhere indicates only the permanently fixed (iwhere=3)
             or free (iwhere= -1) components of x.
             On exit iwhere records the status of the current x variables.
             iwhere(i)=-3  if x(i) is free and has bounds, but is not moved
             0   if x(i) is free and has bounds, and is moved
             1   if x(i) is fixed at l(i), and l(i) .ne. u(i)
             2   if x(i) is fixed at u(i), and u(i) .ne. l(i)
             3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
             -1  if x(i) is always free, i.e., it has no bounds.
            </param>
             <param name="T">
             is a double precision working array of dimension n. 
             t will be used to store the break points.
            </param>
             <param name="D">
             is a double precision array of dimension n used to store
             the Cauchy direction P(x-tg)-x.
            </param>
             <param name="XCP">
             is a double precision array of dimension n used to return the
             GCP on exit.
            </param>
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric corrections 
             used to define the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="THETA">
             is a double precision variable.
             On entry theta is the scaling factor specifying B_0 = theta I.
             On exit theta is unchanged.
            </param>
             <param name="COL">
             is an integer variable.
             On entry col is the actual number of variable metric
             corrections stored so far.
             On exit col is unchanged.
            </param>
             <param name="HEAD">
             is an integer variable.
             On entry head is the location of the first s-vector (or y-vector)
             in S (or Y).
             On exit col is unchanged.
            </param>
             <param name="P">
             is a double precision working array of dimension 2m.
             p will be used to store the vector p = W^(T)d.
            </param>
             <param name="C">
             is a double precision working array of dimension 2m.
             c will be used to store the vector c = W^(T)(xcp-x).
            </param>
             <param name="WBP">
             is a double precision working array of dimension 2m.
             wbp will be used to store the row of W corresponding
             to a breakpoint.
            </param>
             <param name="V">
             is a double precision working array of dimension 2m.
            </param>
             <param name="NINT">
             is an integer variable.
             On exit nint records the number of quadratic segments explored
             in searching for the GCP.
            </param>
             <param name="SG">
             and yg are double precision arrays of dimension m.
             On entry sg  and yg store S'g and Y'g correspondingly.
             On exit they are unchanged. 
            </param>
             <param name="IPRINT">
             is an INTEGER variable that must be set by the user.
             It controls the frequency and type of output generated:
             iprint.LT.0    no output is generated;
             iprint=0    print only one line at the last iteration;
             0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
             iprint=99   print details of every iteration except n-vectors;
             iprint=100  print also the changes of active set and final x;
             iprint.GT.100  print details of every iteration including x and g;
             When iprint .GT. 0, the file iterate.dat will be created to
             summarize the iteration.
            </param>
             <param name="SBGNRM">
             is a double precision variable.
             On entry sbgnrm is the norm of the projected gradient at x.
             On exit sbgnrm is unchanged.
            </param>
             <param name="INFO">
             is an integer variable.
             On entry info is 0.
             On exit info = 0       for normal return,
             = nonzero for abnormal return when the the system
             used in routine bmv is singular.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.Cobyla.COBYLA.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double,System.Double,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Int32[]@,System.Int32)">
             <param name="N">
             components. The algorithm employs linear approximations to the
            </param>
             <param name="X">
             is now the current vector of variables. The subroutine should return
            </param>
             <param name="RHOEND">
             should be set to reasonable initial changes to and the required   
            </param>
             <param name="IPRINT">
             should be set to 0, 1, 2 or 3, which controls the amount of
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRMV">
             <summary>
             Purpose
             =======
             
             DTRMV  performs one of the matrix-vector operations
             
             x := A*x,   or   x := A'*x,
             
             where x is an n element vector and  A is an n by n unit, or non-unit,
             upper or lower triangular matrix.
             
             Parameters
             ==========
             
             UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
             
             TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   x := A*x.
             
             TRANS = 'T' or 't'   x := A'*x.
             
             TRANS = 'C' or 'c'   x := A'*x.
             
             Unchanged on exit.
             
             DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
             
             X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
             
             INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRMV.Run(System.String,System.String,System.String,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DTRMV  performs one of the matrix-vector operations
             
             x := A*x,   or   x := A'*x,
             
             where x is an n element vector and  A is an n by n unit, or non-unit,
             upper or lower triangular matrix.
             
             Parameters
             ==========
             
             UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
             
             TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   x := A*x.
             
             TRANS = 'T' or 't'   x := A'*x.
             
             TRANS = 'C' or 'c'   x := A'*x.
             
             Unchanged on exit.
             
             DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
             
             X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
             
             INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
            </param>
             <param name="TRANS">
             - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   x := A*x.
             
             TRANS = 'T' or 't'   x := A'*x.
             
             TRANS = 'C' or 'c'   x := A'*x.
             
             Unchanged on exit.
            </param>
             <param name="DIAG">
             - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="X">
             := A*x,   or   x := A'*x,
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD2 merges the two sets of singular values together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             singular values are close together or if there is a tiny entry in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
             DLASD2 is called from DLASD1.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD2.Run(System.Int32,System.Int32,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD2 merges the two sets of singular values together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             singular values are close together or if there is a tiny entry in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
             DLASD2 is called from DLASD1.
             
            </summary>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block.  NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block.  NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has N = NL + NR + 1 rows and
             M = N + SQRE .GE. N columns.
            </param>
             <param name="K">
             (output) INTEGER
             Contains the dimension of the non-deflated matrix,
             This is the order of the related secular equation. 1 .LE. K .LE.N.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension(N)
             On entry D contains the singular values of the two submatrices
             to be combined.  On exit D contains the trailing (N-K) updated
             singular values (those which were deflated) sorted into
             increasing order.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension(N)
             On exit Z contains the updating row vector in the secular
             equation.
            </param>
             <param name="ALPHA">
             (input) DOUBLE PRECISION
             Contains the diagonal element associated with the added row.
            </param>
             <param name="BETA">
             (input) DOUBLE PRECISION
             Contains the off-diagonal element associated with the added
             row.
            </param>
             <param name="U">
             (input/output) DOUBLE PRECISION array, dimension(LDU,N)
             On entry U contains the left singular vectors of two
             submatrices in the two square blocks with corners at (1,1),
             (NL, NL), and (NL+2, NL+2), (N,N).
             On exit U contains the trailing (N-K) updated left singular
             vectors (those which were deflated) in its last N-K columns.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. N.
            </param>
             <param name="VT">
             (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
             On entry VT' contains the right singular vectors of two
             submatrices in the two square blocks with corners at (1,1),
             (NL+1, NL+1), and (NL+2, NL+2), (M,M).
             On exit VT' contains the trailing (N-K) updated right singular
             vectors (those which were deflated) in its last N-K columns.
             In case SQRE =1, the last row of VT spans the right null
             space.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. M.
            </param>
             <param name="DSIGMA">
             (output) DOUBLE PRECISION array, dimension (N)
             Contains a copy of the diagonal elements (K-1 singular values
             and one zero) in the secular equation.
            </param>
             <param name="U2">
             (output) DOUBLE PRECISION array, dimension(LDU2,N)
             Contains a copy of the first K-1 left singular vectors which
             will be used by DLASD3 in a matrix multiply (DGEMM) to solve
             for the new left singular vectors. U2 is arranged into four
             blocks. The first block contains a column with 1 at NL+1 and
             zero everywhere else; the second block contains non-zero
             entries only at and above NL; the third contains non-zero
             entries only below NL+1; and the fourth is dense.
            </param>
             <param name="LDU2">
             (input) INTEGER
             The leading dimension of the array U2.  LDU2 .GE. N.
            </param>
             <param name="VT2">
             (output) DOUBLE PRECISION array, dimension(LDVT2,N)
             VT2' contains a copy of the first K right singular vectors
             which will be used by DLASD3 in a matrix multiply (DGEMM) to
             solve for the new right singular vectors. VT2 is arranged into
             three blocks. The first block contains a row that corresponds
             to the special 0 diagonal element in SIGMA; the second block
             contains non-zeros only at and before NL +1; the third block
             contains non-zeros only at and after  NL +2.
            </param>
             <param name="LDVT2">
             (input) INTEGER
             The leading dimension of the array VT2.  LDVT2 .GE. M.
            </param>
             <param name="IDXP">
             (workspace) INTEGER array dimension(N)
             This will contain the permutation used to place deflated
             values of D at the end of the array. On output IDXP(2:K)
             points to the nondeflated D-values and IDXP(K+1:N)
             points to the deflated singular values.
            </param>
             <param name="IDX">
             (workspace) INTEGER array dimension(N)
             This will contain the permutation used to sort the contents of
             D into ascending order.
            </param>
             <param name="IDXC">
             (output) INTEGER array dimension(N)
             This will contain the permutation used to arrange the columns
             of the deflated U matrix into three groups:  the first group
             contains non-zero entries only at and above NL, the second
             contains non-zero entries only below NL+2, and the third is
             dense.
            </param>
             <param name="IDXQ">
             (input/output) INTEGER array dimension(N)
             This contains the permutation which separately sorts the two
             sub-problems in D into ascending order.  Note that entries in
             the first hlaf of this permutation must first be moved one
             position backward; and entries in the second half
             must first have NL+1 added to their values.
            </param>
             <param name="COLTYP">
             (workspace/output) INTEGER array dimension(N)
             As workspace, this will contain a label which will indicate
             which of the following types a column in the U2 matrix or a
             row in the VT2 matrix is:
             1 : non-zero in the upper half only
             2 : non-zero in the lower half only
             3 : dense
             4 : deflated
             
             On exit, it is an array of dimension 4, with COLTYP(I) being
             the dimension of the I-th type columns.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAS2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAS2  computes the singular values of the 2-by-2 matrix
             [  F   G  ]
             [  0   H  ].
             On return, SSMIN is the smaller singular value and SSMAX is the
             larger singular value.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAS2.Run(System.Double,System.Double,System.Double,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAS2  computes the singular values of the 2-by-2 matrix
             [  F   G  ]
             [  0   H  ].
             On return, SSMIN is the smaller singular value and SSMAX is the
             larger singular value.
             
            </summary>
             <param name="F">
             (input) DOUBLE PRECISION
             The (1,1) element of the 2-by-2 matrix.
            </param>
             <param name="G">
             (input) DOUBLE PRECISION
             The (1,2) element of the 2-by-2 matrix.
            </param>
             <param name="H">
             (input) DOUBLE PRECISION
             The (2,2) element of the 2-by-2 matrix.
            </param>
             <param name="SSMIN">
             (output) DOUBLE PRECISION
             The smaller singular value.
            </param>
             <param name="SSMAX">
             (output) DOUBLE PRECISION
             The larger singular value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARTV">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARTV applies a vector of real plane rotations to elements of the
             real vectors x and y. For i = 1,2,...,n
             
             ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
             ( y(i) )    ( -s(i)  c(i) ) ( y(i) )
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARTV.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARTV applies a vector of real plane rotations to elements of the
             real vectors x and y. For i = 1,2,...,n
             
             ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
             ( y(i) )    ( -s(i)  c(i) ) ( y(i) )
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of plane rotations to be applied.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             The vector x.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between elements of X. INCX .GT. 0.
            </param>
             <param name="Y">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCY)
             The vector y.
            </param>
             <param name="INCY">
             (input) INTEGER
             The increment between elements of Y. INCY .GT. 0.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
             The cosines of the plane rotations.
            </param>
             <param name="S">
             (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
             The sines of the plane rotations.
            </param>
             <param name="INCC">
             (input) INTEGER
             The increment between elements of C and S. INCC .GT. 0.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR1">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR1.Run(System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double[]@,System.Int32)">
             <param name="N">
             (input) integer
             Order of the matrix H. N must be either 2 or 3.
            </param>
             <param name="H">
             (input) DOUBLE PRECISION array of dimension (LDH,N)
             The 2-by-2 or 3-by-3 matrix H in (*).
            </param>
             <param name="LDH">
             (input) integer
             The leading dimension of H as declared in
             the calling procedure.  LDH.GE.N
            </param>
             <param name="SR1">
             (input) DOUBLE PRECISION
            </param>
             <param name="SI1">
             The shifts in (*).
            </param>
             <param name="V">
             (output) DOUBLE PRECISION array of dimension N
             A scalar multiple of the first column of the
             matrix K in (*).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQPS">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAQPS computes a step of QR factorization with column pivoting
             of a real M-by-N matrix A by using Blas-3.  It tries to factorize
             NB columns from A starting from the row OFFSET+1, and updates all
             of the matrix with Blas-3 xGEMM.
             
             In some cases, due to catastrophic cancellations, it cannot
             factorize NB columns.  Hence, the actual number of factorized
             columns is returned in KB.
             
             Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQPS.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAQPS computes a step of QR factorization with column pivoting
             of a real M-by-N matrix A by using Blas-3.  It tries to factorize
             NB columns from A starting from the row OFFSET+1, and updates all
             of the matrix with Blas-3 xGEMM.
             
             In some cases, due to catastrophic cancellations, it cannot
             factorize NB columns.  Hence, the actual number of factorized
             columns is returned in KB.
             
             Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A. N .GE. 0
            </param>
             <param name="OFFSET">
             (input) INTEGER
             The number of rows of A that have been factorized in
             previous steps.
            </param>
             <param name="NB">
             (input) INTEGER
             The number of columns to factorize.
            </param>
             <param name="KB">
             (output) INTEGER
             The number of columns actually factorized.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, block A(OFFSET+1:M,1:KB) is the triangular
             factor obtained and block A(1:OFFSET,1:N) has been
             accordingly pivoted, but no factorized.
             The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
             been updated.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="JPVT">
             (input/output) INTEGER array, dimension (N)
             JPVT(I) = K .LE.=.GT. Column K of the full matrix A has been
             permuted into position I in AP.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (KB)
             The scalar factors of the elementary reflectors.
            </param>
             <param name="VN1">
             (input/output) DOUBLE PRECISION array, dimension (N)
             The vector with the partial column norms.
            </param>
             <param name="VN2">
             (input/output) DOUBLE PRECISION array, dimension (N)
             The vector with the exact column norms.
            </param>
             <param name="AUXV">
             (input/output) DOUBLE PRECISION array, dimension (NB)
             Auxiliar vector.
            </param>
             <param name="F">
             (input/output) DOUBLE PRECISION array, dimension (LDF,NB)
             Matrix F' = L*Y'*A.
            </param>
             <param name="LDF">
             (input) INTEGER
             The leading dimension of the array F. LDF .GE. max(1,N).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANSY">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLANSY  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real symmetric matrix A.
             
             Description
             ===========
             
             DLANSY returns the value
             
             DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANSY.Run(System.String,System.String,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLANSY  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real symmetric matrix A.
             
             Description
             ===========
             
             DLANSY returns the value
             
             DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies the value to be returned in DLANSY as described
             above.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the upper or lower triangular part of the
             symmetric matrix A is to be referenced.
             = 'U':  Upper triangular part of A is referenced
             = 'L':  Lower triangular part of A is referenced
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.  When N = 0, DLANSY is
             set to zero.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The symmetric matrix A.  If UPLO = 'U', the leading n by n
             upper triangular part of A contains the upper triangular part
             of the matrix A, and the strictly lower triangular part of A
             is not referenced.  If UPLO = 'L', the leading n by n lower
             triangular part of A contains the lower triangular part of
             the matrix A, and the strictly upper triangular part of A is
             not referenced.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(N,1).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
             where LWORK .GE. N when NORM = 'I' or '1' or 'O'; otherwise,
             WORK is not referenced.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLALN2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLALN2 solves a system of the form  (ca A - w D ) X = s B
             or (ca A' - w D) X = s B   with possible scaling ("s") and
             perturbation of A.  (A' means A-transpose.)
             
             A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
             real diagonal matrix, w is a real or complex value, and X and B are
             NA x 1 matrices -- real if w is real, complex if w is complex.  NA
             may be 1 or 2.
             
             If w is complex, X and B are represented as NA x 2 matrices,
             the first column of each being the real part and the second
             being the imaginary part.
             
             "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
             so chosen that X can be computed without overflow.  X is further
             scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
             than overflow.
             
             If both singular values of (ca A - w D) are less than SMIN,
             SMIN*identity will be used instead of (ca A - w D).  If only one
             singular value is less than SMIN, one element of (ca A - w D) will be
             perturbed enough to make the smallest singular value roughly SMIN.
             If both singular values are at least SMIN, (ca A - w D) will not be
             perturbed.  In any case, the perturbation will be at most some small
             multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
             are computed by infinity-norm approximations, and thus will only be
             correct to a factor of 2 or so.
             
             Note: all input quantities are assumed to be smaller than overflow
             by a reasonable factor.  (See BIGNUM.)
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLALN2.Run(System.Boolean,System.Int32,System.Int32,System.Double,System.Double,System.Double[],System.Int32,System.Int32,System.Double,System.Double,System.Double[],System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32,System.Double@,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLALN2 solves a system of the form  (ca A - w D ) X = s B
             or (ca A' - w D) X = s B   with possible scaling ("s") and
             perturbation of A.  (A' means A-transpose.)
             
             A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
             real diagonal matrix, w is a real or complex value, and X and B are
             NA x 1 matrices -- real if w is real, complex if w is complex.  NA
             may be 1 or 2.
             
             If w is complex, X and B are represented as NA x 2 matrices,
             the first column of each being the real part and the second
             being the imaginary part.
             
             "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
             so chosen that X can be computed without overflow.  X is further
             scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
             than overflow.
             
             If both singular values of (ca A - w D) are less than SMIN,
             SMIN*identity will be used instead of (ca A - w D).  If only one
             singular value is less than SMIN, one element of (ca A - w D) will be
             perturbed enough to make the smallest singular value roughly SMIN.
             If both singular values are at least SMIN, (ca A - w D) will not be
             perturbed.  In any case, the perturbation will be at most some small
             multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
             are computed by infinity-norm approximations, and thus will only be
             correct to a factor of 2 or so.
             
             Note: all input quantities are assumed to be smaller than overflow
             by a reasonable factor.  (See BIGNUM.)
             
            </summary>
             <param name="LTRANS">
             (input) LOGICAL
             =.TRUE.:  A-transpose will be used.
             =.FALSE.: A will be used (not transposed.)
            </param>
             <param name="NA">
             (input) INTEGER
             The size of the matrix A.  It may (only) be 1 or 2.
            </param>
             <param name="NW">
             (input) INTEGER
             1 if "w" is real, 2 if "w" is complex.  It may only be 1
             or 2.
            </param>
             <param name="SMIN">
             (input) DOUBLE PRECISION
             The desired lower bound on the singular values of A.  This
             should be a safe distance away from underflow or overflow,
             say, between (underflow/machine precision) and  (machine
             precision * overflow ).  (See BIGNUM and ULP.)
            </param>
             <param name="CA">
             (input) DOUBLE PRECISION
             The coefficient c, which A is multiplied by.
            </param>
             <param name="A">
             is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of A.  It must be at least NA.
            </param>
             <param name="D1">
             (input) DOUBLE PRECISION
             The 1,1 element in the diagonal matrix D.
            </param>
             <param name="D2">
             (input) DOUBLE PRECISION
             The 2,2 element in the diagonal matrix D.  Not used if NW=1.
            </param>
             <param name="B">
             (input) DOUBLE PRECISION array, dimension (LDB,NW)
             The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
             complex), column 1 contains the real part of B and column 2
             contains the imaginary part.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of B.  It must be at least NA.
            </param>
             <param name="WR">
             (input) DOUBLE PRECISION
             The real part of the scalar "w".
            </param>
             <param name="WI">
             (input) DOUBLE PRECISION
             The imaginary part of the scalar "w".  Not used if NW=1.
            </param>
             <param name="X">
             (output) DOUBLE PRECISION array, dimension (LDX,NW)
             The NA x NW matrix X (unknowns), as computed by DLALN2.
             If NW=2 ("w" is complex), on exit, column 1 will contain
             the real part of X and column 2 will contain the imaginary
             part.
            </param>
             <param name="LDX">
             (input) INTEGER
             The leading dimension of X.  It must be at least NA.
            </param>
             <param name="SCALE">
             (output) DOUBLE PRECISION
             The scale factor that B must be multiplied by to insure
             that overflow does not occur when computing X.  Thus,
             (ca A - w D) X  will be SCALE*B, not B (ignoring
             perturbations of A.)  It will be at most 1.
            </param>
             <param name="XNORM">
             (output) DOUBLE PRECISION
             The infinity-norm of X, when X is regarded as an NA x NW
             real matrix.
            </param>
             <param name="INFO">
             (output) INTEGER
             An error flag.  It will be set to zero if no error occurs,
             a negative number if an argument is in error, or a positive
             number if  ca A - w D  had to be perturbed.
             The possible values are:
             = 0: No error occurred, and (ca A - w D) did not have to be
             perturbed.
             = 1: (ca A - w D) had to be perturbed to make its smallest
             (or only) singular value greater than SMIN.
             NOTE: In the interests of speed, this routine does not
             check the inputs for errors.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.OdeAdamsMoulton">
            <summary>
            Solves an initial-value problem for nonstiff ordinary differential equations using 
            the Adams-Moulton method.
            dy(i)/dt = f(i,t,y(1),y(2),...,y(N)).
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton">
            <summary>
            Represents a base class for the Adams-Moulton and Gears BDF classes. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton._ITask">
             <summary>
            MeITask=1 means normal computation of output values of y(t) at t = TOUT (by overshooting and interpolating).
             </summary>
        </member>
        <member name="F:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton._IState">
            <summary>
            MeIState= an index used for input and output to specify the the state of the calculation.
            In the input, the values of ISTATE are as follows.
            MeIState=1  means this is the first call for the problem (initializations will be done).
            MeIState=2  means this is not the first call, and the calculation is to continue normally.
            In the output, ISTATE has the following values and meanings.
            MeIState=1 means nothing was done, as TOUT was equal to T with ISTATE = 1 in the input.
            MeIState=2  means the integration was performed successfully.
            MeIState .LT. 0 Error
            MeIState=-1 means an excessive amount of work (more than MXSTEP steps) was done on this call, before completing the
            requested task, but the integration was otherwise successful as far as T.  (MXSTEP is an optional input and is normally 500.)
            MeIState=-2  means too much accuracy was requested for the precision of the machine being used.
            MeIState=-3  means illegal input was detected
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton._IOpt">
            <summary>
            MeIOpt= An integer flag to specify whether or not any optional input is being used on this call.
            MeIOpt= 0 means no optional input is being used.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton._Mf">
            <summary>
            MeMf= The method flag.
            MeMf=10, NonStiff. 
            MeMf=21 Stiff  con Jacobiano.
            MeMf=22 Stiff sin Jacobiano.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.InicializacionWithoutJacobiano(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.ODEType,System.Int32)">
            <summary>
            Inicialize the ODE solver without a Jacobiano
            </summary>
            <param name="Func">The function that define the ODEs.</param>
            <param name="type">The Ode type (stiff, nonstiff).</param>
            <param name="numEquations">The number of equatins.</param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.InicializacionWithJacobiano(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32)">
            <summary>
            Inicialize the ODE solver with a Jacobiano
            </summary>
            <param name="Func">The function that define the ODEs.</param>
            <param name="Jac">The Ode type (stiff, nonstiff).</param>
            <param name="numEquations">The number of equatins.</param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.Solve(System.Double)">
            <summary>
            Computes the solution of the differntial equations at a point (tEnd).
            </summary>
            <param name="tEnd">Value of t where the solution is required.</param>
            <returns>A array containing the solution of the differential equations at the point tEnd.</returns>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.Solve(System.Double[],System.Double[])">
            <summary>
             Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions ( at t0). N is the number of differential equations.</param>
            <param name="tspan">A vector specifying the interval of integration (t0,..,tf).</param>
            <returns>
            A matrix that contains the solution of the differential equations [T, y1,..,yN]. 
            The first column contains the time points and each row corresponds to the solution at a time returned in the corresponding row.
            </returns>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.Solve(System.Double[],System.Double,System.Double,System.Double)">
            <summary>
            Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <param name="t0">The initial independent variable value.</param>
            <param name="deltaT">The step for the interval of integration (t0, t0+deltaT, t0+2*deltaT,...,tf).</param>
            <param name="tf">The final independent variable value.</param>
            <returns>
            A matrix that contains the solution of the differential equations [T, y1,..,yN]. 
            The first column contains the time points and each row corresponds to the solution at a time returned in the corresponding row.
            </returns>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.Solve(System.Double[],System.Double,System.Double,System.Double,DotNumerics.ODE.OdeSolution)">
            <summary>
            Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <param name="t0">The initial independent variable value.</param>
            <param name="deltaT">The step for the interval of integration (t0, t0+deltaT, t0+2*deltaT,...,tf).</param>
            <param name="tf">The final independent variable value.</param>
            <param name="solution">A delegate where to return the solution.</param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.Solve(System.Double[],System.Double[],DotNumerics.ODE.OdeSolution)">
            <summary>
             Computes the solution of the differntial equations.
            </summary>
            <param name="y0">A vector of size N containing the initial conditions ( at t0). N is the number of differential equations.</param>
            <param name="tspan">A vector specifying the interval of integration (t0,..,tf).</param>
            <param name="solution">A delegate where to return the solution.</param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.SetInitialValues(System.Double,System.Double[])">
            <summary>
            Sets the initial values for the differential equations.
            </summary>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
            <remarks>
            This method should be invoked before to start the integration.
            When this method is invoked, the ODE solver is restarted.
            </remarks>
        </member>
        <member name="M:DotNumerics.ODE.DVode.xBaseOdeGearsAndAdamsMoulton.InitializeWorkingSpace">
            <summary>
            Inicializa elespacio nesesitado por la surutinas. Se requiere que estend dedfinidas las proiedades
            que definen dicho espacio, por ejemplo el numero de equaciones.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeAdamsMoulton.#ctor">
            <summary>
            Initializes a new instance of the OdeAdamsMoulton class.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeAdamsMoulton.#ctor(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Initializes a new instance of the OdeAdamsMoulton class.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeAdamsMoulton.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeAdamsMoulton.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.Vector">
            <summary>
            Represents a Vector.
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.Vector._Data">
            <summary>
            Los datos del vector
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.Vector._Type">
            <summary>
            El tipo de vector.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the Vector class of the given size.
            </summary>
            <param name="length">The vector length</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.#ctor(DotNumerics.LinearAlgebra.VectorType,System.Int32)">
            <summary>
            Initializes a new instance of the Vector class of the given size and type.
            </summary>
            <param name="type">The vector type</param>
            <param name="length">length">The vector length</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.#ctor(System.Double[])">
            <summary>
            Initializes a new instance of the Vector class that contains elements 
            copied from the specified array.
            </summary>
            <param name="data">The array whose elements are copied to the vector.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.#ctor(DotNumerics.LinearAlgebra.VectorType,System.Double[])">
            <summary>
            Initializes a new instance of the Vector class that contains elements
            copied from the specified array.
            </summary>
            <param name="type">The vector type</param>
            <param name="data">The array whose elements are copied to the vector.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Addition(DotNumerics.LinearAlgebra.Vector,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Vector addition.
            </summary>
            <param name="A">The left side vector of the addition operator.</param>
            <param name="B">The right side vector of the addition operator.</param>
            <returns>A vector that represents the result of the addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_UnaryNegation(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Unary minus.
            </summary>
            <param name="v">The vector.</param>
            <returns>Vector r[i] = -this[i]</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Subtraction(DotNumerics.LinearAlgebra.Vector,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Vector subtraction.
            </summary>
            <param name="A"> The left side vector of the subtraction operator.</param>
            <param name="B">The right side vector of the subtraction operator.</param>
            <returns>A vector that represents the result of the vector subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Multiply(System.Double,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Scalar-Vector multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side vector of the multiplication operator.</param>
            <returns>A vector that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Multiply(DotNumerics.LinearAlgebra.Vector,System.Double)">
            <summary>
            Vector-Scalar multiplication.
            </summary>
            <param name="A">The left side vector of the multiplication operator.</param>
            <param name="s"> The right side scalar of the multiplication operator.</param>
            <returns>A vector that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.DotProduct(DotNumerics.LinearAlgebra.Vector,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Dot product or scalar product.
            </summary>
            <param name="A"> The left side vector of the operator.</param>
            <param name="B">The right side vector of the operator.</param>
            <remarks>
            The dot product is the result of multiplying all the components of two vectors together and adding the results, res= Sum(A[i]*B[i]).
            </remarks>
            <returns>The dot product = Sum(A[i]*B[i])</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.DotProduct(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Dot product of this vector with another vector.
            </summary>
            <param name="B">The other vector.</param>
            <remarks>
            The dot product is the result of multiplying all the components of two vectors together and adding the results, res= Sum(A[i]*B[i]).
            </remarks>
            <returns>r = Sum(this[i]*B[i])</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Transpose">
            <summary>
            Transposed vector.
            </summary>
            <returns>The transposed vector.</returns>
            <remarks>
            Transposition turns a row vector into a column vector ( Or a column vector into a row vector).
            </remarks>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Multiply(DotNumerics.LinearAlgebra.BaseMatrix,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Matrix- Vector multiplication.
            </summary>
            <param name="A"> The left side matrix of the multiplication operator.</param>
            <param name="B">The right side vector of the multiplication operator.</param>
            <returns>A matrix that represents the result of the matrix multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.op_Implicit(DotNumerics.LinearAlgebra.Vector)~DotNumerics.LinearAlgebra.Matrix">
            <summary>
            Implicit Vector to Matrix conversion.
            </summary>
            <param name="V">The Vector</param>
            <returns>The Matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.ToArray">
            <summary>
             Copies the elements of this vector to a new array.
            </summary>
            <returns>An array containing copies of the elements of this vector.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Add(System.Double)">
            <summary>
            Add a scalar to all elements of this vector.
            </summary>
            <param name="s">The scalar.</param>
            <returns>
            Vector r[i] = this[i] + s
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.AddInplace(System.Double)">
            <summary>
            In place add a scalar to all elements of this vector.
            </summary>
            <param name="s">The scalar.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Add(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Add a Vector.
            </summary>
            <param name="B">The vector B.</param>
            <returns>
            Vector r[i] = this[i] + B[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.AddInplace(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            In place add a Vector.
            </summary>
            <param name="B">The vector B.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Subtract(System.Double)">
            <summary>
            Subtract a scalar to all elements of this vector.
            </summary>
            <param name="s">The scalar.</param>
            <returns>
            Vector r[i] = this[i] - s
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.SubtractInplace(System.Double)">
            <summary>
            In place subtract a scalar to all elements of this vector.
            </summary>
            <param name="s">The scalar.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Subtract(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Subtract a Vector.
            </summary>
            <param name="B">The vector B.</param>
            <returns>
            Vector r[i] = this[i] - B[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.SubtractInplace(DotNumerics.LinearAlgebra.Vector)">
            <summary>
            In place add a Vector.
            </summary>
            <param name="B">The vector B.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Multiply(System.Double)">
            <summary>
            Multiply a scalar to all elements of this vector.
            </summary>
            <param name="s">The scalar.</param>
            <returns>
            Vector r[i] = this[i] * s
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.MultiplyInplace(System.Double)">
            <summary>
            In place multiply this vector with a scalar.
            </summary>
            <param name="scalar">The scalar </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.UnaryMinus">
            <summary>
            Unary minus.
            </summary>
            <returns>
            Vector r[i] = -this[i]
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.UnaryMinusInplace">
            <summary>
            In place unary minus of this vector.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Norm">
            <summary>
            Calculate the norm of the vector (The 2-norm of the vector). 
            </summary>
            <remarks>
            The 2-norm of a vector is the square root of the sum of squares of the vector coefficients.
            res = sum(u[i]^2)
            </remarks>
            <returns>The norm</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Norm1">
            <summary>
            Calculate the 1-norm of the vector.
            </summary>
            <returns>
            r = sum(abs(this[i]))
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.NormP(System.Int32)">
            <summary>
            Calculate the p-Norm.
            </summary>
            <returns>
            res = Sum(abs(u[i])^p))^(1/p)
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.NormInf">
            <summary>
            Infinity-Norm.
            </summary>
            <returns>
            res = max(abs(u[i]))
            </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Normalize">
            <summary>
            Normalizes this vector to a unit vector with respect to the Eucliden 2-Norm.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.Clone">
            <summary>
            Creates a copy of the vector.
            </summary>
            <returns>The copy of the vector.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Vector.VectorToString">
            <summary>
            Returns the equivalent string representation of the vector.
            </summary>
            <returns>The string representation of the vector.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.Vector.Data">
            <summary>
            Los datos del vector
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.Vector.Length">
            <summary>
            Returns the number of elements.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.Vector.Type">
            <summary>
            The vector type.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.Vector.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.SingularValueDecomposition">
            <summary>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A.
            </summary>
            <remarks>
            The SVD is written
            
            A = U * S * transpose(V)
            
            where S is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of S
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            
            Note that the routine returns V**T, not V.
            </remarks>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SingularValueDecomposition.#ctor">
            <summary>
            Initializes a new instance of the SingularValues class.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SingularValueDecomposition.ComputeSVD(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix@)">
             <summary>
            Computes the singular value decomposition (SVD) of a real
             M-by-N matrix A.
             The SVD is written
             A = U * S * transpose(V)
             </summary>
             <param name="A">The A matrix.</param>
             <param name="S">The diagonal elements of S are the singular values of A.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SingularValueDecomposition.ComputeSVD(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Vector@)">
             <summary>
            Computes the singular value decomposition (SVD) of a real
             M-by-N matrix A.
             The SVD is written
             A = U * S * transpose(V)
             </summary>
             <param name="A">The A matrix.</param>
             <param name="S">A vector of singular values.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SingularValueDecomposition.ComputeSVD(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix@,DotNumerics.LinearAlgebra.Matrix@,DotNumerics.LinearAlgebra.Matrix@)">
             <summary>
            Computes the singular value decomposition (SVD) of a real
             M-by-N matrix A.
             The SVD is written
             A = U * S * transpose(V)
             </summary>
             <param name="A">The A matrix.</param>
             <param name="S">The diagonal elements of S are the singular values of A.</param>
             <param name="U">The U matrix, U is an M-by-M orthogonal matrix</param>
             <param name="VT">the transpose(V), V is an N-by-N orthogonal matrix.</param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.IEEECK">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             IEEECK is called from the ILAENV to verify that Infinity and
             possibly NaN arithmetic is safe (i.e. will not trap).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.IEEECK.Run(System.Int32,System.Double,System.Double)">
             <summary>
             Purpose
             =======
             
             IEEECK is called from the ILAENV to verify that Infinity and
             possibly NaN arithmetic is safe (i.e. will not trap).
             
            </summary>
             <param name="ISPEC">
             (input) INTEGER
             Specifies whether to test just for inifinity arithmetic
             or whether to test for infinity and NaN arithmetic.
             = 0: Verify infinity arithmetic only.
             = 1: Verify infinity and NaN arithmetic.
            </param>
             <param name="ZERO">
             (input) REAL
             Must contain the value 0.0
             This is passed to prevent the compiler from optimizing
             away this code.
            </param>
             <param name="ONE">
             (input) REAL
             Must contain the value 1.0
             This is passed to prevent the compiler from optimizing
             away this code.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYEV">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSYEV computes all eigenvalues and, optionally, eigenvectors of a
             real symmetric matrix A.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYEV.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSYEV computes all eigenvalues and, optionally, eigenvectors of a
             real symmetric matrix A.
             
            </summary>
             <param name="JOBZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only;
             = 'V':  Compute eigenvalues and eigenvectors.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA, N)
             On entry, the symmetric matrix A.  If UPLO = 'U', the
             leading N-by-N upper triangular part of A contains the
             upper triangular part of the matrix A.  If UPLO = 'L',
             the leading N-by-N lower triangular part of A contains
             the lower triangular part of the matrix A.
             On exit, if JOBZ = 'V', then if INFO = 0, A contains the
             orthonormal eigenvectors of the matrix A.
             If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
             or the upper triangle (if UPLO='U') of A, including the
             diagonal, is destroyed.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             If INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The length of the array WORK.  LWORK .GE. max(1,3*N-1).
             For optimal efficiency, LWORK .GE. (NB+2)*N,
             where NB is the blocksize for DSYTRD returned by ILAENV.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, the algorithm failed to converge; i
             off-diagonal elements of an intermediate tridiagonal
             form did not converge to zero.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASV2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASV2 computes the singular value decomposition of a 2-by-2
             triangular matrix
             [  F   G  ]
             [  0   H  ].
             On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
             smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
             right singular vectors for abs(SSMAX), giving the decomposition
             
             [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
             [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASV2.Run(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLASV2 computes the singular value decomposition of a 2-by-2
             triangular matrix
             [  F   G  ]
             [  0   H  ].
             On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
             smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
             right singular vectors for abs(SSMAX), giving the decomposition
             
             [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
             [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
             
            </summary>
             <param name="F">
             (input) DOUBLE PRECISION
             The (1,1) element of the 2-by-2 matrix.
            </param>
             <param name="G">
             (input) DOUBLE PRECISION
             The (1,2) element of the 2-by-2 matrix.
            </param>
             <param name="H">
             (input) DOUBLE PRECISION
             The (2,2) element of the 2-by-2 matrix.
            </param>
             <param name="SSMIN">
             (output) DOUBLE PRECISION
             abs(SSMIN) is the smaller singular value.
            </param>
             <param name="SSMAX">
             (output) DOUBLE PRECISION
             abs(SSMAX) is the larger singular value.
            </param>
             <param name="SNR">
             (output) DOUBLE PRECISION
            </param>
             <param name="CSR">
             (output) DOUBLE PRECISION
             The vector (CSR, SNR) is a unit right singular vector for the
             singular value abs(SSMAX).
            </param>
             <param name="SNL">
             (output) DOUBLE PRECISION
            </param>
             <param name="CSL">
             (output) DOUBLE PRECISION
             The vector (CSL, SNL) is a unit left singular vector for the
             singular value abs(SSMAX).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD1">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
             where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.
             
             A related subroutine DLASD7 handles the case in which the singular
             values (and the singular vectors in factored form) are desired.
             
             DLASD1 computes the SVD as follows:
             
             ( D1(in)  0    0     0 )
             B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
             (   0     0   D2(in) 0 )
             
             = U(out) * ( D(out) 0) * VT(out)
             
             where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
             with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
             elsewhere; and the entry b is empty if SQRE = 0.
             
             The left singular vectors of the original matrix are stored in U, and
             the transpose of the right singular vectors are stored in VT, and the
             singular values are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple singular values or when there are zeros in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLASD2.
             
             The second stage consists of calculating the updated
             singular values. This is done by finding the square roots of the
             roots of the secular equation via the routine DLASD4 (as called
             by DLASD3). This routine also calculates the singular vectors of
             the current problem.
             
             The final stage consists of computing the updated singular vectors
             directly using the updated singular values.  The singular vectors
             for the current problem are multiplied with the singular vectors
             from the overall problem.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD1.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double@,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
             where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.
             
             A related subroutine DLASD7 handles the case in which the singular
             values (and the singular vectors in factored form) are desired.
             
             DLASD1 computes the SVD as follows:
             
             ( D1(in)  0    0     0 )
             B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
             (   0     0   D2(in) 0 )
             
             = U(out) * ( D(out) 0) * VT(out)
             
             where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
             with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
             elsewhere; and the entry b is empty if SQRE = 0.
             
             The left singular vectors of the original matrix are stored in U, and
             the transpose of the right singular vectors are stored in VT, and the
             singular values are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple singular values or when there are zeros in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLASD2.
             
             The second stage consists of calculating the updated
             singular values. This is done by finding the square roots of the
             roots of the secular equation via the routine DLASD4 (as called
             by DLASD3). This routine also calculates the singular vectors of
             the current problem.
             
             The final stage consists of computing the updated singular vectors
             directly using the updated singular values.  The singular vectors
             for the current problem are multiplied with the singular vectors
             from the overall problem.
             
            </summary>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block.  NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block.  NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has row dimension N = NL + NR + 1,
             and column dimension M = N + SQRE.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array,
             dimension (N = NL+NR+1).
             On entry D(1:NL,1:NL) contains the singular values of the
             upper block; and D(NL+2:N) contains the singular values of
             the lower block. On exit D(1:N) contains the singular values
             of the modified matrix.
            </param>
             <param name="ALPHA">
             (input/output) DOUBLE PRECISION
             Contains the diagonal element associated with the added row.
            </param>
             <param name="BETA">
             (input/output) DOUBLE PRECISION
             Contains the off-diagonal element associated with the added
             row.
            </param>
             <param name="U">
             (input/output) DOUBLE PRECISION array, dimension(LDU,N)
             On entry U(1:NL, 1:NL) contains the left singular vectors of
             the upper block; U(NL+2:N, NL+2:N) contains the left singular
             vectors of the lower block. On exit U contains the left
             singular vectors of the bidiagonal matrix.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. max( 1, N ).
            </param>
             <param name="VT">
             (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
             where M = N + SQRE.
             On entry VT(1:NL+1, 1:NL+1)' contains the right singular
             vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
             the right singular vectors of the lower block. On exit
             VT' contains the right singular vectors of the
             bidiagonal matrix.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. max( 1, M ).
            </param>
             <param name="IDXQ">
             (output) INTEGER array, dimension(N)
             This contains the permutation which will reintegrate the
             subproblem just solved back into sorted order, i.e.
             D( IDXQ( I = 1, N ) ) will be in ascending order.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension( 4 * N )
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARFX">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARFX applies a real elementary reflector H to a real m by n
             matrix C, from either the left or the right. H is represented in the
             form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix
             
             This version uses inline code if H has order .LT. 11.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARFX.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARFX applies a real elementary reflector H to a real m by n
             matrix C, from either the left or the right. H is represented in the
             form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix
             
             This version uses inline code if H has order .LT. 11.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': form  H * C
             = 'R': form  C * H
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C.
            </param>
             <param name="V">
             (input) DOUBLE PRECISION array, dimension (M) if SIDE = 'L'
             or (N) if SIDE = 'R'
             The vector v in the representation of H.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION
             The value tau in the representation of H.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the m by n matrix C.
             On exit, C is overwritten by the matrix H * C if SIDE = 'L',
             or C * H if SIDE = 'R'.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDA .GE. (1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L'
             or (M) if SIDE = 'R'
             WORK is not referenced if H has order .LT. 11.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARFG">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARFG generates a real elementary reflector H of order n, such
             that
             
             H * ( alpha ) = ( beta ),   H' * H = I.
             (   x   )   (   0  )
             
             where alpha and beta are scalars, and x is an (n-1)-element real
             vector. H is represented in the form
             
             H = I - tau * ( 1 ) * ( 1 v' ) ,
             ( v )
             
             where tau is a real scalar and v is a real (n-1)-element
             vector.
             
             If the elements of x are all zero, then tau = 0 and H is taken to be
             the unit matrix.
             
             Otherwise  1 .LE. tau .LE. 2.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARFG.Run(System.Int32,System.Double@,System.Double[]@,System.Int32,System.Int32,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLARFG generates a real elementary reflector H of order n, such
             that
             
             H * ( alpha ) = ( beta ),   H' * H = I.
             (   x   )   (   0  )
             
             where alpha and beta are scalars, and x is an (n-1)-element real
             vector. H is represented in the form
             
             H = I - tau * ( 1 ) * ( 1 v' ) ,
             ( v )
             
             where tau is a real scalar and v is a real (n-1)-element
             vector.
             
             If the elements of x are all zero, then tau = 0 and H is taken to be
             the unit matrix.
             
             Otherwise  1 .LE. tau .LE. 2.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the elementary reflector.
            </param>
             <param name="ALPHA">
             (input/output) DOUBLE PRECISION
             On entry, the value alpha.
             On exit, it is overwritten with the value beta.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array, dimension
             (1+(N-2)*abs(INCX))
             On entry, the vector x.
             On exit, it is overwritten with the vector v.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between elements of X. INCX .GT. 0.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION
             The value tau.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR0">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAQR0 computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR0.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAQR0 computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
             <param name="WANTT">
             (input) LOGICAL
             = .TRUE. : the full Schur form T is required;
             = .FALSE.: only eigenvalues are required.
            </param>
             <param name="WANTZ">
             (input) LOGICAL
             = .TRUE. : the matrix of Schur vectors Z is required;
             = .FALSE.: Schur vectors are not required.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to DGEBAL, and then passed to DGEHRD when the
             matrix output by DGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </param>
             <param name="LDH">
             (input) INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </param>
             <param name="WR">
             (output) DOUBLE PRECISION array, dimension (IHI)
            </param>
             <param name="WI">
             (output) DOUBLE PRECISION array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             
             If LWORK = -1, then DLAQR0 does a workspace query.
             In this case, DLAQR0 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
             
            </param>
             <param name="INFO">
             (output) INTEGER
             =  0:  successful exit
             .GT. 0:  if INFO = i, DLAQR0 failed to compute all of
             the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
             and WI contain those eigenvalues which have been
             successfully computed.  (Failures are rare.)
             
             If INFO .GT. 0 and WANT is .FALSE., then on exit,
             the remaining unconverged eigenvalues are the eigen-
             values of the upper Hessenberg matrix rows and
             columns ILO through INFO of the final, output
             value of H.
             
             If INFO .GT. 0 and WANTT is .TRUE., then on exit
             
             (*)  (initial value of H)*U  = U*(final value of H)
             
             where U is an orthogonal matrix.  The final
             value of H is upper Hessenberg and quasi-triangular
             in rows and columns INFO+1 through IHI.
             
             If INFO .GT. 0 and WANTZ is .TRUE., then on exit
             
             (final value of Z(ILO:IHI,ILOZ:IHIZ)
             =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
             
             where U is the orthogonal matrix in (*) (regard-
             less of the value of WANTT.)
             
             If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
             accessed.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMRG">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMRG will create a permutation list which will merge the elements
             of A (which is composed of two independently sorted sets) into a
             single set which is sorted in ascending order.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMRG.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAMRG will create a permutation list which will merge the elements
             of A (which is composed of two independently sorted sets) into a
             single set which is sorted in ascending order.
             
            </summary>
             <param name="N1">
             (input) INTEGER
            </param>
             <param name="N2">
             (input) INTEGER
             These arguements contain the respective lengths of the two
             sorted lists to be merged.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (N1+N2)
             The first N1 elements of A contain a list of numbers which
             are sorted in either ascending or descending order.  Likewise
             for the final N2 elements.
            </param>
             <param name="DTRD1">
             (input) INTEGER
            </param>
             <param name="DTRD2">
             (input) INTEGER
             These are the strides to be taken through the array A.
             Allowable strides are 1 and -1.  They indicate whether a
             subset of A is sorted in ascending (DTRDx = 1) or descending
             (DTRDx = -1) order.
            </param>
             <param name="INDEX">
             (output) INTEGER array, dimension (N1+N2)
             On exit this array will contain a permutation such that
             if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
             sorted in ascending order.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAEDA">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAEDA computes the Z vector corresponding to the merge step in the
             CURLVLth step of the merge process with TLVLS steps for the CURPBMth
             problem.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAEDA.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAEDA computes the Z vector corresponding to the merge step in the
             CURLVLth step of the merge process with TLVLS steps for the CURPBMth
             problem.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="TLVLS">
             (input) INTEGER
             The total number of merging levels in the overall divide and
             conquer tree.
            </param>
             <param name="CURLVL">
             (input) INTEGER
             The current level in the overall merge routine,
             0 .LE. curlvl .LE. tlvls.
            </param>
             <param name="CURPBM">
             (input) INTEGER
             The current problem in the current level in the overall
             merge routine (counting from upper left to lower right).
            </param>
             <param name="PRMPTR">
             (input) INTEGER array, dimension (N lg N)
             Contains a list of pointers which indicate where in PERM a
             level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
             indicates the size of the permutation and incidentally the
             size of the full, non-deflated problem.
            </param>
             <param name="PERM">
             (input) INTEGER array, dimension (N lg N)
             Contains the permutations (from deflation and sorting) to be
             applied to each eigenblock.
            </param>
             <param name="GIVPTR">
             (input) INTEGER array, dimension (N lg N)
             Contains a list of pointers which indicate where in GIVCOL a
             level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
             indicates the number of Givens rotations.
            </param>
             <param name="GIVCOL">
             (input) INTEGER array, dimension (2, N lg N)
             Each pair of numbers indicates a pair of columns to take place
             in a Givens rotation.
            </param>
             <param name="GIVNUM">
             (input) DOUBLE PRECISION array, dimension (2, N lg N)
             Each number indicates the S value to be used in the
             corresponding Givens rotation.
            </param>
             <param name="Q">
             (input) DOUBLE PRECISION array, dimension (N**2)
             Contains the square eigenblocks from previous levels, the
             starting positions for blocks are given by QPTR.
            </param>
             <param name="QPTR">
             (input) INTEGER array, dimension (N+2)
             Contains a list of pointers which indicate where in Q an
             eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
             the size of the block.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension (N)
             On output this vector contains the updating vector (the last
             row of the first sub-eigenvector matrix and the first row of
             the second sub-eigenvector matrix).
            </param>
             <param name="ZTEMP">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLACON">
             <summary>
             -- LAPACK auxiliary routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             February 29, 1992
             Purpose
             =======
             
             DLACON estimates the 1-norm of a square, real matrix A.
             Reverse communication is used for evaluating matrix-vector products.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLACON.Run(System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLACON estimates the 1-norm of a square, real matrix A.
             Reverse communication is used for evaluating matrix-vector products.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix.  N .GE. 1.
            </param>
             <param name="V">
             (workspace) DOUBLE PRECISION array, dimension (N)
             On the final return, V = A*W,  where  EST = norm(V)/norm(W)
             (W is not returned).
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On an intermediate return, X should be overwritten by
             A * X,   if KASE=1,
             A' * X,  if KASE=2,
             and DLACON must be re-called with all the other parameters
             unchanged.
            </param>
             <param name="ISGN">
             (workspace) INTEGER array, dimension (N)
            </param>
             <param name="EST">
             (output) DOUBLE PRECISION
             An estimate (a lower bound) for norm(A).
            </param>
             <param name="KASE">
             (input/output) INTEGER
             On the initial call to DLACON, KASE should be 0.
             On an intermediate return, KASE will be 1 or 2, indicating
             whether X should be overwritten by A * X  or A' * X.
             On the final return from DLACON, KASE will again be 0.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGETRF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGETRF computes an LU factorization of a general M-by-N matrix A
             using partial pivoting with row interchanges.
             
             The factorization has the form
             A = P * L * U
             where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m .GT. n), and U is upper
             triangular (upper trapezoidal if m .LT. n).
             
             This is the right-looking Level 3 BLAS version of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGETRF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGETRF computes an LU factorization of a general M-by-N matrix A
             using partial pivoting with row interchanges.
             
             The factorization has the form
             A = P * L * U
             where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m .GT. n), and U is upper
             triangular (upper trapezoidal if m .LT. n).
             
             This is the right-looking Level 3 BLAS version of the algorithm.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix to be factored.
             On exit, the factors L and U from the factorization
             A = P*L*U; the unit diagonal elements of L are not stored.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (min(M,N))
             The pivot indices; for 1 .LE. i .LE. min(M,N), row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, U(i,i) is exactly zero. The factorization
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEHD2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
             an orthogonal similarity transformation:  Q' * A * Q = H .
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEHD2.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
             an orthogonal similarity transformation:  Q' * A * Q = H .
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that A is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to DGEBAL; otherwise they should be
             set to 1 and N respectively. See Further Details.
             1 .LE. ILO .LE. IHI .LE. max(1,N).
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the n by n general matrix to be reduced.
             On exit, the upper triangle and the first subdiagonal of A
             are overwritten with the upper Hessenberg matrix H, and the
             elements below the first subdiagonal, with the array TAU,
             represent the orthogonal matrix Q as a product of elementary
             reflectors. See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.COMQR2.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement.
            </param>
             <param name="N">
             is the order of the matrix.
            </param>
             <param name="LOW">
             and igh are integers determined by the balancing
             subroutine  cbal.  if  cbal  has not been used,
             set low=1, igh=n.
            </param>
             <param name="ORTR">
             and orti contain information about the unitary trans-
             formations used in the reduction by  corth, if performed.
             only elements low through igh are used.  if the eigenvectors
             of the hessenberg matrix are desired, set ortr(j) and
             orti(j) to 0.0d0 for these elements.
            </param>
             <param name="HR">
             and hi contain the real and imaginary parts,
             respectively, of the complex upper hessenberg matrix.
             their lower triangles below the subdiagonal contain further
             information about the transformations which were used in the
             reduction by  corth, if performed.  if the eigenvectors of
             the hessenberg matrix are desired, these elements may be
             arbitrary.
            </param>
             <param name="WR">
             and wi contain the real and imaginary parts,
             respectively, of the eigenvalues.  if an error
             exit is made, the eigenvalues should be correct
             for indices ierr+1,...,n.
            </param>
             <param name="ZR">
             and zi contain the real and imaginary parts,
             respectively, of the eigenvectors.  the eigenvectors
             are unnormalized.  if an error exit is made, none of
             the eigenvectors has been found.
            </param>
             <param name="IERR">
             is set to
             zero       for normal return,
             j          if the limit of 30*n iterations is exhausted
             while the j-th eigenvalue is being sought.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.RADAU5.Run(System.Int32,DotNumerics.ODE.Radau5.IFVPOL,System.Double@,System.Double[]@,System.Int32,System.Double,System.Double@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,DotNumerics.ODE.Radau5.IJVPOL,System.Int32,System.Int32@,System.Int32@,DotNumerics.ODE.Radau5.IBBAMPL,System.Int32,System.Int32,System.Int32@,DotNumerics.ODE.Radau5.ISOLOUTR,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Int32@)">
             <param name="N">
             DIMENSION OF THE SYSTEM 
            </param>
             <param name="FCN">
             NAME (EXTERNAL) OF SUBROUTINE COMPUTING THE
             VALUE OF F(X,Y):
             SUBROUTINE FCN(N,X,Y,F,RPAR,IPAR)
             DOUBLE PRECISION X,Y(N),F(N)
             F(1)=...   ETC.
             RPAR, IPAR (SEE BELOW)
            </param>
             <param name="X">
             INITIAL X-VALUE
            </param>
             <param name="XEND">
             FINAL X-VALUE (XEND-X MAY BE POSITIVE OR NEGATIVE)
            </param>
             <param name="H">
             INITIAL STEP SIZE GUESS;
             FOR STIFF EQUATIONS WITH INITIAL TRANSIENT, 
             H=1.D0/(NORM OF F'), USUALLY 1.D-3 OR 1.D-5, IS GOOD.
             THIS CHOICE IS NOT VERY IMPORTANT, THE STEP SIZE IS
             QUICKLY ADAPTED. (IF H=0.D0, THE CODE PUTS H=1.D-6).
            </param>
             <param name="ITOL">
             SWITCH FOR RTOL AND ATOL:
             ITOL=0: BOTH RTOL AND ATOL ARE SCALARS.
             THE CODE KEEPS, ROUGHLY, THE LOCAL ERROR OF
             Y(I) BELOW RTOL*ABS(Y(I))+ATOL
             ITOL=1: BOTH RTOL AND ATOL ARE VECTORS.
             THE CODE KEEPS THE LOCAL ERROR OF Y(I) BELOW
             RTOL(I)*ABS(Y(I))+ATOL(I).
            </param>
             <param name="JAC">
             NAME (EXTERNAL) OF THE SUBROUTINE WHICH COMPUTES
             THE PARTIAL DERIVATIVES OF F(X,Y) WITH RESPECT TO Y
             (THIS ROUTINE IS ONLY CALLED IF IJAC=1; SUPPLY
             A DUMMY SUBROUTINE IN THE CASE IJAC=0).
             FOR IJAC=1, THIS SUBROUTINE MUST HAVE THE FORM
             SUBROUTINE JAC(N,X,Y,DFY,LDFY,RPAR,IPAR)
             DOUBLE PRECISION X,Y(N),DFY(LDFY,N)
             DFY(1,1)= ...
             LDFY, THE COLUMN-LENGTH OF THE ARRAY, IS
             FURNISHED BY THE CALLING PROGRAM.
             IF (MLJAC.EQ.N) THE JACOBIAN IS SUPPOSED TO
             BE FULL AND THE PARTIAL DERIVATIVES ARE
             STORED IN DFY AS
             DFY(I,J) = PARTIAL F(I) / PARTIAL Y(J)
             ELSE, THE JACOBIAN IS TAKEN AS BANDED AND
             THE PARTIAL DERIVATIVES ARE STORED
             DIAGONAL-WISE AS
             DFY(I-J+MUJAC+1,J) = PARTIAL F(I) / PARTIAL Y(J).
            </param>
             <param name="IJAC">
             SWITCH FOR THE COMPUTATION OF THE JACOBIAN:
             IJAC=0: JACOBIAN IS COMPUTED INTERNALLY BY FINITE
             DIFFERENCES, SUBROUTINE "JAC" IS NEVER CALLED.
             IJAC=1: JACOBIAN IS SUPPLIED BY SUBROUTINE JAC.
            </param>
             <param name="MLJAC">
             SWITCH FOR THE BANDED STRUCTURE OF THE JACOBIAN:
             MLJAC=N: JACOBIAN IS A FULL MATRIX. THE LINEAR
             ALGEBRA IS DONE BY FULL-MATRIX GAUSS-ELIMINATION.
             0.LE.MLJAC.LT.N: MLJAC IS THE LOWER BANDWITH OF JACOBIAN 
             MATRIX (.GE. NUMBER OF NON-ZERO DIAGONALS BELOW
             THE MAIN DIAGONAL).
            </param>
             <param name="MUJAC">
             UPPER BANDWITH OF JACOBIAN  MATRIX (.GE. NUMBER OF NON-
             ZERO DIAGONALS ABOVE THE MAIN DIAGONAL).
             NEED NOT BE DEFINED IF MLJAC=N.
            </param>
             <param name="MAS">
             NAME (EXTERNAL) OF SUBROUTINE COMPUTING THE MASS-
             MATRIX M.
             IF IMAS=0, THIS MATRIX IS ASSUMED TO BE THE IDENTITY
             MATRIX AND NEEDS NOT TO BE DEFINED;
             SUPPLY A DUMMY SUBROUTINE IN THIS CASE.
             IF IMAS=1, THE SUBROUTINE MAS IS OF THE FORM
             SUBROUTINE MAS(N,AM,LMAS,RPAR,IPAR)
             DOUBLE PRECISION AM(LMAS,N)
             AM(1,1)= ....
             IF (MLMAS.EQ.N) THE MASS-MATRIX IS STORED
             AS FULL MATRIX LIKE
             AM(I,J) = M(I,J)
             ELSE, THE MATRIX IS TAKEN AS BANDED AND STORED
             DIAGONAL-WISE AS
             AM(I-J+MUMAS+1,J) = M(I,J).
            </param>
             <param name="IMAS">
             GIVES INFORMATION ON THE MASS-MATRIX:
             IMAS=0: M IS SUPPOSED TO BE THE IDENTITY
             MATRIX, MAS IS NEVER CALLED.
             IMAS=1: MASS-MATRIX  IS SUPPLIED.
            </param>
             <param name="MLMAS">
             SWITCH FOR THE BANDED STRUCTURE OF THE MASS-MATRIX:
             MLMAS=N: THE FULL MATRIX CASE. THE LINEAR
             ALGEBRA IS DONE BY FULL-MATRIX GAUSS-ELIMINATION.
             0.LE.MLMAS.LT.N: MLMAS IS THE LOWER BANDWITH OF THE
             MATRIX (.GE. NUMBER OF NON-ZERO DIAGONALS BELOW
             THE MAIN DIAGONAL).
             MLMAS IS SUPPOSED TO BE .LE. MLJAC.
            </param>
             <param name="MUMAS">
             UPPER BANDWITH OF MASS-MATRIX (.GE. NUMBER OF NON-
             ZERO DIAGONALS ABOVE THE MAIN DIAGONAL).
             NEED NOT BE DEFINED IF MLMAS=N.
             MUMAS IS SUPPOSED TO BE .LE. MUJAC.
            </param>
             <param name="SOLOUT">
             NAME (EXTERNAL) OF SUBROUTINE PROVIDING THE
             NUMERICAL SOLUTION DURING INTEGRATION. 
             IF IOUT=1, IT IS CALLED AFTER EVERY SUCCESSFUL STEP.
             SUPPLY A DUMMY SUBROUTINE IF IOUT=0. 
             IT MUST HAVE THE FORM
             SUBROUTINE SOLOUT (NR,XOLD,X,Y,CONT,LRC,N,
             RPAR,IPAR,IRTRN)
             DOUBLE PRECISION X,Y(N),CONT(LRC)
             ....  
             SOLOUT FURNISHES THE SOLUTION "Y" AT THE NR-TH
             GRID-POINT "X" (THEREBY THE INITIAL VALUE IS
             THE FIRST GRID-POINT).
             "XOLD" IS THE PRECEEDING GRID-POINT.
             "IRTRN" SERVES TO INTERRUPT THE INTEGRATION. IF IRTRN
             IS SET .LT.0, RADAU5 RETURNS TO THE CALLING PROGRAM.
             
             -----  CONTINUOUS OUTPUT: -----
             DURING CALLS TO "SOLOUT", A CONTINUOUS SOLUTION
             FOR THE INTERVAL [XOLD,X] IS AVAILABLE THROUGH
             THE FUNCTION
             .GT..GT..GT.   CONTR5(I,S,CONT,LRC)   .LT..LT..LT.
             WHICH PROVIDES AN APPROXIMATION TO THE I-TH
             COMPONENT OF THE SOLUTION AT THE POINT S. THE VALUE
             S SHOULD LIE IN THE INTERVAL [XOLD,X].
             DO NOT CHANGE THE ENTRIES OF CONT(LRC), IF THE
             DENSE OUTPUT FUNCTION IS USED.
            </param>
             <param name="IOUT">
             SWITCH FOR CALLING THE SUBROUTINE SOLOUT:
             IOUT=0: SUBROUTINE IS NEVER CALLED
             IOUT=1: SUBROUTINE IS AVAILABLE FOR OUTPUT.
            </param>
             <param name="WORK">
             ARRAY OF WORKING SPACE OF LENGTH "LWORK".
             WORK(1), WORK(2),.., WORK(20) SERVE AS PARAMETERS
             FOR THE CODE. FOR STANDARD USE OF THE CODE
             WORK(1),..,WORK(20) MUST BE SET TO ZERO BEFORE
             CALLING. SEE BELOW FOR A MORE SOPHISTICATED USE.
             WORK(21),..,WORK(LWORK) SERVE AS WORKING SPACE
             FOR ALL VECTORS AND MATRICES.
             "LWORK" MUST BE AT LEAST
             N*(LJAC+LMAS+3*LE+12)+20
             WHERE
             LJAC=N              IF MLJAC=N (FULL JACOBIAN)
             LJAC=MLJAC+MUJAC+1  IF MLJAC.LT.N (BANDED JAC.)
             AND                  
             LMAS=0              IF IMAS=0
             LMAS=N              IF IMAS=1 AND MLMAS=N (FULL)
             LMAS=MLMAS+MUMAS+1  IF MLMAS.LT.N (BANDED MASS-M.)
             AND
             LE=N               IF MLJAC=N (FULL JACOBIAN)
             LE=2*MLJAC+MUJAC+1 IF MLJAC.LT.N (BANDED JAC.)
             
             IN THE USUAL CASE WHERE THE JACOBIAN IS FULL AND THE
             MASS-MATRIX IS THE INDENTITY (IMAS=0), THE MINIMUM
             STORAGE REQUIREMENT IS 
             LWORK = 4*N*N+12*N+20.
             IF IWORK(9)=M1.GT.0 THEN "LWORK" MUST BE AT LEAST
             N*(LJAC+12)+(N-M1)*(LMAS+3*LE)+20
             WHERE IN THE DEFINITIONS OF LJAC, LMAS AND LE THE
             NUMBER N CAN BE REPLACED BY N-M1.
            </param>
             <param name="LWORK">
             DECLARED LENGTH OF ARRAY "WORK".
            </param>
             <param name="IWORK">
             INTEGER WORKING SPACE OF LENGTH "LIWORK".
             IWORK(1),IWORK(2),...,IWORK(20) SERVE AS PARAMETERS
             FOR THE CODE. FOR STANDARD USE, SET IWORK(1),..,
             IWORK(20) TO ZERO BEFORE CALLING.
             IWORK(21),...,IWORK(LIWORK) SERVE AS WORKING AREA.
             "LIWORK" MUST BE AT LEAST 3*N+20.
            </param>
             <param name="LIWORK">
             DECLARED LENGTH OF ARRAY "IWORK".
            </param>
             <param name="IDID">
             REPORTS ON SUCCESSFULNESS UPON RETURN:
             IDID= 1  COMPUTATION SUCCESSFUL,
             IDID= 2  COMPUT. SUCCESSFUL (INTERRUPTED BY SOLOUT)
             IDID=-1  INPUT IS NOT CONSISTENT,
             IDID=-2  LARGER NMAX IS NEEDED,
             IDID=-3  STEP SIZE BECOMES TOO SMALL,
             IDID=-4  MATRIX IS REPEATEDLY SINGULAR.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.HPSOLB.Run(System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
             <param name="N">
             is an integer variable.
             On entry n is the dimension of the arrays t and iorder.
             On exit n is unchanged.
            </param>
             <param name="T">
             is a double precision array of dimension n.
             On entry t stores the elements to be sorted,
             On exit t(n) stores the least elements of t, and t(1) to t(n-1)
             stores the remaining elements in the form of a heap.
            </param>
             <param name="IORDER">
             is an integer array of dimension n.
             On entry iorder(i) is the index of t(i).
             On exit iorder(i) is still the index of t(i), but iorder may be
             permuted in accordance with t.
            </param>
             <param name="IHEAP">
             is an integer variable specifying the task.
             On entry iheap should be set as follows:
             iheap .eq. 0 if t(1) to t(n) is not in the form of a heap,
             iheap .ne. 0 if otherwise.
             On exit iheap is unchanged.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.SymmetricMatrix">
            <summary>
            Represents a  symmetric matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the SymmetricMatrix class of the given size.
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.#ctor(System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the SymmetricMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="Data">The data</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.Random(System.Int32)">
            <summary>
            Generate a matrix with random elements
            </summary>
            <param name="size">Size</param>
            <returns>An m-by-n matrix with uniformly distributed
            random elements in <c>[0, 1)</c> interval.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.Random(System.Int32,System.Int32)">
            <summary>
            Generate a matrix with random elements
            </summary>
            <param name="size">Size</param>
            <param name="Seed">
            A number used to calculate a starting value for the pseudo-random number
            sequence. If a negative number is specified, the absolute value of the number
            is used.
            </param>
            <returns>An m-by-n matrix with uniformly distributed
            random elements in <c>[0, 1)</c> interval.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.op_Addition(DotNumerics.LinearAlgebra.SymmetricMatrix,DotNumerics.LinearAlgebra.SymmetricMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.op_Subtraction(DotNumerics.LinearAlgebra.SymmetricMatrix,DotNumerics.LinearAlgebra.SymmetricMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.op_Multiply(System.Double,DotNumerics.LinearAlgebra.SymmetricMatrix)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricMatrix.op_Implicit(DotNumerics.LinearAlgebra.SymmetricMatrix)~DotNumerics.LinearAlgebra.Matrix">
            <summary>
            Implicit SymmetricMatrix to Matrix conversion.
            </summary>
            <param name="symmetricMatrix">The SymmetricMatrix.</param>
            <returns>The matrix.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.SymmetricMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of a element of the matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The matrix value at (row, column).</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRTRI">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTRTRI computes the inverse of a real upper or lower triangular
             matrix A.
             
             This is the Level 3 BLAS version of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRTRI.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTRTRI computes the inverse of a real upper or lower triangular
             matrix A.
             
             This is the Level 3 BLAS version of the algorithm.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  A is upper triangular;
             = 'L':  A is lower triangular.
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             = 'N':  A is non-unit triangular;
             = 'U':  A is unit triangular.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the triangular matrix A.  If UPLO = 'U', the
             leading N-by-N upper triangular part of the array A contains
             the upper triangular matrix, and the strictly lower
             triangular part of A is not referenced.  If UPLO = 'L', the
             leading N-by-N lower triangular part of the array A contains
             the lower triangular matrix, and the strictly upper
             triangular part of A is not referenced.  If DIAG = 'U', the
             diagonal elements of A are also not referenced and are
             assumed to be 1.
             On exit, the (triangular) inverse of the original matrix, in
             the same storage format.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: if INFO = i, A(i,i) is exactly zero.  The triangular
             matrix is singular and its inverse can not be computed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSTEQR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
             symmetric tridiagonal matrix using the implicit QL or QR method.
             The eigenvectors of a full or band symmetric matrix can also be found
             if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
             tridiagonal form.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSTEQR.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
             symmetric tridiagonal matrix using the implicit QL or QR method.
             The eigenvectors of a full or band symmetric matrix can also be found
             if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
             tridiagonal form.
             
            </summary>
             <param name="COMPZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only.
             = 'V':  Compute eigenvalues and eigenvectors of the original
             symmetric matrix.  On entry, Z must contain the
             orthogonal matrix used to reduce the original matrix
             to tridiagonal form.
             = 'I':  Compute eigenvalues and eigenvectors of the
             tridiagonal matrix.  Z is initialized to the identity
             matrix.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the diagonal elements of the tridiagonal matrix.
             On exit, if INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, the (n-1) subdiagonal elements of the tridiagonal
             matrix.
             On exit, E has been destroyed.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
             On entry, if  COMPZ = 'V', then Z contains the orthogonal
             matrix used in the reduction to tridiagonal form.
             On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
             orthonormal eigenvectors of the original symmetric matrix,
             and if COMPZ = 'I', Z contains the orthonormal eigenvectors
             of the symmetric tridiagonal matrix.
             If COMPZ = 'N', then Z is not referenced.
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  LDZ .GE. 1, and if
             eigenvectors are desired, then  LDZ .GE. max(1,N).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
             If COMPZ = 'N', then WORK is not referenced.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  the algorithm has failed to find all the eigenvalues in
             a total of 30*N iterations; if INFO = i, then i
             elements of E have not converged to zero; on exit, D
             and E contain the elements of a symmetric tridiagonal
             matrix which is orthogonally similar to the original
             matrix.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMQR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMQR overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMQR.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMQR overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,K)
             The i-th column must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGEQRF in the first k columns of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             If SIDE = 'L', LDA .GE. max(1,M);
             if SIDE = 'R', LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQRF.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORG2L">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORG2L generates an m by n real matrix Q with orthonormal columns,
             which is defined as the last n columns of a product of k elementary
             reflectors of order m
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGEQLF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORG2L.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORG2L generates an m by n real matrix Q with orthonormal columns,
             which is defined as the last n columns of a product of k elementary
             reflectors of order m
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGEQLF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. M .GE. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the (n-k+i)-th column must contain the vector which
             defines the elementary reflector H(i), for i = 1,2,...,k, as
             returned by DGEQLF in the last k columns of its array
             argument A.
             On exit, the m by n matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQLF.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASDT">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASDT creates a tree of subproblems for bidiagonal divide and
             conquer.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASDT.Run(System.Int32,System.Int32@,System.Int32@,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLASDT creates a tree of subproblems for bidiagonal divide and
             conquer.
             
            </summary>
             <param name="N">
             (input) INTEGER
             On entry, the number of diagonal elements of the
             bidiagonal matrix.
            </param>
             <param name="LVL">
             (output) INTEGER
             On exit, the number of levels on the computation tree.
            </param>
             <param name="ND">
             (output) INTEGER
             On exit, the number of nodes on the tree.
            </param>
             <param name="INODE">
             (output) INTEGER array, dimension ( N )
             On exit, centers of subproblems.
            </param>
             <param name="NDIML">
             (output) INTEGER array, dimension ( N )
             On exit, row dimensions of left children.
            </param>
             <param name="NDIMR">
             (output) INTEGER array, dimension ( N )
             On exit, row dimensions of right children.
            </param>
             <param name="MSUB">
             (input) INTEGER.
             On entry, the maximum row dimension each subproblem at the
             bottom of the tree can be of.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD0">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             Using a divide and conquer approach, DLASD0 computes the singular
             value decomposition (SVD) of a real upper bidiagonal N-by-M
             matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
             The algorithm computes orthogonal matrices U and VT such that
             B = U * S * VT. The singular values S are overwritten on D.
             
             A related subroutine, DLASDA, computes only the singular values,
             and optionally, the singular vectors in compact form.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD0.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             Using a divide and conquer approach, DLASD0 computes the singular
             value decomposition (SVD) of a real upper bidiagonal N-by-M
             matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
             The algorithm computes orthogonal matrices U and VT such that
             B = U * S * VT. The singular values S are overwritten on D.
             
             A related subroutine, DLASDA, computes only the singular values,
             and optionally, the singular vectors in compact form.
             
            </summary>
             <param name="N">
             (input) INTEGER
             On entry, the row dimension of the upper bidiagonal matrix.
             This is also the dimension of the main diagonal array D.
            </param>
             <param name="SQRE">
             (input) INTEGER
             Specifies the column dimension of the bidiagonal matrix.
             = 0: The bidiagonal matrix has column dimension M = N;
             = 1: The bidiagonal matrix has column dimension M = N+1;
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry D contains the main diagonal of the bidiagonal
             matrix.
             On exit D, if INFO = 0, contains its singular values.
            </param>
             <param name="E">
             (input) DOUBLE PRECISION array, dimension (M-1)
             Contains the subdiagonal entries of the bidiagonal matrix.
             On exit, E has been destroyed.
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension at least (LDQ, N)
             On exit, U contains the left singular vectors.
            </param>
             <param name="LDU">
             (input) INTEGER
             On entry, leading dimension of U.
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array, dimension at least (LDVT, M)
             On exit, VT' contains the right singular vectors.
            </param>
             <param name="LDVT">
             (input) INTEGER
             On entry, leading dimension of VT.
            </param>
             <param name="SMLSIZ">
             (input) INTEGER
             On entry, maximum size of the subproblems at the
             bottom of the computation tree.
            </param>
             <param name="IWORK">
             (workspace) INTEGER work array.
             Dimension must be at least (8 * N)
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION work array.
             Dimension must be at least (3 * M**2 + 2 * M)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAR2V">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAR2V applies a vector of real plane rotations from both sides to
             a sequence of 2-by-2 real symmetric matrices, defined by the elements
             of the vectors x, y and z. For i = 1,2,...,n
             
             ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
             ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAR2V.Run(System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAR2V applies a vector of real plane rotations from both sides to
             a sequence of 2-by-2 real symmetric matrices, defined by the elements
             of the vectors x, y and z. For i = 1,2,...,n
             
             ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
             ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of plane rotations to be applied.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             The vector x.
            </param>
             <param name="Y">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             The vector y.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             The vector z.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between elements of X, Y and Z. INCX .GT. 0.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
             The cosines of the plane rotations.
            </param>
             <param name="S">
             (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
             The sines of the plane rotations.
            </param>
             <param name="INCC">
             (input) INTEGER
             The increment between elements of C and S. INCC .GT. 0.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMCH">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMCH determines double precision machine parameters.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMCH.Run(System.String)">
             <summary>
             Purpose
             =======
             
             DLAMCH determines double precision machine parameters.
             
            </summary>
             <param name="CMACH">
             (input) CHARACTER*1
             Specifies the value to be returned by DLAMCH:
             = 'E' or 'e',   DLAMCH := eps
             = 'S' or 's ,   DLAMCH := sfmin
             = 'B' or 'b',   DLAMCH := base
             = 'P' or 'p',   DLAMCH := eps*base
             = 'N' or 'n',   DLAMCH := t
             = 'R' or 'r',   DLAMCH := rnd
             = 'M' or 'm',   DLAMCH := emin
             = 'U' or 'u',   DLAMCH := rmin
             = 'L' or 'l',   DLAMCH := emax
             = 'O' or 'o',   DLAMCH := rmax
             
             where
             
             eps   = relative machine precision
             sfmin = safe minimum, such that 1/sfmin does not overflow
             base  = base of the machine
             prec  = eps*base
             t     = number of (base) digits in the mantissa
             rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
             emin  = minimum exponent before (gradual) underflow
             rmin  = underflow threshold - base**(emin-1)
             emax  = largest exponent before overflow
             rmax  = overflow threshold  - (base**emax)*(1-eps)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMC1">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMC1 determines the machine parameters given by BETA, T, RND, and
             IEEE1.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMC1.Run(System.Int32@,System.Int32@,System.Boolean@,System.Boolean@)">
             <summary>
             Purpose
             =======
             
             DLAMC1 determines the machine parameters given by BETA, T, RND, and
             IEEE1.
             
            </summary>
             <param name="BETA">
             (output) INTEGER
             The base of the machine.
            </param>
             <param name="T">
             (output) INTEGER
             The number of ( BETA ) digits in the mantissa.
            </param>
             <param name="RND">
             (output) LOGICAL
             Specifies whether proper rounding  ( RND = .TRUE. )  or
             chopping  ( RND = .FALSE. )  occurs in addition. This may not
             be a reliable guide to the way in which the machine performs
             its arithmetic.
            </param>
             <param name="IEEE1">
             (output) LOGICAL
             Specifies whether rounding appears to be done in the IEEE
             'round to nearest' style.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMC2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMC2 determines the machine parameters specified in its argument
             list.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMC2.Run(System.Int32@,System.Int32@,System.Boolean@,System.Double@,System.Int32@,System.Double@,System.Int32@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAMC2 determines the machine parameters specified in its argument
             list.
             
            </summary>
             <param name="BETA">
             (output) INTEGER
             The base of the machine.
            </param>
             <param name="T">
             (output) INTEGER
             The number of ( BETA ) digits in the mantissa.
            </param>
             <param name="RND">
             (output) LOGICAL
             Specifies whether proper rounding  ( RND = .TRUE. )  or
             chopping  ( RND = .FALSE. )  occurs in addition. This may not
             be a reliable guide to the way in which the machine performs
             its arithmetic.
            </param>
             <param name="EPS">
             (output) DOUBLE PRECISION
             The smallest positive number such that
             
             fl( 1.0 - EPS ) .LT. 1.0,
             
             where fl denotes the computed value.
            </param>
             <param name="EMIN">
             (output) INTEGER
             The minimum exponent before (gradual) underflow occurs.
            </param>
             <param name="RMIN">
             (output) DOUBLE PRECISION
             The smallest normalized number for the machine, given by
             BASE**( EMIN - 1 ), where  BASE  is the floating point value
             of BETA.
            </param>
             <param name="EMAX">
             (output) INTEGER
             The maximum exponent before overflow occurs.
            </param>
             <param name="RMAX">
             (output) DOUBLE PRECISION
             The largest positive number for the machine, given by
             BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point
             value of BETA.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMC3">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMC3  is intended to force  A  and  B  to be stored prior to doing
             the addition of  A  and  B ,  for use in situations where optimizers
             might hold one of these in a register.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMC3.Run(System.Double,System.Double)">
             <summary>
             Purpose
             =======
             
             DLAMC3  is intended to force  A  and  B  to be stored prior to doing
             the addition of  A  and  B ,  for use in situations where optimizers
             might hold one of these in a register.
             
            </summary>
             <param name="A">
             (input) DOUBLE PRECISION
            </param>
             <param name="B">
             (input) DOUBLE PRECISION
             The values A and B.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMC4">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMC4 is a service routine for DLAMC2.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMC4.Run(System.Int32@,System.Double,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAMC4 is a service routine for DLAMC2.
             
            </summary>
             <param name="EMIN">
             (output) INTEGER 
             The minimum exponent before (gradual) underflow, computed by
             setting A = START and dividing by BASE until the previous A
             can not be recovered.
            </param>
             <param name="START">
             (input) DOUBLE PRECISION
             The starting point for determining EMIN.
            </param>
             <param name="BASE">
             (input) INTEGER
             The base of the machine.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAMC5">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAMC5 attempts to compute RMAX, the largest machine floating-point
             number, without overflow.  It assumes that EMAX + abs(EMIN) sum
             approximately to a power of 2.  It will fail on machines where this
             assumption does not hold, for example, the Cyber 205 (EMIN = -28625,
             EMAX = 28718).  It will also fail if the value supplied for EMIN is
             too large (i.e. too close to zero), probably with overflow.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAMC5.Run(System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAMC5 attempts to compute RMAX, the largest machine floating-point
             number, without overflow.  It assumes that EMAX + abs(EMIN) sum
             approximately to a power of 2.  It will fail on machines where this
             assumption does not hold, for example, the Cyber 205 (EMIN = -28625,
             EMAX = 28718).  It will also fail if the value supplied for EMIN is
             too large (i.e. too close to zero), probably with overflow.
             
            </summary>
             <param name="BETA">
             (input) INTEGER
             The base of floating-point arithmetic.
            </param>
             <param name="P">
             (input) INTEGER
             The number of base BETA digits in the mantissa of a
             floating-point value.
            </param>
             <param name="EMIN">
             (input) INTEGER
             The minimum exponent before (gradual) underflow.
            </param>
             <param name="IEEE">
             (input) LOGICAL
             A logical flag specifying whether or not the arithmetic
             system is thought to comply with the IEEE standard.
            </param>
             <param name="EMAX">
             (output) INTEGER
             The largest exponent before overflow
            </param>
             <param name="RMAX">
             (output) DOUBLE PRECISION
             The largest machine floating-point number.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAEXC">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
             an upper quasi-triangular matrix T by an orthogonal similarity
             transformation.
             
             T must be in Schur canonical form, that is, block upper triangular
             with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
             has its diagonal elemnts equal and its off-diagonal elements of
             opposite sign.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAEXC.Run(System.Boolean,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
             an upper quasi-triangular matrix T by an orthogonal similarity
             transformation.
             
             T must be in Schur canonical form, that is, block upper triangular
             with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
             has its diagonal elemnts equal and its off-diagonal elements of
             opposite sign.
             
            </summary>
             <param name="WANTQ">
             (input) LOGICAL
             = .TRUE. : accumulate the transformation in the matrix Q;
             = .FALSE.: do not accumulate the transformation.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix T. N .GE. 0.
            </param>
             <param name="T">
             must be in Schur canonical form, that is, block upper triangular
            </param>
             <param name="LDT">
             (input)  INTEGER
             The leading dimension of the array T. LDT .GE. max(1,N).
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
             On exit, if WANTQ is .TRUE., the updated matrix Q.
             If WANTQ is .FALSE., Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.
             LDQ .GE. 1; and if WANTQ is .TRUE., LDQ .GE. N.
            </param>
             <param name="J1">
             (input) INTEGER
             The index of the first row of the first block T11.
            </param>
             <param name="N1">
             (input) INTEGER
             The order of the first block T11. N1 = 0, 1 or 2.
            </param>
             <param name="N2">
             (input) INTEGER
             The order of the second block T22. N2 = 0, 1 or 2.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             = 1: the transformed matrix T would be too far from Schur
             form; the blocks are not swapped and T and Q are
             unchanged.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DHSEQR">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DHSEQR computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DHSEQR.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DHSEQR computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
             <param name="JOB">
             (input) CHARACTER*1
             = 'E':  compute eigenvalues only;
             = 'S':  compute eigenvalues and the Schur form T.
            </param>
             <param name="COMPZ">
             (input) CHARACTER*1
             = 'N':  no Schur vectors are computed;
             = 'I':  Z is initialized to the unit matrix and the matrix Z
             of Schur vectors of H is returned;
             = 'V':  Z must contain an orthogonal matrix Q on entry, and
             the product Q*Z is returned.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to DGEBAL, and then passed to DGEHRD
             when the matrix output by DGEBAL is reduced to Hessenberg
             form. Otherwise ILO and IHI should be set to 1 and N
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and JOB = 'S', then H contains the
             upper quasi-triangular matrix T from the Schur decomposition
             (the Schur form); 2-by-2 diagonal blocks (corresponding to
             complex conjugate pairs of eigenvalues) are returned in
             standard form, with H(i,i) = H(i+1,i+1) and
             H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
             contents of H are unspecified on exit.  (The output value of
             H when INFO.GT.0 is given under the description of INFO
             below.)
             
             Unlike earlier versions of DHSEQR, this subroutine may
             explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
             or j = IHI+1, IHI+2, ... N.
            </param>
             <param name="LDH">
             (input) INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </param>
             <param name="WR">
             (output) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="WI">
             (output) DOUBLE PRECISION array, dimension (N)
             The real and imaginary parts, respectively, of the computed
             eigenvalues. If two eigenvalues are computed as a complex
             conjugate pair, they are stored in consecutive elements of
             WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
             WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
             the same order as on the diagonal of the Schur form returned
             in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
             diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
             If COMPZ = 'N', Z is not referenced.
             If COMPZ = 'I', on entry Z need not be set and on exit,
             if INFO = 0, Z contains the orthogonal matrix Z of the Schur
             vectors of H.  If COMPZ = 'V', on entry Z must contain an
             N-by-N matrix Q, which is assumed to be equal to the unit
             matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
             if INFO = 0, Z contains Q*Z.
             Normally Q is the orthogonal matrix generated by DORGHR
             after the call to DGEHRD which formed the Hessenberg matrix
             H. (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  if COMPZ = 'I' or
             COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             
             If LWORK = -1, then DHSEQR does a workspace query.
             In this case, DHSEQR checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
             
            </param>
             <param name="INFO">
             (output) INTEGER
             =  0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal
             value
             .GT. 0:  if INFO = i, DHSEQR failed to compute all of
             the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
             and WI contain those eigenvalues which have been
             successfully computed.  (Failures are rare.)
             
             If INFO .GT. 0 and JOB = 'E', then on exit, the
             remaining unconverged eigenvalues are the eigen-
             values of the upper Hessenberg matrix rows and
             columns ILO through INFO of the final, output
             value of H.
             
             If INFO .GT. 0 and JOB   = 'S', then on exit
             
             (*)  (initial value of H)*U  = U*(final value of H)
             
             where U is an orthogonal matrix.  The final
             value of H is upper Hessenberg and quasi-triangular
             in rows and columns INFO+1 through IHI.
             
             If INFO .GT. 0 and COMPZ = 'V', then on exit
             
             (final value of Z)  =  (initial value of Z)*U
             
             where U is the orthogonal matrix in (*) (regard-
             less of the value of JOB.)
             
             If INFO .GT. 0 and COMPZ = 'I', then on exit
             (final value of Z)  = U
             where U is the orthogonal matrix in (*) (regard-
             less of the value of JOB.)
             
             If INFO .GT. 0 and COMPZ = 'N', then Z is not
             accessed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGERQF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGERQF computes an RQ factorization of a real M-by-N matrix A:
             A = R * Q.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGERQF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGERQF computes an RQ factorization of a real M-by-N matrix A:
             A = R * Q.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit,
             if m .LE. n, the upper triangle of the subarray
             A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
             if m .GE. n, the elements on and above the (m-n)-th subdiagonal
             contain the M-by-N upper trapezoidal matrix R;
             the remaining elements, with the array TAU, represent the
             orthogonal matrix Q as a product of min(m,n) elementary
             reflectors (see Further Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. M*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEQPF">
             <summary>
             -- LAPACK deprecated driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This routine is deprecated and has been replaced by routine DGEQP3.
             
             DGEQPF computes a QR factorization with column pivoting of a
             real M-by-N matrix A: A*P = Q*R.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEQPF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             This routine is deprecated and has been replaced by routine DGEQP3.
             
             DGEQPF computes a QR factorization with column pivoting of a
             real M-by-N matrix A: A*P = Q*R.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A. N .GE. 0
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the upper triangle of the array contains the
             min(M,N)-by-N upper triangular matrix R; the elements
             below the diagonal, together with the array TAU,
             represent the orthogonal matrix Q as a product of
             min(m,n) elementary reflectors.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="JPVT">
             (input/output) INTEGER array, dimension (N)
             On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
             to the front of A*P (a leading column); if JPVT(i) = 0,
             the i-th column of A is a free column.
             On exit, if JPVT(i) = k, then the i-th column of A*P
             was the k-th column of A.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (3*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEQP3">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEQP3 computes a QR factorization with column pivoting of a
             matrix A:  A*P = Q*R  using Level 3 BLAS.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEQP3.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEQP3 computes a QR factorization with column pivoting of a
             matrix A:  A*P = Q*R  using Level 3 BLAS.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the upper triangle of the array contains the
             min(M,N)-by-N upper trapezoidal matrix R; the elements below
             the diagonal, together with the array TAU, represent the
             orthogonal matrix Q as a product of min(M,N) elementary
             reflectors.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="JPVT">
             (input/output) INTEGER array, dimension (N)
             On entry, if JPVT(J).ne.0, the J-th column of A is permuted
             to the front of A*P (a leading column); if JPVT(J)=0,
             the J-th column of A is a free column.
             On exit, if JPVT(J)=K, then the J-th column of A*P was the
             the K-th column of A.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO=0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. 3*N+1.
             For optimal performance LWORK .GE. 2*N+( N+1 )*NB, where NB
             is the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit.
             .LT. 0: if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.OdeGearsBDF">
            <summary>
            Solves an initial-value problem for stiff ordinary differential equations using 
            the Gears BDF method.
            dy(i)/dt = f(i,t,y(1),y(2),...,y(N)).
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.#ctor">
            <summary>
            Initializes a new instance of the OdeGearsBDF class.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.#ctor(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Initializes a new instance of the OdeGearsBDF class.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.#ctor(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32)">
            <summary>
            Initializes a new instance of the OdeGearsBDF class. 
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.InitializeODEs(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeGearsBDF.InitializeODEs(DotNumerics.ODE.OdeFunction,DotNumerics.ODE.OdeJacobian,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="jacobian">A function that evaluates the jacobian matrix.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.Dopri5.DOPRI5.Run(System.Int32,DotNumerics.ODE.Dopri5.IFAREN,System.Double@,System.Double[]@,System.Int32,System.Double,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,DotNumerics.ODE.Dopri5.ISOLOUT,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Int32@)">
             <param name="N">
             DIMENSION OF THE SYSTEM 
            </param>
             <param name="FCN">
             NAME (EXTERNAL) OF SUBROUTINE COMPUTING THE
             VALUE OF F(X,Y):
             SUBROUTINE FCN(N,X,Y,F,RPAR,IPAR)
             DOUBLE PRECISION X,Y(N),F(N)
             F(1)=...   ETC.
            </param>
             <param name="X">
             INITIAL X-VALUE
            </param>
             <param name="XEND">
             FINAL X-VALUE (XEND-X MAY BE POSITIVE OR NEGATIVE)
            </param>
             <param name="ITOL">
             SWITCH FOR RTOL AND ATOL:
             ITOL=0: BOTH RTOL AND ATOL ARE SCALARS.
             THE CODE KEEPS, ROUGHLY, THE LOCAL ERROR OF
             Y(I) BELOW RTOL*ABS(Y(I))+ATOL
             ITOL=1: BOTH RTOL AND ATOL ARE VECTORS.
             THE CODE KEEPS THE LOCAL ERROR OF Y(I) BELOW
             RTOL(I)*ABS(Y(I))+ATOL(I).
            </param>
             <param name="SOLOUT">
             NAME (EXTERNAL) OF SUBROUTINE PROVIDING THE
             NUMERICAL SOLUTION DURING INTEGRATION. 
             IF IOUT.GE.1, IT IS CALLED AFTER EVERY SUCCESSFUL STEP.
             SUPPLY A DUMMY SUBROUTINE IF IOUT=0. 
             IT MUST HAVE THE FORM
             SUBROUTINE SOLOUT (NR,XOLD,X,Y,N,CON,ICOMP,ND,
             RPAR,IPAR,IRTRN)
             DIMENSION Y(N),CON(5*ND),ICOMP(ND)
             ....  
             SOLOUT FURNISHES THE SOLUTION "Y" AT THE NR-TH
             GRID-POINT "X" (THEREBY THE INITIAL VALUE IS
             THE FIRST GRID-POINT).
             "XOLD" IS THE PRECEEDING GRID-POINT.
             "IRTRN" SERVES TO INTERRUPT THE INTEGRATION. IF IRTRN
             IS SET .LT.0, DOPRI5 WILL RETURN TO THE CALLING PROGRAM.
             IF THE NUMERICAL SOLUTION IS ALTERED IN SOLOUT,
             SET  IRTRN = 2
             
             -----  CONTINUOUS OUTPUT: -----
             DURING CALLS TO "SOLOUT", A CONTINUOUS SOLUTION
             FOR THE INTERVAL [XOLD,X] IS AVAILABLE THROUGH
             THE FUNCTION
             .GT..GT..GT.   CONTD5(I,S,CON,ICOMP,ND)   .LT..LT..LT.
             WHICH PROVIDES AN APPROXIMATION TO THE I-TH
             COMPONENT OF THE SOLUTION AT THE POINT S. THE VALUE
             S SHOULD LIE IN THE INTERVAL [XOLD,X].
            </param>
             <param name="IOUT">
             SWITCH FOR CALLING THE SUBROUTINE SOLOUT:
             IOUT=0: SUBROUTINE IS NEVER CALLED
             IOUT=1: SUBROUTINE IS USED FOR OUTPUT.
             IOUT=2: DENSE OUTPUT IS PERFORMED IN SOLOUT
             (IN THIS CASE WORK(5) MUST BE SPECIFIED)
            </param>
             <param name="WORK">
             ARRAY OF WORKING SPACE OF LENGTH "LWORK".
             WORK(1),...,WORK(20) SERVE AS PARAMETERS FOR THE CODE.
             FOR STANDARD USE, SET THEM TO ZERO BEFORE CALLING.
             "LWORK" MUST BE AT LEAST  8*N+5*NRDENS+21
             WHERE  NRDENS = IWORK(5)
            </param>
             <param name="LWORK">
             DECLARED LENGHT OF ARRAY "WORK".
            </param>
             <param name="IWORK">
             INTEGER WORKING SPACE OF LENGHT "LIWORK".
             IWORK(1),...,IWORK(20) SERVE AS PARAMETERS FOR THE CODE.
             FOR STANDARD USE, SET THEM TO ZERO BEFORE CALLING.
             "LIWORK" MUST BE AT LEAST NRDENS+21 .
            </param>
             <param name="LIWORK">
             DECLARED LENGHT OF ARRAY "IWORK".
            </param>
             <param name="IDID">
             REPORTS ON SUCCESSFULNESS UPON RETURN:
             IDID= 1  COMPUTATION SUCCESSFUL,
             IDID= 2  COMPUT. SUCCESSFUL (INTERRUPTED BY SOLOUT)
             IDID=-1  INPUT IS NOT CONSISTENT,
             IDID=-2  LARGER NMAX IS NEEDED,
             IDID=-3  STEP SIZE BECOMES TOO SMALL.
             IDID=-4  PROBLEM IS PROBABLY STIFF (INTERRUPTED).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.IDAMAX">
             <summary>
             Purpose
             =======
             
             finds the index of element having max. absolute value.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.IDAMAX.Run(System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             finds the index of element having max. absolute value.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTZRZF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTZRZF reduces the M-by-N ( M.LE.N ) real upper trapezoidal matrix A
             to upper triangular form by means of orthogonal transformations.
             
             The upper trapezoidal matrix A is factored as
             
             A = ( R  0 ) * Z,
             
             where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
             triangular matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTZRZF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTZRZF reduces the M-by-N ( M.LE.N ) real upper trapezoidal matrix A
             to upper triangular form by means of orthogonal transformations.
             
             The upper trapezoidal matrix A is factored as
             
             A = ( R  0 ) * Z,
             
             where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
             triangular matrix.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. M.
            </param>
             <param name="A">
             = ( R  0 ) * Z,
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (M)
             The scalar factors of the elementary reflectors.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. M*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASSQ">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASSQ  returns the values  scl  and  smsq  such that
             
             ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
             
             where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
             assumed to be non-negative and  scl  returns the value
             
             scl = max( scale, abs( x( i ) ) ).
             
             scale and sumsq must be supplied in SCALE and SUMSQ and
             scl and smsq are overwritten on SCALE and SUMSQ respectively.
             
             The routine makes only one pass through the vector x.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASSQ.Run(System.Int32,System.Double[],System.Int32,System.Int32,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLASSQ  returns the values  scl  and  smsq  such that
             
             ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
             
             where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
             assumed to be non-negative and  scl  returns the value
             
             scl = max( scale, abs( x( i ) ) ).
             
             scale and sumsq must be supplied in SCALE and SUMSQ and
             scl and smsq are overwritten on SCALE and SUMSQ respectively.
             
             The routine makes only one pass through the vector x.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of elements to be used from the vector X.
            </param>
             <param name="X">
             (input) DOUBLE PRECISION array, dimension (N)
             The vector for which a scaled sum of squares is computed.
             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 .LE. i .LE. n.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between successive values of the vector X.
             INCX .GT. 0.
            </param>
             <param name="SCALE">
             and sumsq must be supplied in SCALE and SUMSQ and
            </param>
             <param name="SUMSQ">
             (input/output) DOUBLE PRECISION
             On entry, the value  sumsq  in the equation above.
             On exit, SUMSQ is overwritten with  smsq , the basic sum of
             squares from which  scl  has been factored out.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASET">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASET initializes an m-by-n matrix A to BETA on the diagonal and
             ALPHA on the offdiagonals.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASET.Run(System.String,System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLASET initializes an m-by-n matrix A to BETA on the diagonal and
             ALPHA on the offdiagonals.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies the part of the matrix A to be set.
             = 'U':      Upper triangular part is set; the strictly lower
             triangular part of A is not changed.
             = 'L':      Lower triangular part is set; the strictly upper
             triangular part of A is not changed.
             Otherwise:  All of the matrix A is set.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="ALPHA">
             (input) DOUBLE PRECISION
             The constant to which the offdiagonal elements are to be set.
            </param>
             <param name="BETA">
             (input) DOUBLE PRECISION
             The constant to which the diagonal elements are to be set.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On exit, the leading m-by-n submatrix of A is set as follows:
             
             if UPLO = 'U', A(i,j) = ALPHA, 1.LE.i.LE.j-1, 1.LE.j.LE.n,
             if UPLO = 'L', A(i,j) = ALPHA, j+1.LE.i.LE.m, 1.LE.j.LE.n,
             otherwise,     A(i,j) = ALPHA, 1.LE.i.LE.m, 1.LE.j.LE.n, i.ne.j,
             
             and, for all UPLO, A(i,i) = BETA, 1.LE.i.LE.min(m,n).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAE2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
             [  A   B  ]
             [  B   C  ].
             On return, RT1 is the eigenvalue of larger absolute value, and RT2
             is the eigenvalue of smaller absolute value.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAE2.Run(System.Double,System.Double,System.Double,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
             [  A   B  ]
             [  B   C  ].
             On return, RT1 is the eigenvalue of larger absolute value, and RT2
             is the eigenvalue of smaller absolute value.
             
            </summary>
             <param name="A">
             (input) DOUBLE PRECISION
             The (1,1) element of the 2-by-2 matrix.
            </param>
             <param name="B">
             (input) DOUBLE PRECISION
             The (1,2) and (2,1) elements of the 2-by-2 matrix.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION
             The (2,2) element of the 2-by-2 matrix.
            </param>
             <param name="RT1">
             (output) DOUBLE PRECISION
             The eigenvalue of larger absolute value.
            </param>
             <param name="RT2">
             (output) DOUBLE PRECISION
             The eigenvalue of smaller absolute value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLADIV">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLADIV performs complex division in  real arithmetic
             
             a + i*b
             p + i*q = ---------
             c + i*d
             
             The algorithm is due to Robert L. Smith and can be found
             in D. Knuth, The art of Computer Programming, Vol.2, p.195
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLADIV.Run(System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLADIV performs complex division in  real arithmetic
             
             a + i*b
             p + i*q = ---------
             c + i*d
             
             The algorithm is due to Robert L. Smith and can be found
             in D. Knuth, The art of Computer Programming, Vol.2, p.195
             
            </summary>
             <param name="A">
             + i*b
            </param>
             <param name="B">
             (input) DOUBLE PRECISION
            </param>
             <param name="C">
             + i*d
            </param>
             <param name="D">
             (input) DOUBLE PRECISION
             The scalars a, b, c, and d in the above expression.
            </param>
             <param name="P">
             (output) DOUBLE PRECISION
            </param>
             <param name="Q">
             (output) DOUBLE PRECISION
             The scalars p and q in the above expression.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGGLM">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGGLM solves a general Gauss-Markov linear model (GLM) problem:
             
             minimize || y ||_2   subject to   d = A*x + B*y
             x
             
             where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
             given N-vector. It is assumed that M .LE. N .LE. M+P, and
             
             rank(A) = M    and    rank( A B ) = N.
             
             Under these assumptions, the constrained equation is always
             consistent, and there is a unique solution x and a minimal 2-norm
             solution y, which is obtained using a generalized QR factorization
             of the matrices (A, B) given by
             
             A = Q*(R),   B = Q*T*Z.
             (0)
             
             In particular, if matrix B is square nonsingular, then the problem
             GLM is equivalent to the following weighted linear least squares
             problem
             
             minimize || inv(B)*(d-A*x) ||_2
             x
             
             where inv(B) denotes the inverse of B.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGGLM.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGGLM solves a general Gauss-Markov linear model (GLM) problem:
             
             minimize || y ||_2   subject to   d = A*x + B*y
             x
             
             where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
             given N-vector. It is assumed that M .LE. N .LE. M+P, and
             
             rank(A) = M    and    rank( A B ) = N.
             
             Under these assumptions, the constrained equation is always
             consistent, and there is a unique solution x and a minimal 2-norm
             solution y, which is obtained using a generalized QR factorization
             of the matrices (A, B) given by
             
             A = Q*(R),   B = Q*T*Z.
             (0)
             
             In particular, if matrix B is square nonsingular, then the problem
             GLM is equivalent to the following weighted linear least squares
             problem
             
             minimize || inv(B)*(d-A*x) ||_2
             x
             
             where inv(B) denotes the inverse of B.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of rows of the matrices A and B.  N .GE. 0.
            </param>
             <param name="M">
             (input) INTEGER
             The number of columns of the matrix A.  0 .LE. M .LE. N.
            </param>
             <param name="P">
             (input) INTEGER
             The number of columns of the matrix B.  P .GE. N-M.
            </param>
             <param name="A">
             = Q*(R),   B = Q*T*Z.
             (0)
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,N).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,P)
             On entry, the N-by-P matrix B.
             On exit, if N .LE. P, the upper triangle of the subarray
             B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
             if N .GT. P, the elements on and above the (N-P)th subdiagonal
             contain the N-by-P upper trapezoidal matrix T.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,N).
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, D is the left hand side of the GLM equation.
             On exit, D is destroyed.
            </param>
             <param name="X">
             (output) DOUBLE PRECISION array, dimension (M)
            </param>
             <param name="Y">
             (output) DOUBLE PRECISION array, dimension (P)
             On exit, X and Y are the solutions of the GLM problem.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N+M+P).
             For optimum performance, LWORK .GE. M+min(N,P)+max(N,P)*NB,
             where NB is an upper bound for the optimal blocksizes for
             DGEQRF, SGERQF, DORMQR and SORMRQ.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             = 1:  the upper triangular factor R associated with A in the
             generalized QR factorization of the pair (A, B) is
             singular, so that rank(A) .LT. M; the least squares
             solution could not be computed.
             = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal
             factor T associated with B in the generalized QR
             factorization of the pair (A, B) is singular, so that
             rank( A B ) .LT. N; the least squares solution could not
             be computed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGERQ2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGERQ2 computes an RQ factorization of a real m by n matrix A:
             A = R * Q.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGERQ2.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGERQ2 computes an RQ factorization of a real m by n matrix A:
             A = R * Q.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n matrix A.
             On exit, if m .LE. n, the upper triangle of the subarray
             A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
             if m .GE. n, the elements on and above the (m-n)-th subdiagonal
             contain the m by n upper trapezoidal matrix R; the remaining
             elements, with the array TAU, represent the orthogonal matrix
             Q as a product of elementary reflectors (see Further
             Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (M)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGBTRS">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGBTRS solves a system of linear equations
             A * X = B  or  A' * X = B
             with a general band matrix A using the LU factorization computed
             by DGBTRF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGBTRS.Run(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGBTRS solves a system of linear equations
             A * X = B  or  A' * X = B
             with a general band matrix A using the LU factorization computed
             by DGBTRF.
             
            </summary>
             <param name="TRANS">
             (input) CHARACTER*1
             Specifies the form of the system of equations.
             = 'N':  A * X = B  (No transpose)
             = 'T':  A'* X = B  (Transpose)
             = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="KL">
             (input) INTEGER
             The number of subdiagonals within the band of A.  KL .GE. 0.
            </param>
             <param name="KU">
             (input) INTEGER
             The number of superdiagonals within the band of A.  KU .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="AB">
             (input) DOUBLE PRECISION array, dimension (LDAB,N)
             Details of the LU factorization of the band matrix A, as
             computed by DGBTRF.  U is stored as an upper triangular band
             matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
             the multipliers used during the factorization are stored in
             rows KL+KU+2 to 2*KL+KU+1.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. 2*KL+KU+1.
            </param>
             <param name="IPIV">
             (input) INTEGER array, dimension (N)
             The pivot indices; for 1 .LE. i .LE. N, row i of the matrix was
             interchanged with row IPIV(i).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DASUM">
             <summary>
             Purpose
             =======
             
             takes the sum of the absolute values.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DASUM.Run(System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             takes the sum of the absolute values.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.DCSRCH.Run(System.Double,System.Double,System.Double@,System.Double,System.Double,System.Double,System.Double,System.Double,DotNumerics.Optimization.LBFGSB.BFGSTask@,System.Int32[]@,System.Int32,System.Double[]@,System.Int32)">
             <param name="F">
             is a double precision variable.
             On initial entry f is the value of the function at 0.
             On subsequent entries f is the value of the 
             function at stp.
             On exit f is the value of the function at stp.
            </param>
             <param name="G">
             is a double precision variable.
             On initial entry g is the derivative of the function at 0.
             On subsequent entries g is the derivative of the 
             function at stp.
             On exit g is the derivative of the function at stp.
             
             stp is a double precision variable. 
             On entry stp is the current estimate of a satisfactory 
             step. On initial entry, a positive initial estimate 
             must be provided. 
             On exit stp is the current estimate of a satisfactory step
             if task = 'FG'. If task = 'CONV' then stp satisfies
             the sufficient decrease and curvature condition.
             
             ftol is a double precision variable.
             On entry ftol specifies a nonnegative tolerance for the 
             sufficient decrease condition.
             On exit ftol is unchanged.
             
             gtol is a double precision variable.
             On entry gtol specifies a nonnegative tolerance for the 
             curvature condition. 
             On exit gtol is unchanged.
             
             xtol is a double precision variable.
             On entry xtol specifies a nonnegative relative tolerance
             for an acceptable step. The subroutine exits with a
             warning if the relative difference between sty and stx
             is less than xtol.
             On exit xtol is unchanged.
             
             stpmin is a double precision variable.
             On entry stpmin is a nonnegative lower bound for the step.
             On exit stpmin is unchanged.
             
             stpmax is a double precision variable.
             On entry stpmax is a nonnegative upper bound for the step.
             On exit stpmax is unchanged.
             
             task is a character variable of length at least 60.
             On initial entry task must be set to 'START'.
             On exit task indicates the required action:
             
             If task(1:2) = 'FG' then evaluate the function and 
             derivative at stp and call dcsrch again.
             
             If task(1:4) = 'CONV' then the search is successful.
             
             If task(1:4) = 'WARN' then the subroutine is not able
             to satisfy the convergence conditions. The exit value of
             stp contains the best point found during the search.
             
             If task(1:5) = 'ERROR' then there is an error in the
             input arguments.
             
             On exit with convergence, a warning or an error, the
             variable task contains additional information.
             
             isave is an integer work array of dimension 2.
             
             dsave is a double precision work array of dimension 13.
             
             Subprograms called
             
             MINPACK-2 ... dcstep
             
             MINPACK-1 Project. June 1983.
             Argonne National Laboratory. 
             Jorge J. More' and David J. Thuente.
             
             MINPACK-2 Project. October 1993.
             Argonne National Laboratory and University of Minnesota. 
             Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
             
             **********
             
             
             
             
             Initialization block.
            </param>
             <param name="STP">
             is a double precision variable. 
             On entry stp is the current estimate of a satisfactory 
             step. On initial entry, a positive initial estimate 
             must be provided. 
             On exit stp is the current estimate of a satisfactory step
             if task = 'FG'. If task = 'CONV' then stp satisfies
             the sufficient decrease and curvature condition.
             
             ftol is a double precision variable.
             On entry ftol specifies a nonnegative tolerance for the 
             sufficient decrease condition.
             On exit ftol is unchanged.
             
             gtol is a double precision variable.
             On entry gtol specifies a nonnegative tolerance for the 
             curvature condition. 
             On exit gtol is unchanged.
             
             xtol is a double precision variable.
             On entry xtol specifies a nonnegative relative tolerance
             for an acceptable step. The subroutine exits with a
             warning if the relative difference between sty and stx
             is less than xtol.
             On exit xtol is unchanged.
             
             stpmin is a double precision variable.
             On entry stpmin is a nonnegative lower bound for the step.
             On exit stpmin is unchanged.
             
             stpmax is a double precision variable.
             On entry stpmax is a nonnegative upper bound for the step.
             On exit stpmax is unchanged.
             
             task is a character variable of length at least 60.
             On initial entry task must be set to 'START'.
             On exit task indicates the required action:
             
             If task(1:2) = 'FG' then evaluate the function and 
             derivative at stp and call dcsrch again.
             
             If task(1:4) = 'CONV' then the search is successful.
             
             If task(1:4) = 'WARN' then the subroutine is not able
             to satisfy the convergence conditions. The exit value of
             stp contains the best point found during the search.
             
             If task(1:5) = 'ERROR' then there is an error in the
             input arguments.
             
             On exit with convergence, a warning or an error, the
             variable task contains additional information.
             
             isave is an integer work array of dimension 2.
             
             dsave is a double precision work array of dimension 13.
             
             Subprograms called
             
             MINPACK-2 ... dcstep
             
             MINPACK-1 Project. June 1983.
             Argonne National Laboratory. 
             Jorge J. More' and David J. Thuente.
             
             MINPACK-2 Project. October 1993.
             Argonne National Laboratory and University of Minnesota. 
             Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
             
             **********
             
             
             
             
             Initialization block.
            </param>
             <param name="FTOL">
             is a double precision variable.
             On entry ftol specifies a nonnegative tolerance for the 
             sufficient decrease condition.
             On exit ftol is unchanged.
            </param>
             <param name="GTOL">
             is a double precision variable.
             On entry gtol specifies a nonnegative tolerance for the 
             curvature condition. 
             On exit gtol is unchanged.
            </param>
             <param name="XTOL">
             is a double precision variable.
             On entry xtol specifies a nonnegative relative tolerance
             for an acceptable step. The subroutine exits with a
             warning if the relative difference between sty and stx
             is less than xtol.
             On exit xtol is unchanged.
             
             stpmin is a double precision variable.
             On entry stpmin is a nonnegative lower bound for the step.
             On exit stpmin is unchanged.
             
             stpmax is a double precision variable.
             On entry stpmax is a nonnegative upper bound for the step.
             On exit stpmax is unchanged.
             
             task is a character variable of length at least 60.
             On initial entry task must be set to 'START'.
             On exit task indicates the required action:
             
             If task(1:2) = 'FG' then evaluate the function and 
             derivative at stp and call dcsrch again.
             
             If task(1:4) = 'CONV' then the search is successful.
             
             If task(1:4) = 'WARN' then the subroutine is not able
             to satisfy the convergence conditions. The exit value of
             stp contains the best point found during the search.
             
             If task(1:5) = 'ERROR' then there is an error in the
             input arguments.
             
             On exit with convergence, a warning or an error, the
             variable task contains additional information.
             
             isave is an integer work array of dimension 2.
             
             dsave is a double precision work array of dimension 13.
             
             Subprograms called
             
             MINPACK-2 ... dcstep
             
             MINPACK-1 Project. June 1983.
             Argonne National Laboratory. 
             Jorge J. More' and David J. Thuente.
             
             MINPACK-2 Project. October 1993.
             Argonne National Laboratory and University of Minnesota. 
             Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
             
             **********
             
             
             
             
             Initialization block.
            </param>
             <param name="STPMIN">
             is a double precision variable.
             On entry stpmin is a nonnegative lower bound for the step.
             On exit stpmin is unchanged.
             
             stpmax is a double precision variable.
             On entry stpmax is a nonnegative upper bound for the step.
             On exit stpmax is unchanged.
             
             task is a character variable of length at least 60.
             On initial entry task must be set to 'START'.
             On exit task indicates the required action:
             
             If task(1:2) = 'FG' then evaluate the function and 
             derivative at stp and call dcsrch again.
             
             If task(1:4) = 'CONV' then the search is successful.
             
             If task(1:4) = 'WARN' then the subroutine is not able
             to satisfy the convergence conditions. The exit value of
             stp contains the best point found during the search.
             
             If task(1:5) = 'ERROR' then there is an error in the
             input arguments.
             
             On exit with convergence, a warning or an error, the
             variable task contains additional information.
             
             isave is an integer work array of dimension 2.
             
             dsave is a double precision work array of dimension 13.
             
             Subprograms called
             
             MINPACK-2 ... dcstep
             
             MINPACK-1 Project. June 1983.
             Argonne National Laboratory. 
             Jorge J. More' and David J. Thuente.
             
             MINPACK-2 Project. October 1993.
             Argonne National Laboratory and University of Minnesota. 
             Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
             
             **********
             
             
             
             
             Initialization block.
            </param>
             <param name="STPMAX">
             is a double precision variable.
             On entry stpmax is a nonnegative upper bound for the step.
             On exit stpmax is unchanged.
             
             task is a character variable of length at least 60.
             On initial entry task must be set to 'START'.
             On exit task indicates the required action:
             
             If task(1:2) = 'FG' then evaluate the function and 
             derivative at stp and call dcsrch again.
             
             If task(1:4) = 'CONV' then the search is successful.
             
             If task(1:4) = 'WARN' then the subroutine is not able
             to satisfy the convergence conditions. The exit value of
             stp contains the best point found during the search.
             
             If task(1:5) = 'ERROR' then there is an error in the
             input arguments.
             
             On exit with convergence, a warning or an error, the
             variable task contains additional information.
             
             isave is an integer work array of dimension 2.
             
             dsave is a double precision work array of dimension 13.
             
             Subprograms called
             
             MINPACK-2 ... dcstep
             
             MINPACK-1 Project. June 1983.
             Argonne National Laboratory. 
             Jorge J. More' and David J. Thuente.
             
             MINPACK-2 Project. October 1993.
             Argonne National Laboratory and University of Minnesota. 
             Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
             
             **********
             
             
             
             
             Initialization block.
            </param>
             <param name="TASK">
             = 'START'
            </param>
             <param name="ISAVE">
             is an integer work array of dimension 2.
            </param>
             <param name="DSAVE">
             is a double precision work array of dimension 13.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.EigenSystem">
            <summary>
            Computes the eigenvalues and the eigenvectors of a square matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.#ctor">
            <summary>
            Initializes a new instance of the EigenSystem class.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the eigenvalues for an N-by-N real nonsymmetric matrix A.
            </summary>
            <param name="A">N-by-N real nonsymmetric matrix A.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.ComplexMatrix@)">
            <summary>
            Computes for an N-by-N real nonsymmetric matrix A, the
            eigenvalues and eigenvectors.
            </summary>
            <param name="A">N-by-N real nonsymmetric matrix A.</param>
            <param name="EigenVectors">The eigenvectors.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.SymmetricMatrix)">
            <summary>
            Computes all eigenvalues of a real symmetric matrix A.
            </summary>
            <param name="A">The real symmetric matrix A.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.SymmetricMatrix,DotNumerics.LinearAlgebra.Matrix@)">
            <summary>
            Computes all eigenvalues and eigenvectors of a of a real symmetric matrix A.
            </summary>
            <param name="A">The real symmetric matrix A.</param>
            <param name="EigenVects">The eigenvectors.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.SymmetricBandMatrix)">
             <summary>
            Computes all the eigenvalues of
             a real symmetric band matrix A.
             </summary>
             <param name="A">The real symmetric band matrix A.</param>
             <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.SymmetricBandMatrix,DotNumerics.LinearAlgebra.Matrix@)">
             <summary>
            Computes all the eigenvalues and eigenvectors of
             a real symmetric band matrix A.
             </summary>
             <param name="A">The real symmetric band matrix A.</param>
             <param name="EigenVects">The eigenvectors.</param>
             <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Computes the eigenvalues for an complex general matrix A.
            </summary>
            <param name="A">The complex general matrix A.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.EigenSystem.GetEigenvalues(DotNumerics.LinearAlgebra.ComplexMatrix,DotNumerics.LinearAlgebra.ComplexMatrix@)">
            <summary>
            Computes the eigenvalues and eigenvectors for an complex general matrix A.
            </summary>
            <param name="A">The complex general matrix A.</param>
            <param name="EigenVectors">The eigenvectors.</param>
            <returns>The eigenvalues.</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYR2K">
             <summary>
             Purpose
             =======
             
             DSYR2K  performs one of the symmetric rank 2k operations
             
             C := alpha*A*B' + alpha*B*A' + beta*C,
             
             or
             
             C := alpha*A'*B + alpha*B'*A + beta*C,
             
             where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
             and  A and B  are  n by k  matrices  in the  first  case  and  k by n
             matrices in the second case.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYR2K.Run(System.String,System.String,System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DSYR2K  performs one of the symmetric rank 2k operations
             
             C := alpha*A*B' + alpha*B*A' + beta*C,
             
             or
             
             C := alpha*A'*B + alpha*B'*A + beta*C,
             
             where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
             and  A and B  are  n by k  matrices  in the  first  case  and  k by n
             matrices in the second case.
             
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
             
             UPLO = 'U' or 'u'   Only the  upper triangular part of  C
             is to be referenced.
             
             UPLO = 'L' or 'l'   Only the  lower triangular part of  C
             is to be referenced.
             
             Unchanged on exit.
            </param>
             <param name="TRANS">
             - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   C := alpha*A*B' + alpha*B*A' +
             beta*C.
             
             TRANS = 'T' or 't'   C := alpha*A'*B + alpha*B'*A +
             beta*C.
             
             TRANS = 'C' or 'c'   C := alpha*A'*B + alpha*B'*A +
             beta*C.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.
            </param>
             <param name="K">
             - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.
            </param>
             <param name="B">
             - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.
            </param>
             <param name="LDB">
             - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.
            </param>
             <param name="BETA">
             - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.
            </param>
             <param name="C">
             := alpha*A*B' + alpha*B*A' + beta*C,
            </param>
             <param name="LDC">
             - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSTEDC">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
             symmetric tridiagonal matrix using the divide and conquer method.
             The eigenvectors of a full or band real symmetric matrix can also be
             found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
             matrix to tridiagonal form.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.  See DLAED3 for details.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSTEDC.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
             symmetric tridiagonal matrix using the divide and conquer method.
             The eigenvectors of a full or band real symmetric matrix can also be
             found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
             matrix to tridiagonal form.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.  See DLAED3 for details.
             
            </summary>
             <param name="COMPZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only.
             = 'I':  Compute eigenvectors of tridiagonal matrix also.
             = 'V':  Compute eigenvectors of original dense symmetric
             matrix also.  On entry, Z contains the orthogonal
             matrix used to reduce the original matrix to
             tridiagonal form.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the diagonal elements of the tridiagonal matrix.
             On exit, if INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, the subdiagonal elements of the tridiagonal matrix.
             On exit, E has been destroyed.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
             On entry, if COMPZ = 'V', then Z contains the orthogonal
             matrix used in the reduction to tridiagonal form.
             On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
             orthonormal eigenvectors of the original symmetric matrix,
             and if COMPZ = 'I', Z contains the orthonormal eigenvectors
             of the symmetric tridiagonal matrix.
             If  COMPZ = 'N', then Z is not referenced.
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  LDZ .GE. 1.
             If eigenvectors are desired, then LDZ .GE. max(1,N).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array,
             dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If COMPZ = 'N' or N .LE. 1 then LWORK must be at least 1.
             If COMPZ = 'V' and N .GT. 1 then LWORK must be at least
             ( 1 + 3*N + 2*N*lg N + 3*N**2 ),
             where lg( N ) = smallest integer k such
             that 2**k .GE. N.
             If COMPZ = 'I' and N .GT. 1 then LWORK must be at least
             ( 1 + 4*N + N**2 ).
             Note that for COMPZ = 'I' or 'V', then if N is less than or
             equal to the minimum divide size, usually 25, then LWORK need
             only be max(1,2*(N-1)).
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="IWORK">
             (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
             On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </param>
             <param name="LIWORK">
             (input) INTEGER
             The dimension of the array IWORK.
             If COMPZ = 'N' or N .LE. 1 then LIWORK must be at least 1.
             If COMPZ = 'V' and N .GT. 1 then LIWORK must be at least
             ( 6 + 6*N + 5*N*lg N ).
             If COMPZ = 'I' and N .GT. 1 then LIWORK must be at least
             ( 3 + 5*N ).
             Note that for COMPZ = 'I' or 'V', then if N is less than or
             equal to the minimum divide size, usually 25, then LIWORK
             need only be 1.
             
             If LIWORK = -1, then a workspace query is assumed; the
             routine only calculates the optimal size of the IWORK array,
             returns this value as the first entry of the IWORK array, and
             no error message related to LIWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  The algorithm failed to compute an eigenvalue while
             working on the submatrix lying in rows and columns
             INFO/(N+1) through mod(INFO,N+1).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMRQ">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMRQ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMRQ.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMRQ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGERQF in the last k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGERQF.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMBR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
             with
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
             with
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      P * C          C * P
             TRANS = 'T':      P**T * C       C * P**T
             
             Here Q and P**T are the orthogonal matrices determined by DGEBRD when
             reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
             P**T are defined as products of elementary reflectors H(i) and G(i)
             respectively.
             
             Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
             order of the orthogonal matrix Q or P**T that is applied.
             
             If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
             if nq .GE. k, Q = H(1) H(2) . . . H(k);
             if nq .LT. k, Q = H(1) H(2) . . . H(nq-1).
             
             If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
             if k .LT. nq, P = G(1) G(2) . . . G(k);
             if k .GE. nq, P = G(1) G(2) . . . G(nq-1).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMBR.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
             with
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
             with
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      P * C          C * P
             TRANS = 'T':      P**T * C       C * P**T
             
             Here Q and P**T are the orthogonal matrices determined by DGEBRD when
             reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
             P**T are defined as products of elementary reflectors H(i) and G(i)
             respectively.
             
             Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
             order of the orthogonal matrix Q or P**T that is applied.
             
             If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
             if nq .GE. k, Q = H(1) H(2) . . . H(k);
             if nq .LT. k, Q = H(1) H(2) . . . H(nq-1).
             
             If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
             if k .LT. nq, P = G(1) G(2) . . . G(k);
             if k .GE. nq, P = G(1) G(2) . . . G(nq-1).
             
            </summary>
             <param name="VECT">
             (input) CHARACTER*1
             = 'Q': apply Q or Q**T;
             = 'P': apply P or P**T.
            </param>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q, Q**T, P or P**T from the Left;
             = 'R': apply Q, Q**T, P or P**T from the Right.
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q  or P;
             = 'T':  Transpose, apply Q**T or P**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             If VECT = 'Q', the number of columns in the original
             matrix reduced by DGEBRD.
             If VECT = 'P', the number of rows in the original
             matrix reduced by DGEBRD.
             K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,min(nq,K)) if VECT = 'Q'
             (LDA,nq)        if VECT = 'P'
             The vectors which define the elementary reflectors H(i) and
             G(i), whose products determine the matrices Q and P, as
             returned by DGEBRD.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             If VECT = 'Q', LDA .GE. max(1,nq);
             if VECT = 'P', LDA .GE. max(1,min(nq,K)).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (min(nq,K))
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i) or G(i) which determines Q or P, as returned
             by DGEBRD in the array argument TAUQ or TAUP.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
             or P*C or P**T*C or C*P or C*P**T.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGLQ">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
             which is defined as the first M rows of a product of K elementary
             reflectors of order N
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGELQF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGLQ.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
             which is defined as the first M rows of a product of K elementary
             reflectors of order N
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGELQF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. N .GE. M.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. M .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the i-th row must contain the vector which defines
             the elementary reflector H(i), for i = 1,2,...,k, as returned
             by DGELQF in the first k rows of its array argument A.
             On exit, the M-by-N matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGELQF.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. M*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAZQ4">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAZQ4 computes an approximation TAU to the smallest eigenvalue 
             using values of d from the previous transform.
             
             I0    (input) INTEGER
             First index.
             
             N0    (input) INTEGER
             Last index.
             
             Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array.
             
             PP    (input) INTEGER
             PP=0 for ping, PP=1 for pong.
             
             N0IN  (input) INTEGER
             The value of N0 at start of EIGTEST.
             
             DMIN  (input) DOUBLE PRECISION
             Minimum value of d.
             
             DMIN1 (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).
             
             DMIN2 (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).
             
             DN    (input) DOUBLE PRECISION
             d(N)
             
             DN1   (input) DOUBLE PRECISION
             d(N-1)
             
             DN2   (input) DOUBLE PRECISION
             d(N-2)
             
             TAU   (output) DOUBLE PRECISION
             This is the shift.
             
             TTYPE (output) INTEGER
             Shift type.
             
             G     (input/output) DOUBLE PRECISION
             G is passed as an argument in order to save its value between
             calls to DLAZQ4
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAZQ4.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@,System.Int32@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAZQ4 computes an approximation TAU to the smallest eigenvalue 
             using values of d from the previous transform.
             
             I0    (input) INTEGER
             First index.
             
             N0    (input) INTEGER
             Last index.
             
             Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array.
             
             PP    (input) INTEGER
             PP=0 for ping, PP=1 for pong.
             
             N0IN  (input) INTEGER
             The value of N0 at start of EIGTEST.
             
             DMIN  (input) DOUBLE PRECISION
             Minimum value of d.
             
             DMIN1 (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).
             
             DMIN2 (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).
             
             DN    (input) DOUBLE PRECISION
             d(N)
             
             DN1   (input) DOUBLE PRECISION
             d(N-1)
             
             DN2   (input) DOUBLE PRECISION
             d(N-2)
             
             TAU   (output) DOUBLE PRECISION
             This is the shift.
             
             TTYPE (output) INTEGER
             Shift type.
             
             G     (input/output) DOUBLE PRECISION
             G is passed as an argument in order to save its value between
             calls to DLAZQ4
             
            </summary>
             <param name="I0">
             (input) INTEGER
             First index.
            </param>
             <param name="N0">
             (input) INTEGER
             Last index.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array.
            </param>
             <param name="PP">
             (input) INTEGER
             PP=0 for ping, PP=1 for pong.
            </param>
             <param name="N0IN">
             (input) INTEGER
             The value of N0 at start of EIGTEST.
            </param>
             <param name="DMIN">
             (input) DOUBLE PRECISION
             Minimum value of d.
            </param>
             <param name="DMIN1">
             (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).
            </param>
             <param name="DMIN2">
             (input) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).
            </param>
             <param name="DN">
             (input) DOUBLE PRECISION
             d(N)
            </param>
             <param name="DN1">
             (input) DOUBLE PRECISION
             d(N-1)
            </param>
             <param name="DN2">
             (input) DOUBLE PRECISION
             d(N-2)
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION
             This is the shift.
            </param>
             <param name="TTYPE">
             (output) INTEGER
             Shift type.
            </param>
             <param name="G">
             (input/output) DOUBLE PRECISION
             G is passed as an argument in order to save its value between
             calls to DLAZQ4
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASY2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASY2 solves for the N1 by N2 matrix X, 1 .LE. N1,N2 .LE. 2, in
             
             op(TL)*X + ISGN*X*op(TR) = SCALE*B,
             
             where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
             -1.  op(T) = T or T', where T' denotes the transpose of T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASY2.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Int32,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASY2 solves for the N1 by N2 matrix X, 1 .LE. N1,N2 .LE. 2, in
             
             op(TL)*X + ISGN*X*op(TR) = SCALE*B,
             
             where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
             -1.  op(T) = T or T', where T' denotes the transpose of T.
             
            </summary>
             <param name="LTRANL">
             (input) LOGICAL
             On entry, LTRANL specifies the op(TL):
             = .FALSE., op(TL) = TL,
             = .TRUE., op(TL) = TL'.
            </param>
             <param name="LTRANR">
             (input) LOGICAL
             On entry, LTRANR specifies the op(TR):
             = .FALSE., op(TR) = TR,
             = .TRUE., op(TR) = TR'.
            </param>
             <param name="ISGN">
             (input) INTEGER
             On entry, ISGN specifies the sign of the equation
             as described before. ISGN may only be 1 or -1.
            </param>
             <param name="N1">
             (input) INTEGER
             On entry, N1 specifies the order of matrix TL.
             N1 may only be 0, 1 or 2.
            </param>
             <param name="N2">
             (input) INTEGER
             On entry, N2 specifies the order of matrix TR.
             N2 may only be 0, 1 or 2.
            </param>
             <param name="TL">
             (input) DOUBLE PRECISION array, dimension (LDTL,2)
             On entry, TL contains an N1 by N1 matrix.
            </param>
             <param name="LDTL">
             (input) INTEGER
             The leading dimension of the matrix TL. LDTL .GE. max(1,N1).
            </param>
             <param name="TR">
             (input) DOUBLE PRECISION array, dimension (LDTR,2)
             On entry, TR contains an N2 by N2 matrix.
            </param>
             <param name="LDTR">
             (input) INTEGER
             The leading dimension of the matrix TR. LDTR .GE. max(1,N2).
            </param>
             <param name="B">
             (input) DOUBLE PRECISION array, dimension (LDB,2)
             On entry, the N1 by N2 matrix B contains the right-hand
             side of the equation.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the matrix B. LDB .GE. max(1,N1).
            </param>
             <param name="SCALE">
             (output) DOUBLE PRECISION
             On exit, SCALE contains the scale factor. SCALE is chosen
             less than or equal to 1 to prevent the solution overflowing.
            </param>
             <param name="X">
             (output) DOUBLE PRECISION array, dimension (LDX,2)
             On exit, X contains the N1 by N2 solution.
            </param>
             <param name="LDX">
             (input) INTEGER
             The leading dimension of the matrix X. LDX .GE. max(1,N1).
            </param>
             <param name="XNORM">
             (output) DOUBLE PRECISION
             On exit, XNORM is the infinity-norm of the solution.
            </param>
             <param name="INFO">
             (output) INTEGER
             On exit, INFO is set to
             0: successful exit.
             1: TL and TR have too close eigenvalues, so TL or
             TR is perturbed to get a nonsingular equation.
             NOTE: In the interests of speed, this routine does not
             check the inputs for errors.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASR">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASR applies a sequence of plane rotations to a real matrix A,
             from either the left or the right.
             
             When SIDE = 'L', the transformation takes the form
             
             A := P*A
             
             and when SIDE = 'R', the transformation takes the form
             
             A := A*P**T
             
             where P is an orthogonal matrix consisting of a sequence of z plane
             rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
             and P**T is the transpose of P.
             
             When DIRECT = 'F' (Forward sequence), then
             
             P = P(z-1) * ... * P(2) * P(1)
             
             and when DIRECT = 'B' (Backward sequence), then
             
             P = P(1) * P(2) * ... * P(z-1)
             
             where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
             
             R(k) = (  c(k)  s(k) )
             = ( -s(k)  c(k) ).
             
             When PIVOT = 'V' (Variable pivot), the rotation is performed
             for the plane (k,k+1), i.e., P(k) has the form
             
             P(k) = (  1                                            )
             (       ...                                     )
             (              1                                )
             (                   c(k)  s(k)                  )
             (                  -s(k)  c(k)                  )
             (                                1              )
             (                                     ...       )
             (                                            1  )
             
             where R(k) appears as a rank-2 modification to the identity matrix in
             rows and columns k and k+1.
             
             When PIVOT = 'T' (Top pivot), the rotation is performed for the
             plane (1,k+1), so P(k) has the form
             
             P(k) = (  c(k)                    s(k)                 )
             (         1                                     )
             (              ...                              )
             (                     1                         )
             ( -s(k)                    c(k)                 )
             (                                 1             )
             (                                      ...      )
             (                                             1 )
             
             where R(k) appears in rows and columns 1 and k+1.
             
             Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
             performed for the plane (k,z), giving P(k) the form
             
             P(k) = ( 1                                             )
             (      ...                                      )
             (             1                                 )
             (                  c(k)                    s(k) )
             (                         1                     )
             (                              ...              )
             (                                     1         )
             (                 -s(k)                    c(k) )
             
             where R(k) appears in rows and columns k and z.  The rotations are
             performed without ever forming P(k) explicitly.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASR.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLASR applies a sequence of plane rotations to a real matrix A,
             from either the left or the right.
             
             When SIDE = 'L', the transformation takes the form
             
             A := P*A
             
             and when SIDE = 'R', the transformation takes the form
             
             A := A*P**T
             
             where P is an orthogonal matrix consisting of a sequence of z plane
             rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
             and P**T is the transpose of P.
             
             When DIRECT = 'F' (Forward sequence), then
             
             P = P(z-1) * ... * P(2) * P(1)
             
             and when DIRECT = 'B' (Backward sequence), then
             
             P = P(1) * P(2) * ... * P(z-1)
             
             where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
             
             R(k) = (  c(k)  s(k) )
             = ( -s(k)  c(k) ).
             
             When PIVOT = 'V' (Variable pivot), the rotation is performed
             for the plane (k,k+1), i.e., P(k) has the form
             
             P(k) = (  1                                            )
             (       ...                                     )
             (              1                                )
             (                   c(k)  s(k)                  )
             (                  -s(k)  c(k)                  )
             (                                1              )
             (                                     ...       )
             (                                            1  )
             
             where R(k) appears as a rank-2 modification to the identity matrix in
             rows and columns k and k+1.
             
             When PIVOT = 'T' (Top pivot), the rotation is performed for the
             plane (1,k+1), so P(k) has the form
             
             P(k) = (  c(k)                    s(k)                 )
             (         1                                     )
             (              ...                              )
             (                     1                         )
             ( -s(k)                    c(k)                 )
             (                                 1             )
             (                                      ...      )
             (                                             1 )
             
             where R(k) appears in rows and columns 1 and k+1.
             
             Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
             performed for the plane (k,z), giving P(k) the form
             
             P(k) = ( 1                                             )
             (      ...                                      )
             (             1                                 )
             (                  c(k)                    s(k) )
             (                         1                     )
             (                              ...              )
             (                                     1         )
             (                 -s(k)                    c(k) )
             
             where R(k) appears in rows and columns k and z.  The rotations are
             performed without ever forming P(k) explicitly.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             Specifies whether the plane rotation matrix P is applied to
             A on the left or the right.
             = 'L':  Left, compute A := P*A
             = 'R':  Right, compute A:= A*P**T
            </param>
             <param name="PIVOT">
             (input) CHARACTER*1
             Specifies the plane for which P(k) is a plane rotation
             matrix.
             = 'V':  Variable pivot, the plane (k,k+1)
             = 'T':  Top pivot, the plane (1,k+1)
             = 'B':  Bottom pivot, the plane (k,z)
            </param>
             <param name="DIRECT">
             (input) CHARACTER*1
             Specifies whether P is a forward or backward sequence of
             plane rotations.
             = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
             = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  If m .LE. 1, an immediate
             return is effected.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  If n .LE. 1, an
             immediate return is effected.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION array, dimension
             (M-1) if SIDE = 'L'
             (N-1) if SIDE = 'R'
             The cosines c(k) of the plane rotations.
            </param>
             <param name="S">
             (input) DOUBLE PRECISION array, dimension
             (M-1) if SIDE = 'L'
             (N-1) if SIDE = 'R'
             The sines s(k) of the plane rotations.  The 2-by-2 plane
             rotation part of the matrix P(k), R(k), has the form
             R(k) = (  c(k)  s(k) )
             ( -s(k)  c(k) ).
            </param>
             <param name="A">
             := P*A
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASDA">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             Using a divide and conquer approach, DLASDA computes the singular
             value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
             B with diagonal D and offdiagonal E, where M = N + SQRE. The
             algorithm computes the singular values in the SVD B = U * S * VT.
             The orthogonal matrices U and VT are optionally computed in
             compact form.
             
             A related subroutine, DLASD0, computes the singular values and
             the singular vectors in explicit form.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASDA.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             Using a divide and conquer approach, DLASDA computes the singular
             value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
             B with diagonal D and offdiagonal E, where M = N + SQRE. The
             algorithm computes the singular values in the SVD B = U * S * VT.
             The orthogonal matrices U and VT are optionally computed in
             compact form.
             
             A related subroutine, DLASD0, computes the singular values and
             the singular vectors in explicit form.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether singular vectors are to be computed
             in compact form, as follows
             = 0: Compute singular values only.
             = 1: Compute singular vectors of upper bidiagonal
             matrix in compact form.
            </param>
             <param name="SMLSIZ">
             (input) INTEGER
             The maximum size of the subproblems at the bottom of the
             computation tree.
            </param>
             <param name="N">
             (input) INTEGER
             The row dimension of the upper bidiagonal matrix. This is
             also the dimension of the main diagonal array D.
            </param>
             <param name="SQRE">
             (input) INTEGER
             Specifies the column dimension of the bidiagonal matrix.
             = 0: The bidiagonal matrix has column dimension M = N;
             = 1: The bidiagonal matrix has column dimension M = N + 1.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension ( N )
             On entry D contains the main diagonal of the bidiagonal
             matrix. On exit D, if INFO = 0, contains its singular values.
            </param>
             <param name="E">
             (input) DOUBLE PRECISION array, dimension ( M-1 )
             Contains the subdiagonal entries of the bidiagonal matrix.
             On exit, E has been destroyed.
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array,
             dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
             if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
             singular vector matrices of all subproblems at the bottom
             level.
            </param>
             <param name="LDU">
             (input) INTEGER, LDU = .GT. N.
             The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
             GIVNUM, and Z.
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array,
             dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
             if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT' contains the right
             singular vector matrices of all subproblems at the bottom
             level.
            </param>
             <param name="K">
             (output) INTEGER array,
             dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
             If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
             secular equation on the computation tree.
            </param>
             <param name="DIFL">
             (output) DOUBLE PRECISION array, dimension ( LDU, NLVL ),
             where NLVL = floor(log_2 (N/SMLSIZ))).
            </param>
             <param name="DIFR">
             (output) DOUBLE PRECISION array,
             dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
             dimension ( N ) if ICOMPQ = 0.
             If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
             record distances between singular values on the I-th
             level and singular values on the (I -1)-th level, and
             DIFR(1:N, 2 * I ) contains the normalizing factors for
             the right singular vector matrix. See DLASD8 for details.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array,
             dimension ( LDU, NLVL ) if ICOMPQ = 1 and
             dimension ( N ) if ICOMPQ = 0.
             The first K elements of Z(1, I) contain the components of
             the deflation-adjusted updating row vector for subproblems
             on the I-th level.
            </param>
             <param name="POLES">
             (output) DOUBLE PRECISION array,
             dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
             if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
             POLES(1, 2*I) contain  the new and old singular values
             involved in the secular equations on the I-th level.
            </param>
             <param name="GIVPTR">
             (output) INTEGER array,
             dimension ( N ) if ICOMPQ = 1, and not referenced if
             ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
             the number of Givens rotations performed on the I-th
             problem on the computation tree.
            </param>
             <param name="GIVCOL">
             (output) INTEGER array,
             dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
             referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
             GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
             of Givens rotations performed on the I-th level on the
             computation tree.
            </param>
             <param name="LDGCOL">
             (input) INTEGER, LDGCOL = .GT. N.
             The leading dimension of arrays GIVCOL and PERM.
            </param>
             <param name="PERM">
             (output) INTEGER array,
             dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
             if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
             permutations done on the I-th level of the computation tree.
            </param>
             <param name="GIVNUM">
             (output) DOUBLE PRECISION array,
             dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
             referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
             GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
             values of Givens rotations performed on the I-th level on
             the computation tree.
            </param>
             <param name="C">
             (output) DOUBLE PRECISION array,
             dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
             If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
             C( I ) contains the C-value of a Givens rotation related to
             the right null space of the I-th subproblem.
            </param>
             <param name="S">
             (output) DOUBLE PRECISION array, dimension ( N ) if
             ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
             and the I-th subproblem is not square, on exit, S( I )
             contains the S-value of a Givens rotation related to
             the right null space of the I-th subproblem.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
            </param>
             <param name="IWORK">
             (workspace) INTEGER array.
             Dimension must be at least (7 * N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARGV">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARGV generates a vector of real plane rotations, determined by
             elements of the real vectors x and y. For i = 1,2,...,n
             
             (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
             ( -s(i)  c(i) ) ( y(i) ) = (   0  )
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARGV.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARGV generates a vector of real plane rotations, determined by
             elements of the real vectors x and y. For i = 1,2,...,n
             
             (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
             ( -s(i)  c(i) ) ( y(i) ) = (   0  )
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of plane rotations to be generated.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             On entry, the vector x.
             On exit, x(i) is overwritten by a(i), for i = 1,...,n.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between elements of X. INCX .GT. 0.
            </param>
             <param name="Y">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCY)
             On entry, the vector y.
             On exit, the sines of the plane rotations.
            </param>
             <param name="INCY">
             (input) INTEGER
             The increment between elements of Y. INCY .GT. 0.
            </param>
             <param name="C">
             (output) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
             The cosines of the plane rotations.
            </param>
             <param name="INCC">
             (input) INTEGER
             The increment between elements of C. INCC .GT. 0.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAPLL">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             Given two column vectors X and Y, let
             
             A = ( X Y ).
             
             The subroutine first computes the QR factorization of A = Q*R,
             and then computes the SVD of the 2-by-2 upper triangular matrix R.
             The smaller singular value of R is returned in SSMIN, which is used
             as the measurement of the linear dependency of the vectors X and Y.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAPLL.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double@)">
             <summary>
             Purpose
             =======
             
             Given two column vectors X and Y, let
             
             A = ( X Y ).
             
             The subroutine first computes the QR factorization of A = Q*R,
             and then computes the SVD of the 2-by-2 upper triangular matrix R.
             The smaller singular value of R is returned in SSMIN, which is used
             as the measurement of the linear dependency of the vectors X and Y.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The length of the vectors X and Y.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCX)
             On entry, X contains the N-vector X.
             On exit, X is overwritten.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between successive elements of X. INCX .GT. 0.
            </param>
             <param name="Y">
             (input/output) DOUBLE PRECISION array,
             dimension (1+(N-1)*INCY)
             On entry, Y contains the N-vector Y.
             On exit, Y is overwritten.
            </param>
             <param name="INCY">
             (input) INTEGER
             The increment between successive elements of Y. INCY .GT. 0.
            </param>
             <param name="SSMIN">
             (output) DOUBLE PRECISION
             The smallest singular value of the N-by-2 matrix A = ( X Y ).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGRQF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGRQF computes a generalized RQ factorization of an M-by-N matrix A
             and a P-by-N matrix B:
             
             A = R*Q,        B = Z*T*Q,
             
             where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
             matrix, and R and T assume one of the forms:
             
             if M .LE. N,  R = ( 0  R12 ) M,   or if M .GT. N,  R = ( R11 ) M-N,
             N-M  M                           ( R21 ) N
             N
             
             where R12 or R21 is upper triangular, and
             
             if P .GE. N,  T = ( T11 ) N  ,   or if P .LT. N,  T = ( T11  T12 ) P,
             (  0  ) P-N                         P   N-P
             N
             
             where T11 is upper triangular.
             
             In particular, if B is square and nonsingular, the GRQ factorization
             of A and B implicitly gives the RQ factorization of A*inv(B):
             
             A*inv(B) = (R*inv(T))*Z'
             
             where inv(B) denotes the inverse of the matrix B, and Z' denotes the
             transpose of the matrix Z.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGRQF.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGRQF computes a generalized RQ factorization of an M-by-N matrix A
             and a P-by-N matrix B:
             
             A = R*Q,        B = Z*T*Q,
             
             where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
             matrix, and R and T assume one of the forms:
             
             if M .LE. N,  R = ( 0  R12 ) M,   or if M .GT. N,  R = ( R11 ) M-N,
             N-M  M                           ( R21 ) N
             N
             
             where R12 or R21 is upper triangular, and
             
             if P .GE. N,  T = ( T11 ) N  ,   or if P .LT. N,  T = ( T11  T12 ) P,
             (  0  ) P-N                         P   N-P
             N
             
             where T11 is upper triangular.
             
             In particular, if B is square and nonsingular, the GRQ factorization
             of A and B implicitly gives the RQ factorization of A*inv(B):
             
             A*inv(B) = (R*inv(T))*Z'
             
             where inv(B) denotes the inverse of the matrix B, and Z' denotes the
             transpose of the matrix Z.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of rows of the matrix B.  P .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrices A and B. N .GE. 0.
            </param>
             <param name="A">
             = R*Q,        B = Z*T*Q,
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAUA">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Q (see Further Details).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,N)
             On entry, the P-by-N matrix B.
             On exit, the elements on and above the diagonal of the array
             contain the min(P,N)-by-N upper trapezoidal matrix T (T is
             upper triangular if P .GE. N); the elements below the diagonal,
             with the array TAUB, represent the orthogonal matrix Z as a
             product of elementary reflectors (see Further Details).
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,P).
            </param>
             <param name="TAUB">
             (output) DOUBLE PRECISION array, dimension (min(P,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Z (see Further Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N,M,P).
             For optimum performance LWORK .GE. max(N,M,P)*max(NB1,NB2,NB3),
             where NB1 is the optimal blocksize for the RQ factorization
             of an M-by-N matrix, NB2 is the optimal blocksize for the
             QR factorization of a P-by-N matrix, and NB3 is the optimal
             blocksize for a call of DORMRQ.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INF0= -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEQRF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEQRF computes a QR factorization of a real M-by-N matrix A:
             A = Q * R.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEQRF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEQRF computes a QR factorization of a real M-by-N matrix A:
             A = Q * R.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m .GE. n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N).
             For optimum performance LWORK .GE. N*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEMV">
             <summary>
             Purpose
             =======
             
             DGEMV  performs one of the matrix-vector operations
             
             y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
             
             where alpha and beta are scalars, x and y are vectors and A is an
             m by n matrix.
             
             Parameters
             ==========
             
             TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
             
             TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
             
             TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
             
             Unchanged on exit.
             
             M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.
             
             ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.
             
             X      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.
             
             INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
             
             BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.
             
             Y      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
             
             INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEMV.Run(System.String,System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DGEMV  performs one of the matrix-vector operations
             
             y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
             
             where alpha and beta are scalars, x and y are vectors and A is an
             m by n matrix.
             
             Parameters
             ==========
             
             TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
             
             TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
             
             TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
             
             Unchanged on exit.
             
             M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.
             
             ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.
             
             X      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.
             
             INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
             
             BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.
             
             Y      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
             
             INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
            </summary>
             <param name="TRANS">
             - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:
             
             TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
             
             TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
             
             TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
             
             Unchanged on exit.
            </param>
             <param name="M">
             - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </param>
             <param name="BETA">
             - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.
            </param>
             <param name="Y">
             := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
            </param>
             <param name="INCY">
             - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
             
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.COMQR.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement.
            </param>
             <param name="N">
             is the order of the matrix.
            </param>
             <param name="LOW">
             and igh are integers determined by the balancing
             subroutine  cbal.  if  cbal  has not been used,
             set low=1, igh=n.
            </param>
             <param name="HR">
             and hi contain the real and imaginary parts,
             respectively, of the complex upper hessenberg matrix.
             their lower triangles below the subdiagonal contain
             information about the unitary transformations used in
             the reduction by  corth, if performed.
            </param>
             <param name="WR">
             and wi contain the real and imaginary parts,
             respectively, of the eigenvalues.  if an error
             exit is made, the eigenvalues should be correct
             for indices ierr+1,...,n.
            </param>
             <param name="IERR">
             is set to
             zero       for normal return,
             j          if the limit of 30*n iterations is exhausted
             while the j-th eigenvalue is being sought.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.BandMatrix">
            <summary>
            Represents a Band Matrix.
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.BaseBandMatrix">
            <summary>
            Represents the base class for band matrices.
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.BaseBandMatrix.MeLowerBandWidth">
            <summary>
            Number of bands below the main diagonal (lowerBandWidth)
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.BaseBandMatrix.MeUpperBandWidth">
            <summary>
            Number of bands above the main diagonal (upperBandWidth)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseBandMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseBandMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size using a array
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
            <param name="Data">The matix data </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseBandMatrix.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseBandMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="Data">The matix data </param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BaseBandMatrix.op_Implicit(DotNumerics.LinearAlgebra.BaseBandMatrix)~DotNumerics.LinearAlgebra.Matrix">
            <summary>
            Implicit BaseBandMatrix to Matrix conversion.
            </summary>
            <param name="bandMatrix">The BandMatrix</param>
            <returns>The Matrix.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseBandMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of a element of the matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The matrix value at (row, column).</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseBandMatrix.LowerBandWidth">
            <summary>
            Number of bands below the main diagonal (lowerBandWidth)
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.BaseBandMatrix.UpperBandWidth">
            <summary>
            Number of bands above the main diagonal (upperBandWidth)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the BandMatrix class of the given size using a array
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
            <param name="Data">The matix data </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.op_Addition(DotNumerics.LinearAlgebra.BandMatrix,DotNumerics.LinearAlgebra.BandMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.op_Subtraction(DotNumerics.LinearAlgebra.BandMatrix,DotNumerics.LinearAlgebra.BandMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.op_Multiply(System.Double,DotNumerics.LinearAlgebra.BandMatrix)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.Clone">
            <summary>
            Creates a copy of the matrix.
            </summary>
            <returns>The copy of the Matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.BandMatrix.Random(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Generate a BandMatrix with random elements</summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="lowerBandWidth">Number of bands below the main diagonal</param>
            <param name="upperBandWidth">Number of bands above the main diagonal</param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.IPARMQ">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This program sets problem and machine dependent parameters
             useful for xHSEQR and its subroutines. It is called whenever 
             ILAENV is called with 12 .LE. ISPEC .LE. 16
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.IPARMQ.Run(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             This program sets problem and machine dependent parameters
             useful for xHSEQR and its subroutines. It is called whenever 
             ILAENV is called with 12 .LE. ISPEC .LE. 16
             
            </summary>
             <param name="ISPEC">
             (input) integer scalar
             ISPEC specifies which tunable parameter IPARMQ should
             return.
             
             ISPEC=12: (INMIN)  Matrices of order nmin or less
             are sent directly to xLAHQR, the implicit
             double shift QR algorithm.  NMIN must be
             at least 11.
             
             ISPEC=13: (INWIN)  Size of the deflation window.
             This is best set greater than or equal to
             the number of simultaneous shifts NS.
             Larger matrices benefit from larger deflation
             windows.
             
             ISPEC=14: (INIBL) Determines when to stop nibbling and
             invest in an (expensive) multi-shift QR sweep.
             If the aggressive early deflation subroutine
             finds LD converged eigenvalues from an order
             NW deflation window and LD.GT.(NW*NIBBLE)/100,
             then the next QR sweep is skipped and early
             deflation is applied immediately to the
             remaining active diagonal block.  Setting
             IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
             multi-shift QR sweep whenever early deflation
             finds a converged eigenvalue.  Setting
             IPARMQ(ISPEC=14) greater than or equal to 100
             prevents TTQRE from skipping a multi-shift
             QR sweep.
             
             ISPEC=15: (NSHFTS) The number of simultaneous shifts in
             a multi-shift QR iteration.
             
             ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
             following meanings.
             0:  During the multi-shift QR sweep,
             xLAQR5 does not accumulate reflections and
             does not use matrix-matrix multiply to
             update the far-from-diagonal matrix
             entries.
             1:  During the multi-shift QR sweep,
             xLAQR5 and/or xLAQRaccumulates reflections and uses
             matrix-matrix multiply to update the
             far-from-diagonal matrix entries.
             2:  During the multi-shift QR sweep.
             xLAQR5 accumulates reflections and takes
             advantage of 2-by-2 block structure during
             matrix-matrix multiplies.
             (If xTRMM is slower than xGEMM, then
             IPARMQ(ISPEC=16)=1 may be more efficient than
             IPARMQ(ISPEC=16)=2 despite the greater level of
             arithmetic work implied by the latter choice.)
            </param>
             <param name="NAME">
             (input) character string
             Name of the calling subroutine
            </param>
             <param name="OPTS">
             (input) character string
             This is a concatenation of the string arguments to
             TTQRE.
            </param>
             <param name="N">
             (input) integer scalar
             N is the order of the Hessenberg matrix H.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that H is already upper triangular
             in rows and columns 1:ILO-1 and IHI+1:N.
            </param>
             <param name="LWORK">
             (input) integer scalar
             The amount of workspace available.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTBSV">
             <summary>
             Purpose
             =======
             
             DTBSV  solves one of the systems of equations
             
             A*x = b,   or   A'*x = b,
             
             where b and x are n element vectors and A is an n by n unit, or
             non-unit, upper or lower triangular band matrix, with ( k + 1 )
             diagonals.
             
             No test for singularity or near-singularity is included in this
             routine. Such tests must be performed before calling this routine.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTBSV.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DTBSV  solves one of the systems of equations
             
             A*x = b,   or   A'*x = b,
             
             where b and x are n element vectors and A is an n by n unit, or
             non-unit, upper or lower triangular band matrix, with ( k + 1 )
             diagonals.
             
             No test for singularity or near-singularity is included in this
             routine. Such tests must be performed before calling this routine.
             
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
            </param>
             <param name="TRANS">
             - CHARACTER*1.
             On entry, TRANS specifies the equations to be solved as
             follows:
             
             TRANS = 'N' or 'n'   A*x = b.
             
             TRANS = 'T' or 't'   A'*x = b.
             
             TRANS = 'C' or 'c'   A'*x = b.
             
             Unchanged on exit.
            </param>
             <param name="DIAG">
             - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="K">
             - INTEGER.
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
             
             DO 20, J = 1, N
             M = K + 1 - J
             DO 10, I = MAX( 1, J - K ), J
             A( M + I, J ) = matrix( I, J )
             10    CONTINUE
             20 CONTINUE
             
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
             
             DO 20, J = 1, N
             M = 1 - J
             DO 10, I = J, MIN( N, J + K )
             A( M + I, J ) = matrix( I, J )
             10    CONTINUE
             20 CONTINUE
             
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYTRD">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSYTRD reduces a real symmetric matrix A to real symmetric
             tridiagonal form T by an orthogonal similarity transformation:
             Q**T * A * Q = T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYTRD.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSYTRD reduces a real symmetric matrix A to real symmetric
             tridiagonal form T by an orthogonal similarity transformation:
             Q**T * A * Q = T.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the symmetric matrix A.  If UPLO = 'U', the leading
             N-by-N upper triangular part of A contains the upper
             triangular part of the matrix A, and the strictly lower
             triangular part of A is not referenced.  If UPLO = 'L', the
             leading N-by-N lower triangular part of A contains the lower
             triangular part of the matrix A, and the strictly upper
             triangular part of A is not referenced.
             On exit, if UPLO = 'U', the diagonal and first superdiagonal
             of A are overwritten by the corresponding elements of the
             tridiagonal matrix T, and the elements above the first
             superdiagonal, with the array TAU, represent the orthogonal
             matrix Q as a product of elementary reflectors; if UPLO
             = 'L', the diagonal and first subdiagonal of A are over-
             written by the corresponding elements of the tridiagonal
             matrix T, and the elements below the first subdiagonal, with
             the array TAU, represent the orthogonal matrix Q as a product
             of elementary reflectors. See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (N)
             The diagonal elements of the tridiagonal matrix T:
             D(i) = A(i,i).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The off-diagonal elements of the tridiagonal matrix T:
             E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. 1.
             For optimum performance LWORK .GE. N*NB, where NB is the
             optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSWAP">
             <summary>
             Purpose
             =======
             
             interchanges two vectors.
             uses unrolled loops for increments equal one.
             jack dongarra, linpack, 3/11/78.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSWAP.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             interchanges two vectors.
             uses unrolled loops for increments equal one.
             jack dongarra, linpack, 3/11/78.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMTR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMTR overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix of order nq, with nq = m if
             SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
             nq-1 elementary reflectors, as returned by DSYTRD:
             
             if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
             
             if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMTR.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMTR overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix of order nq, with nq = m if
             SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
             nq-1 elementary reflectors, as returned by DSYTRD:
             
             if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
             
             if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U': Upper triangle of A contains elementary reflectors
             from DSYTRD;
             = 'L': Lower triangle of A contains elementary reflectors
             from DSYTRD.
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L'
             (LDA,N) if SIDE = 'R'
             The vectors which define the elementary reflectors, as
             returned by DSYTRD.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             LDA .GE. max(1,M) if SIDE = 'L'; LDA .GE. max(1,N) if SIDE = 'R'.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension
             (M-1) if SIDE = 'L'
             (N-1) if SIDE = 'R'
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DSYTRD.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAZQ3">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAZQ3 checks for deflation, computes a shift (TAU) and calls dqds.
             In case of failure it changes shifts, and tries again until output
             is positive.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAZQ3.Run(System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Double@,System.Double@,System.Double@,System.Double@,System.Int32@,System.Int32@,System.Int32@,System.Boolean,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAZQ3 checks for deflation, computes a shift (TAU) and calls dqds.
             In case of failure it changes shifts, and tries again until output
             is positive.
             
            </summary>
             <param name="I0">
             (input) INTEGER
             First index.
            </param>
             <param name="N0">
             (input) INTEGER
             Last index.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array.
            </param>
             <param name="PP">
             (input) INTEGER
             PP=0 for ping, PP=1 for pong.
            </param>
             <param name="DMIN">
             (output) DOUBLE PRECISION
             Minimum value of d.
            </param>
             <param name="SIGMA">
             (output) DOUBLE PRECISION
             Sum of shifts used in current segment.
            </param>
             <param name="DESIG">
             (input/output) DOUBLE PRECISION
             Lower order part of SIGMA
            </param>
             <param name="QMAX">
             (input) DOUBLE PRECISION
             Maximum value of q.
            </param>
             <param name="NFAIL">
             (output) INTEGER
             Number of times shift was too big.
            </param>
             <param name="ITER">
             (output) INTEGER
             Number of iterations.
            </param>
             <param name="NDIV">
             (output) INTEGER
             Number of divisions.
            </param>
             <param name="IEEE">
             (input) LOGICAL
             Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).
            </param>
             <param name="TTYPE">
             (input/output) INTEGER
             Shift type.  TTYPE is passed as an argument in order to save
             its value between calls to DLAZQ3
            </param>
             <param name="DMIN1">
             (input/output) REAL
            </param>
             <param name="DMIN2">
             (input/output) REAL
            </param>
             <param name="DN">
             (input/output) REAL
            </param>
             <param name="DN1">
             (input/output) REAL
            </param>
             <param name="DN2">
             (input/output) REAL
            </param>
             <param name="TAU">
             (input/output) REAL
             These are passed as arguments in order to save their values
             between calls to DLAZQ3
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASDQ">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASDQ computes the singular value decomposition (SVD) of a real
             (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
             E, accumulating the transformations if desired. Letting B denote
             the input bidiagonal matrix, the algorithm computes orthogonal
             matrices Q and P such that B = Q * S * P' (P' denotes the transpose
             of P). The singular values S are overwritten on D.
             
             The input matrix U  is changed to U  * Q  if desired.
             The input matrix VT is changed to P' * VT if desired.
             The input matrix C  is changed to Q' * C  if desired.
             
             See "Computing  Small Singular Values of Bidiagonal Matrices With
             Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
             LAPACK Working Note #3, for a detailed description of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASDQ.Run(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASDQ computes the singular value decomposition (SVD) of a real
             (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
             E, accumulating the transformations if desired. Letting B denote
             the input bidiagonal matrix, the algorithm computes orthogonal
             matrices Q and P such that B = Q * S * P' (P' denotes the transpose
             of P). The singular values S are overwritten on D.
             
             The input matrix U  is changed to U  * Q  if desired.
             The input matrix VT is changed to P' * VT if desired.
             The input matrix C  is changed to Q' * C  if desired.
             
             See "Computing  Small Singular Values of Bidiagonal Matrices With
             Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
             LAPACK Working Note #3, for a detailed description of the algorithm.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             On entry, UPLO specifies whether the input bidiagonal matrix
             is upper or lower bidiagonal, and wether it is square are
             not.
             UPLO = 'U' or 'u'   B is upper bidiagonal.
             UPLO = 'L' or 'l'   B is lower bidiagonal.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: then the input matrix is N-by-N.
             = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
             (N+1)-by-N if UPLU = 'L'.
             
             The bidiagonal matrix has
             N = NL + NR + 1 rows and
             M = N + SQRE .GE. N columns.
            </param>
             <param name="N">
             (input) INTEGER
             On entry, N specifies the number of rows and columns
             in the matrix. N must be at least 0.
            </param>
             <param name="NCVT">
             (input) INTEGER
             On entry, NCVT specifies the number of columns of
             the matrix VT. NCVT must be at least 0.
            </param>
             <param name="NRU">
             (input) INTEGER
             On entry, NRU specifies the number of rows of
             the matrix U. NRU must be at least 0.
            </param>
             <param name="NCC">
             (input) INTEGER
             On entry, NCC specifies the number of columns of
             the matrix C. NCC must be at least 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, D contains the diagonal entries of the
             bidiagonal matrix whose SVD is desired. On normal exit,
             D contains the singular values in ascending order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array.
             dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
             On entry, the entries of E contain the offdiagonal entries
             of the bidiagonal matrix whose SVD is desired. On normal
             exit, E will contain 0. If the algorithm does not converge,
             D and E will contain the diagonal and superdiagonal entries
             of a bidiagonal matrix orthogonally equivalent to the one
             given as input.
            </param>
             <param name="VT">
             (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
             On entry, contains a matrix which on exit has been
             premultiplied by P', dimension N-by-NCVT if SQRE = 0
             and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
            </param>
             <param name="LDVT">
             (input) INTEGER
             On entry, LDVT specifies the leading dimension of VT as
             declared in the calling (sub) program. LDVT must be at
             least 1. If NCVT is nonzero LDVT must also be at least N.
            </param>
             <param name="U">
             (input/output) DOUBLE PRECISION array, dimension (LDU, N)
             On entry, contains a  matrix which on exit has been
             postmultiplied by Q, dimension NRU-by-N if SQRE = 0
             and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
            </param>
             <param name="LDU">
             (input) INTEGER
             On entry, LDU  specifies the leading dimension of U as
             declared in the calling (sub) program. LDU must be at
             least max( 1, NRU ) .
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
             On entry, contains an N-by-NCC matrix which on exit
             has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
             and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
            </param>
             <param name="LDC">
             (input) INTEGER
             On entry, LDC  specifies the leading dimension of C as
             declared in the calling (sub) program. LDC must be at
             least 1. If NCC is nonzero, LDC must also be at least N.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (4*N)
             Workspace. Only referenced if one of NCVT, NRU, or NCC is
             nonzero, and if N is at least 2.
            </param>
             <param name="INFO">
             (output) INTEGER
             On exit, a value of 0 indicates a successful exit.
             If INFO .LT. 0, argument number -INFO is illegal.
             If INFO .GT. 0, the algorithm did not converge, and INFO
             specifies how many superdiagonals did not converge.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARFT">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARFT forms the triangular factor T of a real block reflector H
             of order n, which is defined as a product of k elementary reflectors.
             
             If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
             
             If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
             
             If STOREV = 'C', the vector which defines the elementary reflector
             H(i) is stored in the i-th column of the array V, and
             
             H  =  I - V * T * V'
             
             If STOREV = 'R', the vector which defines the elementary reflector
             H(i) is stored in the i-th row of the array V, and
             
             H  =  I - V' * T * V
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARFT.Run(System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARFT forms the triangular factor T of a real block reflector H
             of order n, which is defined as a product of k elementary reflectors.
             
             If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
             
             If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
             
             If STOREV = 'C', the vector which defines the elementary reflector
             H(i) is stored in the i-th column of the array V, and
             
             H  =  I - V * T * V'
             
             If STOREV = 'R', the vector which defines the elementary reflector
             H(i) is stored in the i-th row of the array V, and
             
             H  =  I - V' * T * V
             
            </summary>
             <param name="DIRECT">
             (input) CHARACTER*1
             Specifies the order in which the elementary reflectors are
             multiplied to form the block reflector:
             = 'F': H = H(1) H(2) . . . H(k) (Forward)
             = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </param>
             <param name="STOREV">
             (input) CHARACTER*1
             Specifies how the vectors which define the elementary
             reflectors are stored (see also Further Details):
             = 'C': columnwise
             = 'R': rowwise
            </param>
             <param name="N">
             (input) INTEGER
             The order of the block reflector H. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The order of the triangular factor T (= the number of
             elementary reflectors). K .GE. 1.
            </param>
             <param name="V">
             (input/output) DOUBLE PRECISION array, dimension
             (LDV,K) if STOREV = 'C'
             (LDV,N) if STOREV = 'R'
             The matrix V. See further details.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V.
             If STOREV = 'C', LDV .GE. max(1,N); if STOREV = 'R', LDV .GE. K.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i).
            </param>
             <param name="T">
             (output) DOUBLE PRECISION array, dimension (LDT,K)
             The k by k triangular factor T of the block reflector.
             If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
             lower triangular. The rest of the array is not used.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. K.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANST">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLANST  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real symmetric tridiagonal matrix A.
             
             Description
             ===========
             
             DLANST returns the value
             
             DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANST.Run(System.String,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32)">
             <summary>
             Purpose
             =======
             
             DLANST  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real symmetric tridiagonal matrix A.
             
             Description
             ===========
             
             DLANST returns the value
             
             DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies the value to be returned in DLANST as described
             above.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.  When N = 0, DLANST is
             set to zero.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension (N)
             The diagonal elements of A.
            </param>
             <param name="E">
             (input) DOUBLE PRECISION array, dimension (N-1)
             The (n-1) sub-diagonal or super-diagonal elements of A.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGETRS">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGETRS solves a system of linear equations
             A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU factorization computed
             by DGETRF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGETRS.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGETRS solves a system of linear equations
             A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU factorization computed
             by DGETRF.
             
            </summary>
             <param name="TRANS">
             (input) CHARACTER*1
             Specifies the form of the system of equations:
             = 'N':  A * X = B  (No transpose)
             = 'T':  A'* X = B  (Transpose)
             = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the factorization A = P*L*U
             as computed by DGETRF.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="IPIV">
             (input) INTEGER array, dimension (N)
             The pivot indices from DGETRF; for 1.LE.i.LE.N, row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEQR2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEQR2 computes a QR factorization of a real m by n matrix A:
             A = Q * R.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEQR2.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEQR2 computes a QR factorization of a real m by n matrix A:
             A = Q * R.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(m,n) by n upper trapezoidal matrix R (R is
             upper triangular if m .GE. n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of elementary reflectors (see Further Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEBRD">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEBRD reduces a general real M-by-N matrix A to upper or lower
             bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
             
             If m .GE. n, B is upper bidiagonal; if m .LT. n, B is lower bidiagonal.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEBRD.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEBRD reduces a general real M-by-N matrix A to upper or lower
             bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
             
             If m .GE. n, B is upper bidiagonal; if m .LT. n, B is lower bidiagonal.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows in the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns in the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N general matrix to be reduced.
             On exit,
             if m .GE. n, the diagonal and the first superdiagonal are
             overwritten with the upper bidiagonal matrix B; the
             elements below the diagonal, with the array TAUQ, represent
             the orthogonal matrix Q as a product of elementary
             reflectors, and the elements above the first superdiagonal,
             with the array TAUP, represent the orthogonal matrix P as
             a product of elementary reflectors;
             if m .LT. n, the diagonal and the first subdiagonal are
             overwritten with the lower bidiagonal matrix B; the
             elements below the first subdiagonal, with the array TAUQ,
             represent the orthogonal matrix Q as a product of
             elementary reflectors, and the elements above the diagonal,
             with the array TAUP, represent the orthogonal matrix P as
             a product of elementary reflectors.
             See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The diagonal elements of the bidiagonal matrix B:
             D(i) = A(i,i).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
             The off-diagonal elements of the bidiagonal matrix B:
             if m .GE. n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
             if m .LT. n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </param>
             <param name="TAUQ">
             (output) DOUBLE PRECISION array dimension (min(M,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Q. See Further Details.
            </param>
             <param name="TAUP">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix P. See Further Details.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The length of the array WORK.  LWORK .GE. max(1,M,N).
             For optimum performance LWORK .GE. (M+N)*NB, where NB
             is the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGBTF2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGBTF2 computes an LU factorization of a real m-by-n band matrix A
             using partial pivoting with row interchanges.
             
             This is the unblocked version of the algorithm, calling Level 2 BLAS.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGBTF2.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGBTF2 computes an LU factorization of a real m-by-n band matrix A
             using partial pivoting with row interchanges.
             
             This is the unblocked version of the algorithm, calling Level 2 BLAS.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="KL">
             (input) INTEGER
             The number of subdiagonals within the band of A.  KL .GE. 0.
            </param>
             <param name="KU">
             (input) INTEGER
             The number of superdiagonals within the band of A.  KU .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
             On entry, the matrix A in band storage, in rows KL+1 to
             2*KL+KU+1; rows 1 to KL of the array need not be set.
             The j-th column of A is stored in the j-th column of the
             array AB as follows:
             AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku).LE.i.LE.min(m,j+kl)
             
             On exit, details of the factorization: U is stored as an
             upper triangular band matrix with KL+KU superdiagonals in
             rows 1 to KL+KU+1, and the multipliers used during the
             factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
             See below for further details.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. 2*KL+KU+1.
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (min(M,N))
             The pivot indices; for 1 .LE. i .LE. min(M,N), row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: if INFO = +i, U(i,i) is exactly zero. The factorization
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DDISNA">
             <summary>
             -- LAPACK routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             September 30, 1994
             Purpose
             =======
             
             DDISNA computes the reciprocal condition numbers for the eigenvectors
             of a real symmetric or complex Hermitian matrix or for the left or
             right singular vectors of a general m-by-n matrix. The reciprocal
             condition number is the 'gap' between the corresponding eigenvalue or
             singular value and the nearest other one.
             
             The bound on the error, measured by angle in radians, in the I-th
             computed vector is given by
             
             DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
             
             where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
             to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
             the error bound.
             
             DDISNA may also be used to compute error bounds for eigenvectors of
             the generalized symmetric definite eigenproblem.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DDISNA.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DDISNA computes the reciprocal condition numbers for the eigenvectors
             of a real symmetric or complex Hermitian matrix or for the left or
             right singular vectors of a general m-by-n matrix. The reciprocal
             condition number is the 'gap' between the corresponding eigenvalue or
             singular value and the nearest other one.
             
             The bound on the error, measured by angle in radians, in the I-th
             computed vector is given by
             
             DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
             
             where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
             to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
             the error bound.
             
             DDISNA may also be used to compute error bounds for eigenvectors of
             the generalized symmetric definite eigenproblem.
             
            </summary>
             <param name="JOB">
             (input) CHARACTER*1
             Specifies for which problem the reciprocal condition numbers
             should be computed:
             = 'E':  the eigenvectors of a symmetric/Hermitian matrix;
             = 'L':  the left singular vectors of a general matrix;
             = 'R':  the right singular vectors of a general matrix.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             If JOB = 'L' or 'R', the number of columns of the matrix,
             in which case N .GE. 0. Ignored if JOB = 'E'.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension (M) if JOB = 'E'
             dimension (min(M,N)) if JOB = 'L' or 'R'
             The eigenvalues (if JOB = 'E') or singular values (if JOB =
             'L' or 'R') of the matrix, in either increasing or decreasing
             order. If singular values, they must be non-negative.
            </param>
             <param name="SEP">
             (output) DOUBLE PRECISION array, dimension (M) if JOB = 'E'
             dimension (min(M,N)) if JOB = 'L' or 'R'
             The reciprocal condition numbers of the vectors.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.Optimization.OptVariable">
            <summary>
            Represents a varaible that can be used in optimization classes.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptVariable._Name">
            <summary>
            The variable name.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptVariable._InitialGuess">
            <summary>
            The initial guess for this variable.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptVariable._Fixed">
            <summary>
            Value that indicates if the variable is fixed.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptVariable.#ctor">
            <summary>
            Initializes a new instance of the OptVariable class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptVariable.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the OptVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptVariable.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new instance of the OptVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptVariable.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptVariable.#ctor(System.String,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="P:DotNumerics.Optimization.OptVariable.Name">
            <summary>
            The variable name.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.OptVariable.InitialGuess">
            <summary>
            The initial guess for this variable.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.OptVariable.Fixed">
            <summary>
            Value that indicates if the variable is fixed.
            </summary>
        </member>
        <member name="T:DotNumerics.Optimization.OptSimplexBoundVariable">
            <summary>
            Represents a varaible that can be used in a simplex optimization classe.
            </summary>
        </member>
        <member name="T:DotNumerics.Optimization.OptBoundVariable">
            <summary>
            Represents a varaible that can be used in optimization classes with bounded constrains.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptBoundVariable._LowerBound">
            <summary>
            The lower bound.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptBoundVariable._UpperBound">
            <summary>
            The upper bound.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.String,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.String,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.Double,System.Boolean,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptBoundVariable.#ctor(System.String,System.Double,System.Boolean,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="P:DotNumerics.Optimization.OptBoundVariable.LowerBound">
            <summary>
            The lower bound.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.OptBoundVariable.UpperBound">
            <summary>
            The upper bound.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptSimplexBoundVariable._ScaleFactor">
            <summary>
            The scale factor controls the internal variable size. Variable=IntVar*ScaleFactor where IntVar is the internal variable. 
            Try to set the ScaleFactor of the same order that the variable, with this value the internal size will be near to 1 . 
            The default value is 1. This value modifies the changes and accuracy of this variable. 
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Boolean,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double,System.Boolean,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double,System.Double,System.Double)">
            <summary>
             Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.Double,System.Boolean,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexBoundVariable.#ctor(System.String,System.Double,System.Boolean,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexBoundVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
        </member>
        <member name="P:DotNumerics.Optimization.OptSimplexBoundVariable.ScaleFactor">
            <summary>
            The scale factor controls the internal variable size. Variable=IntVar*ScaleFactor where IntVar is the internal variable. 
            Try to set the ScaleFactor of the same order that the variable, with this value the internal size will be near to 1 . 
            The default value is 1. This value modifies the changes and accuracy of this variable. 
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.MAINLB.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double@,System.Double[]@,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,DotNumerics.Optimization.LBFGSB.BFGSTask@,System.Int32,DotNumerics.Optimization.LBFGSB.BFGSTask@,System.Boolean[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32)">
             <param name="N">
             is an integer variable.
             On entry n is the number of variables.
             On exit n is unchanged.
            </param>
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric
             corrections allowed in the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="X">
             is a double precision array of dimension n.
             On entry x is an approximation to the solution.
             On exit x is the current approximation.
            </param>
             <param name="L">
             is a double precision array of dimension n.
             On entry l is the lower bound of x.
             On exit l is unchanged.
            </param>
             <param name="U">
             is a double precision array of dimension n.
             On entry u is the upper bound of x.
             On exit u is unchanged.
            </param>
             <param name="NBD">
             is an integer array of dimension n.
             On entry nbd represents the type of bounds imposed on the
             variables, and must be specified as follows:
             nbd(i)=0 if x(i) is unbounded,
             1 if x(i) has only a lower bound,
             2 if x(i) has both lower and upper bounds,
             3 if x(i) has only an upper bound.
             On exit nbd is unchanged.
            </param>
             <param name="F">
             is a double precision variable.
             On first entry f is unspecified.
             On final exit f is the value of the function at x.
            </param>
             <param name="G">
             is a double precision array of dimension n.
             On first entry g is unspecified.
             On final exit g is the value of the gradient at x.
            </param>
             <param name="FACTR">
             is a double precision variable.
             On entry factr .GE. 0 is specified by the user.  The iteration
             will stop when
             
             (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} .LE. factr*epsmch
             
             where epsmch is the machine precision, which is automatically
             generated by the code.
             On exit factr is unchanged.
            </param>
             <param name="PGTOL">
             is a double precision variable.
             On entry pgtol .GE. 0 is specified by the user.  The iteration
             will stop when
             
             max{|proj g_i | i = 1, ..., n} .LE. pgtol
             
             where pg_i is the ith component of the projected gradient.
             On exit pgtol is unchanged.
            </param>
             <param name="WN">
             is a double precision working array of dimension 2m x 2m
             used to store the LEL^T factorization of the indefinite matrix
             K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
             [L_a -R_z           theta*S'AA'S ]
             
             where     E = [-I  0]
             [ 0  I]
            </param>
             <param name="SND">
             is a double precision working array of dimension 2m x 2m
             used to store the lower triangular part of
             N = [Y' ZZ'Y   L_a'+R_z']
             [L_a +R_z  S'AA'S   ]
            </param>
             <param name="Z">
             is used at different times to store the Cauchy point and
            </param>
             <param name="INDEX">
             is an integer working array of dimension n.
             In subroutine freev, index is used to store the free and fixed
             variables at the Generalized Cauchy Point (GCP).
            </param>
             <param name="IWHERE">
             is an integer working array of dimension n used to record
             the status of the vector x for GCP computation.
             iwhere(i)=0 or -3 if x(i) is free and has bounds,
             1       if x(i) is fixed at l(i), and l(i) .ne. u(i)
             2       if x(i) is fixed at u(i), and u(i) .ne. l(i)
             3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
             -1       if x(i) is always free, i.e., no bounds on it.
            </param>
             <param name="INDX2">
             is an integer working array of dimension n.
             Within subroutine cauchy, indx2 corresponds to the array iorder.
             In subroutine freev, a list of variables entering and leaving
             the free set is stored in indx2, and it is passed on to
             subroutine formk with this information.
            </param>
             <param name="TASK">
             is a working string of characters of length 60 indicating
             the current job when entering and leaving this subroutine.
            </param>
             <param name="IPRINT">
             is an INTEGER variable that must be set by the user.
             It controls the frequency and type of output generated:
             iprint.LT.0    no output is generated;
             iprint=0    print only one line at the last iteration;
             0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
             iprint=99   print details of every iteration except n-vectors;
             iprint=100  print also the changes of active set and final x;
             iprint.GT.100  print details of every iteration including x and g;
             When iprint .GT. 0, the file iterate.dat will be created to
             summarize the iteration.
            </param>
             <param name="CSAVE">
             is a working string of characters of length 60.
            </param>
             <param name="LSAVE">
             is a logical working array of dimension 4.
            </param>
             <param name="ISAVE">
             is an integer working array of dimension 23.
            </param>
             <param name="DSAVE">
             is a double precision working array of dimension 29.
             
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.BMV.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric corrections
             used to define the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="SY">
             is a double precision array of dimension m x m.
             On entry sy specifies the matrix S'Y.
             On exit sy is unchanged.
            </param>
             <param name="WT">
             is a double precision array of dimension m x m.
             On entry wt specifies the upper triangular matrix J' which is 
             the Cholesky factor of (thetaS'S+LD^(-1)L').
             On exit wt is unchanged.
            </param>
             <param name="COL">
             is an integer variable.
             On entry col specifies the number of s-vectors (or y-vectors)
             stored in the compact L-BFGS formula.
             On exit col is unchanged.
            </param>
             <param name="V">
             is a double precision array of dimension 2col.
             On entry v specifies vector v.
             On exit v is unchanged.
            </param>
             <param name="P">
             is a double precision array of dimension 2col.
             On entry p is unspecified.
             On exit p is the product Mv.
            </param>
             <param name="INFO">
             is an integer variable.
             On entry info is unspecified.
             On exit info = 0       for normal return,
             = nonzero for abnormal return when the system
             to be solved by dtrsl is singular.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRSV">
             <summary>
             Purpose
             =======
             
             DTRSV  solves one of the systems of equations
             
             A*x = b,   or   A'*x = b,
             
             where b and x are n element vectors and A is an n by n unit, or
             non-unit, upper or lower triangular matrix.
             
             No test for singularity or near-singularity is included in this
             routine. Such tests must be performed before calling this routine.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRSV.Run(System.String,System.String,System.String,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DTRSV  solves one of the systems of equations
             
             A*x = b,   or   A'*x = b,
             
             where b and x are n element vectors and A is an n by n unit, or
             non-unit, upper or lower triangular matrix.
             
             No test for singularity or near-singularity is included in this
             routine. Such tests must be performed before calling this routine.
             
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
            </param>
             <param name="TRANS">
             - CHARACTER*1.
             On entry, TRANS specifies the equations to be solved as
             follows:
             
             TRANS = 'N' or 'n'   A*x = b.
             
             TRANS = 'T' or 't'   A'*x = b.
             
             TRANS = 'C' or 'c'   A'*x = b.
             
             Unchanged on exit.
            </param>
             <param name="DIAG">
             - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSBTRD">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSBTRD reduces a real symmetric band matrix A to symmetric
             tridiagonal form T by an orthogonal similarity transformation:
             Q**T * A * Q = T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSBTRD.Run(System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSBTRD reduces a real symmetric band matrix A to symmetric
             tridiagonal form T by an orthogonal similarity transformation:
             Q**T * A * Q = T.
             
            </summary>
             <param name="VECT">
             (input) CHARACTER*1
             = 'N':  do not form Q;
             = 'V':  form Q;
             = 'U':  update a matrix X, by forming X*Q.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="KD">
             (input) INTEGER
             The number of superdiagonals of the matrix A if UPLO = 'U',
             or the number of subdiagonals if UPLO = 'L'.  KD .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
             On entry, the upper or lower triangle of the symmetric band
             matrix A, stored in the first KD+1 rows of the array.  The
             j-th column of A is stored in the j-th column of the array AB
             as follows:
             if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd).LE.i.LE.j;
             if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j.LE.i.LE.min(n,j+kd).
             On exit, the diagonal elements of AB are overwritten by the
             diagonal elements of the tridiagonal matrix T; if KD .GT. 0, the
             elements on the first superdiagonal (if UPLO = 'U') or the
             first subdiagonal (if UPLO = 'L') are overwritten by the
             off-diagonal elements of T; the rest of AB is overwritten by
             values generated during the reduction.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. KD+1.
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (N)
             The diagonal elements of the tridiagonal matrix T.
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The off-diagonal elements of the tridiagonal matrix T:
             E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             On entry, if VECT = 'U', then Q must contain an N-by-N
             matrix X; if VECT = 'N' or 'V', then Q need not be set.
             
             On exit:
             if VECT = 'V', Q contains the N-by-N orthogonal matrix Q;
             if VECT = 'U', Q contains the product X*Q;
             if VECT = 'N', the array Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.
             LDQ .GE. 1, and LDQ .GE. N if VECT = 'V' or 'U'.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARFB">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARFB applies a real block reflector H or its transpose H' to a
             real m by n matrix C, from either the left or the right.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARFB.Run(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARFB applies a real block reflector H or its transpose H' to a
             real m by n matrix C, from either the left or the right.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply H or H' from the Left
             = 'R': apply H or H' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply H (No transpose)
             = 'T': apply H' (Transpose)
            </param>
             <param name="DIRECT">
             (input) CHARACTER*1
             Indicates how H is formed from a product of elementary
             reflectors
             = 'F': H = H(1) H(2) . . . H(k) (Forward)
             = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </param>
             <param name="STOREV">
             (input) CHARACTER*1
             Indicates how the vectors which define the elementary
             reflectors are stored:
             = 'C': Columnwise
             = 'R': Rowwise
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C.
            </param>
             <param name="K">
             (input) INTEGER
             The order of the matrix T (= the number of elementary
             reflectors whose product defines the block reflector).
            </param>
             <param name="V">
             (input) DOUBLE PRECISION array, dimension
             (LDV,K) if STOREV = 'C'
             (LDV,M) if STOREV = 'R' and SIDE = 'L'
             (LDV,N) if STOREV = 'R' and SIDE = 'R'
             The matrix V. See further details.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V.
             If STOREV = 'C' and SIDE = 'L', LDV .GE. max(1,M);
             if STOREV = 'C' and SIDE = 'R', LDV .GE. max(1,N);
             if STOREV = 'R', LDV .GE. K.
            </param>
             <param name="T">
             (input) DOUBLE PRECISION array, dimension (LDT,K)
             The triangular k by k matrix T in the representation of the
             block reflector.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. K.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the m by n matrix C.
             On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDA .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
            </param>
             <param name="LDWORK">
             (input) INTEGER
             The leading dimension of the array WORK.
             If SIDE = 'L', LDWORK .GE. max(1,N);
             if SIDE = 'R', LDWORK .GE. max(1,M).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANV2">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
             matrix in standard form:
             
             [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
             [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
             
             where either
             1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
             2) AA = DD and BB*CC .LT. 0, so that AA + or - sqrt(BB*CC) are complex
             conjugate eigenvalues.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANV2.Run(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
             matrix in standard form:
             
             [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
             [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
             
             where either
             1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
             2) AA = DD and BB*CC .LT. 0, so that AA + or - sqrt(BB*CC) are complex
             conjugate eigenvalues.
             
            </summary>
             <param name="A">
             (input/output) DOUBLE PRECISION
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION
             On entry, the elements of the input matrix.
             On exit, they are overwritten by the elements of the
             standardised Schur form.
            </param>
             <param name="RT1R">
             (output) DOUBLE PRECISION
            </param>
             <param name="RT1I">
             (output) DOUBLE PRECISION
            </param>
             <param name="RT2R">
             (output) DOUBLE PRECISION
            </param>
             <param name="RT2I">
             (output) DOUBLE PRECISION
             The real and imaginary parts of the eigenvalues. If the
             eigenvalues are a complex conjugate pair, RT1I .GT. 0.
            </param>
             <param name="CS">
             (output) DOUBLE PRECISION
            </param>
             <param name="SN">
             (output) DOUBLE PRECISION
             Parameters of the rotation matrix.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANSB">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLANSB  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the element of  largest absolute value  of an
             n by n symmetric band matrix A,  with k super-diagonals.
             
             Description
             ===========
             
             DLANSB returns the value
             
             DLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANSB.Run(System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLANSB  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the element of  largest absolute value  of an
             n by n symmetric band matrix A,  with k super-diagonals.
             
             Description
             ===========
             
             DLANSB returns the value
             
             DLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies the value to be returned in DLANSB as described
             above.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the upper or lower triangular part of the
             band matrix A is supplied.
             = 'U':  Upper triangular part is supplied
             = 'L':  Lower triangular part is supplied
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.  When N = 0, DLANSB is
             set to zero.
            </param>
             <param name="K">
             (input) INTEGER
             The number of super-diagonals or sub-diagonals of the
             band matrix A.  K .GE. 0.
            </param>
             <param name="AB">
             (input) DOUBLE PRECISION array, dimension (LDAB,N)
             The upper or lower triangle of the symmetric band matrix A,
             stored in the first K+1 rows of AB.  The j-th column of A is
             stored in the j-th column of the array AB as follows:
             if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k).LE.i.LE.j;
             if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j.LE.i.LE.min(n,j+k).
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. K+1.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
             where LWORK .GE. N when NORM = 'I' or '1' or 'O'; otherwise,
             WORK is not referenced.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLALSD">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLALSD uses the singular value decomposition of A to solve the least
             squares problem of finding X to minimize the Euclidean norm of each
             column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
             are N-by-NRHS. The solution X overwrites B.
             
             The singular values of A smaller than RCOND times the largest
             singular value are treated as zero in solving the least squares
             problem; in this case a minimum norm solution is returned.
             The actual singular values are returned in D in ascending order.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLALSD.Run(System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Int32@,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLALSD uses the singular value decomposition of A to solve the least
             squares problem of finding X to minimize the Euclidean norm of each
             column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
             are N-by-NRHS. The solution X overwrites B.
             
             The singular values of A smaller than RCOND times the largest
             singular value are treated as zero in solving the least squares
             problem; in this case a minimum norm solution is returned.
             The actual singular values are returned in D in ascending order.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U': D and E define an upper bidiagonal matrix.
             = 'L': D and E define a  lower bidiagonal matrix.
            </param>
             <param name="SMLSIZ">
             (input) INTEGER
             The maximum size of the subproblems at the bottom of the
             computation tree.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the  bidiagonal matrix.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of columns of B. NRHS must be at least 1.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry D contains the main diagonal of the bidiagonal
             matrix. On exit, if INFO = 0, D contains its singular values.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             Contains the super-diagonal entries of the bidiagonal matrix.
             On exit, E has been destroyed.
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On input, B contains the right hand sides of the least
             squares problem. On output, B contains the solution X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of B in the calling subprogram.
             LDB must be at least max(1,N).
            </param>
             <param name="RCOND">
             (input) DOUBLE PRECISION
             The singular values of A less than or equal to RCOND times
             the largest singular value are treated as zero in solving
             the least squares problem. If RCOND is negative,
             machine precision is used instead.
             For example, if diag(S)*X=B were the least squares problem,
             where diag(S) is a diagonal matrix of singular values, the
             solution would be X(i) = B(i) / S(i) if S(i) is greater than
             RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
             RCOND*max(S).
            </param>
             <param name="RANK">
             (output) INTEGER
             The number of singular values of A greater than RCOND times
             the largest singular value.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension at least
             (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),
             where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension at least
             (3*N*NLVL + 11*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  The algorithm failed to compute an singular value while
             working on the submatrix lying in rows and columns
             INFO/(N+1) through MOD(INFO,N+1).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGQRF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGQRF computes a generalized QR factorization of an N-by-M matrix A
             and an N-by-P matrix B:
             
             A = Q*R,        B = Q*T*Z,
             
             where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
             matrix, and R and T assume one of the forms:
             
             if N .GE. M,  R = ( R11 ) M  ,   or if N .LT. M,  R = ( R11  R12 ) N,
             (  0  ) N-M                         N   M-N
             M
             
             where R11 is upper triangular, and
             
             if N .LE. P,  T = ( 0  T12 ) N,   or if N .GT. P,  T = ( T11 ) N-P,
             P-N  N                           ( T21 ) P
             P
             
             where T12 or T21 is upper triangular.
             
             In particular, if B is square and nonsingular, the GQR factorization
             of A and B implicitly gives the QR factorization of inv(B)*A:
             
             inv(B)*A = Z'*(inv(T)*R)
             
             where inv(B) denotes the inverse of the matrix B, and Z' denotes the
             transpose of the matrix Z.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGQRF.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGQRF computes a generalized QR factorization of an N-by-M matrix A
             and an N-by-P matrix B:
             
             A = Q*R,        B = Q*T*Z,
             
             where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
             matrix, and R and T assume one of the forms:
             
             if N .GE. M,  R = ( R11 ) M  ,   or if N .LT. M,  R = ( R11  R12 ) N,
             (  0  ) N-M                         N   M-N
             M
             
             where R11 is upper triangular, and
             
             if N .LE. P,  T = ( 0  T12 ) N,   or if N .GT. P,  T = ( T11 ) N-P,
             P-N  N                           ( T21 ) P
             P
             
             where T12 or T21 is upper triangular.
             
             In particular, if B is square and nonsingular, the GQR factorization
             of A and B implicitly gives the QR factorization of inv(B)*A:
             
             inv(B)*A = Z'*(inv(T)*R)
             
             where inv(B) denotes the inverse of the matrix B, and Z' denotes the
             transpose of the matrix Z.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of rows of the matrices A and B. N .GE. 0.
            </param>
             <param name="M">
             (input) INTEGER
             The number of columns of the matrix A.  M .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of columns of the matrix B.  P .GE. 0.
            </param>
             <param name="A">
             = Q*R,        B = Q*T*Z,
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,N).
            </param>
             <param name="TAUA">
             (output) DOUBLE PRECISION array, dimension (min(N,M))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Q (see Further Details).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,P)
             On entry, the N-by-P matrix B.
             On exit, if N .LE. P, the upper triangle of the subarray
             B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
             if N .GT. P, the elements on and above the (N-P)-th subdiagonal
             contain the N-by-P upper trapezoidal matrix T; the remaining
             elements, with the array TAUB, represent the orthogonal
             matrix Z as a product of elementary reflectors (see Further
             Details).
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,N).
            </param>
             <param name="TAUB">
             (output) DOUBLE PRECISION array, dimension (min(N,P))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Z (see Further Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N,M,P).
             For optimum performance LWORK .GE. max(N,M,P)*max(NB1,NB2,NB3),
             where NB1 is the optimal blocksize for the QR factorization
             of an N-by-M matrix, NB2 is the optimal blocksize for the
             RQ factorization of an N-by-P matrix, and NB3 is the optimal
             blocksize for a call of DORMQR.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGER">
             <summary>
             Purpose
             =======
             
             DGER   performs the rank 1 operation
             
             A := alpha*x*y' + A,
             
             where alpha is a scalar, x is an m element vector, y is an n element
             vector and A is an m by n matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGER.Run(System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DGER   performs the rank 1 operation
             
             A := alpha*x*y' + A,
             
             where alpha is a scalar, x is an m element vector, y is an n element
             vector and A is an m by n matrix.
             
            </summary>
             <param name="M">
             - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </param>
             <param name="Y">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.
            </param>
             <param name="INCY">
             - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
            </param>
             <param name="A">
             := alpha*x*y' + A,
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGELS">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGELS solves overdetermined or underdetermined real linear systems
             involving an M-by-N matrix A, or its transpose, using a QR or LQ
             factorization of A.  It is assumed that A has full rank.
             
             The following options are provided:
             
             1. If TRANS = 'N' and m .GE. n:  find the least squares solution of
             an overdetermined system, i.e., solve the least squares problem
             minimize || B - A*X ||.
             
             2. If TRANS = 'N' and m .LT. n:  find the minimum norm solution of
             an underdetermined system A * X = B.
             
             3. If TRANS = 'T' and m .GE. n:  find the minimum norm solution of
             an undetermined system A**T * X = B.
             
             4. If TRANS = 'T' and m .LT. n:  find the least squares solution of
             an overdetermined system, i.e., solve the least squares problem
             minimize || B - A**T * X ||.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGELS.Run(System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGELS solves overdetermined or underdetermined real linear systems
             involving an M-by-N matrix A, or its transpose, using a QR or LQ
             factorization of A.  It is assumed that A has full rank.
             
             The following options are provided:
             
             1. If TRANS = 'N' and m .GE. n:  find the least squares solution of
             an overdetermined system, i.e., solve the least squares problem
             minimize || B - A*X ||.
             
             2. If TRANS = 'N' and m .LT. n:  find the minimum norm solution of
             an underdetermined system A * X = B.
             
             3. If TRANS = 'T' and m .GE. n:  find the minimum norm solution of
             an undetermined system A**T * X = B.
             
             4. If TRANS = 'T' and m .LT. n:  find the least squares solution of
             an overdetermined system, i.e., solve the least squares problem
             minimize || B - A**T * X ||.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
            </summary>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': the linear system involves A;
             = 'T': the linear system involves A**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of
             columns of the matrices B and X. NRHS .GE.0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit,
             if M .GE. N, A is overwritten by details of its QR
             factorization as returned by DGEQRF;
             if M .LT.  N, A is overwritten by details of its LQ
             factorization as returned by DGELQF.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the matrix B of right hand side vectors, stored
             columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
             if TRANS = 'T'.
             On exit, if INFO = 0, B is overwritten by the solution
             vectors, stored columnwise:
             if TRANS = 'N' and m .GE. n, rows 1 to n of B contain the least
             squares solution vectors; the residual sum of squares for the
             solution in each column is given by the sum of squares of
             elements N+1 to M in that column;
             if TRANS = 'N' and m .LT. n, rows 1 to N of B contain the
             minimum norm solution vectors;
             if TRANS = 'T' and m .GE. n, rows 1 to M of B contain the
             minimum norm solution vectors;
             if TRANS = 'T' and m .LT. n, rows 1 to M of B contain the
             least squares solution vectors; the residual sum of squares
             for the solution in each column is given by the sum of
             squares of elements M+1 to N in that column.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. MAX(1,M,N).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             LWORK .GE. max( 1, MN + max( MN, NRHS ) ).
             For optimal performance,
             LWORK .GE. max( 1, MN + max( MN, NRHS )*NB ).
             where MN = min(M,N) and NB is the optimum block size.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO =  i, the i-th diagonal element of the
             triangular factor of A is zero, so that A does not have
             full rank; the least squares solution could not be
             computed.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.TN.TN.Run(System.Int32@,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,DotNumerics.Optimization.TN.ISFUN)">
             <param name="IERROR">
             - (INTEGER) ERROR CODE
             ( 0 =.GT. NORMAL RETURN)
             ( 2 =.GT. MORE THAN MAXFUN EVALUATIONS)
             ( 3 =.GT. LINE SEARCH FAILED TO FIND
             (          LOWER POINT (MAY NOT BE SERIOUS)
             (-1 =.GT. ERROR IN INPUT PARAMETERS)
            </param>
             <param name="N">
             - (INTEGER) NUMBER OF VARIABLES
            </param>
             <param name="X">
             - (REAL*8) VECTOR OF LENGTH AT LEAST N; ON INPUT, AN INITIAL
             ESTIMATE OF THE SOLUTION; ON OUTPUT, THE COMPUTED SOLUTION.
            </param>
             <param name="F">
             - (REAL*8) ON INPUT, A ROUGH ESTIMATE OF THE VALUE OF THE
             OBJECTIVE FUNCTION AT THE SOLUTION; ON OUTPUT, THE VALUE
             OF THE OBJECTIVE FUNCTION AT THE SOLUTION
            </param>
             <param name="G">
             - (REAL*8) VECTOR OF LENGTH AT LEAST N; ON OUTPUT, THE FINAL
             VALUE OF THE GRADIENT
            </param>
             <param name="W">
             - (REAL*8) WORK VECTOR OF LENGTH AT LEAST 14*N
            </param>
             <param name="LW">
             - (INTEGER) THE DECLARED DIMENSION OF W
            </param>
             <param name="SFUN">
             - A USER-SPECIFIED SUBROUTINE THAT COMPUTES THE FUNCTION
             AND GRADIENT OF THE OBJECTIVE FUNCTION.  IT MUST HAVE
             THE CALLING SEQUENCE
             SUBROUTINE SFUN (N, X, F, G)
             INTEGER           N
             DOUBLE PRECISION  X(N), G(N), F
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.TN.TNBC.Run(System.Int32@,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,DotNumerics.Optimization.TN.ISFUN,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[]@,System.Int32)">
             <param name="IERROR">
             - (INTEGER) ERROR CODE
             ( 0 =.GT. NORMAL RETURN
             ( 2 =.GT. MORE THAN MAXFUN EVALUATIONS
             ( 3 =.GT. LINE SEARCH FAILED TO FIND LOWER
             (          POINT (MAY NOT BE SERIOUS)
             (-1 =.GT. ERROR IN INPUT PARAMETERS
            </param>
             <param name="N">
             - (INTEGER) NUMBER OF VARIABLES
            </param>
             <param name="X">
             - (REAL*8) VECTOR OF LENGTH AT LEAST N; ON INPUT, AN INITIAL
             ESTIMATE OF THE SOLUTION; ON OUTPUT, THE COMPUTED SOLUTION.
            </param>
             <param name="F">
             - (REAL*8) ON INPUT, A ROUGH ESTIMATE OF THE VALUE OF THE
             OBJECTIVE FUNCTION AT THE SOLUTION; ON OUTPUT, THE VALUE
             OF THE OBJECTIVE FUNCTION AT THE SOLUTION
            </param>
             <param name="G">
             - (REAL*8) VECTOR OF LENGTH AT LEAST N; ON OUTPUT, THE FINAL
             VALUE OF THE GRADIENT
            </param>
             <param name="W">
             - (REAL*8) WORK VECTOR OF LENGTH AT LEAST 14*N
            </param>
             <param name="LW">
             - (INTEGER) THE DECLARED DIMENSION OF W
            </param>
             <param name="SFUN">
             - A USER-SPECIFIED SUBROUTINE THAT COMPUTES THE FUNCTION
             AND GRADIENT OF THE OBJECTIVE FUNCTION.  IT MUST HAVE
             THE CALLING SEQUENCE
             SUBROUTINE SFUN (N, X, F, G)
             INTEGER           N
             DOUBLE PRECISION  X(N), G(N), F
            </param>
             <param name="IPIVOT">
             - (INTEGER) WORK VECTOR OF LENGTH AT LEAST N, USED
             TO RECORD WHICH VARIABLES ARE AT THEIR BOUNDS.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.TN.MODLNP.Run(System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32,System.Int32@,System.Boolean,System.Double,System.Double@,System.Double,System.Boolean,DotNumerics.Optimization.TN.ISFUN,System.Boolean,System.Int32[],System.Int32,System.Double,System.Double@,System.Double,System.Double)">
             <param name="MODET">
             - INTEGER WHICH CONTROLS AMOUNT OF OUTPUT
            </param>
             <param name="ZSOL">
             - COMPUTED SEARCH DIRECTION
            </param>
             <param name="R">
             - RESIDUAL
            </param>
             <param name="G">
             - CURRENT GRADIENT
            </param>
             <param name="NITER">
             - NONLINEAR ITERATION #
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.TN.GTIMS.Run(System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,DotNumerics.Optimization.TN.ISFUN,System.Boolean@,System.Double@,System.Double,System.Double)">
             <param name="V">
             AND STORES THE RESULT IN THE VECTOR GV (FINITE-DIFFERENCE VERSION)
            </param>
        </member>
        <member name="T:DotNumerics.Optimization.OptMultivariateFunction">
            <summary>
            Evaluates the function to be minimized.
            </summary>
            <param name="X">Vector of length N at which point the function is evaluated, where N id the dimension of the problem.</param>
            <returns>The computed function value at the point X.</returns>
        </member>
        <member name="T:DotNumerics.Optimization.OptMultivariateGradient">
            <summary>
            Evaluates the gradient of the function to be minimized.
            </summary>
            <param name="X">Vector of length N at which point the function is evaluated, where N id the dimension of the problem.</param>
            <returns>The gradient of the function to be minimized.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.DNRM2.Run(System.Int32,System.Double[],System.Int32,System.Int32)">
             <param name="N">
             is a positive integer input variable.
            </param>
             <param name="X">
             is an input array of length n.
            </param>
             <param name="INCX">
             is a positive integer variable that specifies the 
             stride of the vector.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.ILAENV">
             <summary>
             -- LAPACK auxiliary routine (version 3.1.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             January 2007
             Purpose
             =======
             
             ILAENV is called from the LAPACK routines to choose problem-dependent
             parameters for the local environment.  See ISPEC for a description of
             the parameters.
             
             ILAENV returns an INTEGER
             if ILAENV .GE. 0: ILAENV returns the value of the parameter specified by ISPEC
             if ILAENV .LT. 0:  if ILAENV = -k, the k-th argument had an illegal value.
             
             This version provides a set of parameters which should give good,
             but not optimal, performance on many of the currently available
             computers.  Users are encouraged to modify this subroutine to set
             the tuning parameters for their particular machine using the option
             and problem size information in the arguments.
             
             This routine will not function correctly if it is converted to all
             lower case.  Converting it to all upper case is allowed.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.ILAENV.Run(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             ILAENV is called from the LAPACK routines to choose problem-dependent
             parameters for the local environment.  See ISPEC for a description of
             the parameters.
             
             ILAENV returns an INTEGER
             if ILAENV .GE. 0: ILAENV returns the value of the parameter specified by ISPEC
             if ILAENV .LT. 0:  if ILAENV = -k, the k-th argument had an illegal value.
             
             This version provides a set of parameters which should give good,
             but not optimal, performance on many of the currently available
             computers.  Users are encouraged to modify this subroutine to set
             the tuning parameters for their particular machine using the option
             and problem size information in the arguments.
             
             This routine will not function correctly if it is converted to all
             lower case.  Converting it to all upper case is allowed.
             
            </summary>
             <param name="ISPEC">
             (input) INTEGER
             Specifies the parameter to be returned as the value of
             ILAENV.
             = 1: the optimal blocksize; if this value is 1, an unblocked
             algorithm will give the best performance.
             = 2: the minimum block size for which the block routine
             should be used; if the usable block size is less than
             this value, an unblocked routine should be used.
             = 3: the crossover point (in a block routine, for N less
             than this value, an unblocked routine should be used)
             = 4: the number of shifts, used in the nonsymmetric
             eigenvalue routines (DEPRECATED)
             = 5: the minimum column dimension for blocking to be used;
             rectangular blocks must have dimension at least k by m,
             where k is given by ILAENV(2,...) and m by ILAENV(5,...)
             = 6: the crossover point for the SVD (when reducing an m by n
             matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
             this value, a QR factorization is used first to reduce
             the matrix to a triangular form.)
             = 7: the number of processors
             = 8: the crossover point for the multishift QR method
             for nonsymmetric eigenvalue problems (DEPRECATED)
             = 9: maximum size of the subproblems at the bottom of the
             computation tree in the divide-and-conquer algorithm
             (used by xGELSD and xGESDD)
             =10: ieee NaN arithmetic can be trusted not to trap
             =11: infinity arithmetic can be trusted not to trap
             12 .LE. ISPEC .LE. 16:
             xHSEQR or one of its subroutines,
             see IPARMQ for detailed explanation
            </param>
             <param name="NAME">
             (input) CHARACTER*(*)
             The name of the calling subroutine, in either upper case or
             lower case.
            </param>
             <param name="OPTS">
             (input) CHARACTER*(*)
             The character options to the subroutine NAME, concatenated
             into a single character string.  For example, UPLO = 'U',
             TRANS = 'T', and DIAG = 'N' for a triangular routine would
             be specified as OPTS = 'UTN'.
            </param>
             <param name="N1">
             (input) INTEGER
            </param>
             <param name="N2">
             (input) INTEGER
            </param>
             <param name="N3">
             (input) INTEGER
            </param>
             <param name="N4">
             (input) INTEGER
             Problem dimensions for the subroutine NAME; these may not all
             be required.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYTD2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
             form T by an orthogonal similarity transformation: Q' * A * Q = T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYTD2.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
             form T by an orthogonal similarity transformation: Q' * A * Q = T.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the upper or lower triangular part of the
             symmetric matrix A is stored:
             = 'U':  Upper triangular
             = 'L':  Lower triangular
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the symmetric matrix A.  If UPLO = 'U', the leading
             n-by-n upper triangular part of A contains the upper
             triangular part of the matrix A, and the strictly lower
             triangular part of A is not referenced.  If UPLO = 'L', the
             leading n-by-n lower triangular part of A contains the lower
             triangular part of the matrix A, and the strictly upper
             triangular part of A is not referenced.
             On exit, if UPLO = 'U', the diagonal and first superdiagonal
             of A are overwritten by the corresponding elements of the
             tridiagonal matrix T, and the elements above the first
             superdiagonal, with the array TAU, represent the orthogonal
             matrix Q as a product of elementary reflectors; if UPLO
             = 'L', the diagonal and first subdiagonal of A are over-
             written by the corresponding elements of the tridiagonal
             matrix T, and the elements below the first subdiagonal, with
             the array TAU, represent the orthogonal matrix Q as a product
             of elementary reflectors. See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (N)
             The diagonal elements of the tridiagonal matrix T:
             D(i) = A(i,i).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The off-diagonal elements of the tridiagonal matrix T:
             E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYEVD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
             real symmetric matrix A. If eigenvectors are desired, it uses a
             divide and conquer algorithm.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
             Because of large use of BLAS of level 3, DSYEVD needs N**2 more
             workspace than DSYEVX.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYEVD.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
             real symmetric matrix A. If eigenvectors are desired, it uses a
             divide and conquer algorithm.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
             Because of large use of BLAS of level 3, DSYEVD needs N**2 more
             workspace than DSYEVX.
             
            </summary>
             <param name="JOBZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only;
             = 'V':  Compute eigenvalues and eigenvectors.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA, N)
             On entry, the symmetric matrix A.  If UPLO = 'U', the
             leading N-by-N upper triangular part of A contains the
             upper triangular part of the matrix A.  If UPLO = 'L',
             the leading N-by-N lower triangular part of A contains
             the lower triangular part of the matrix A.
             On exit, if JOBZ = 'V', then if INFO = 0, A contains the
             orthonormal eigenvectors of the matrix A.
             If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
             or the upper triangle (if UPLO='U') of A, including the
             diagonal, is destroyed.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             If INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array,
             dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If N .LE. 1,               LWORK must be at least 1.
             If JOBZ = 'N' and N .GT. 1, LWORK must be at least 2*N+1.
             If JOBZ = 'V' and N .GT. 1, LWORK must be at least
             1 + 6*N + 2*N**2.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal sizes of the WORK and IWORK
             arrays, returns these values as the first entries of the WORK
             and IWORK arrays, and no error message related to LWORK or
             LIWORK is issued by XERBLA.
            </param>
             <param name="IWORK">
             (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
             On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </param>
             <param name="LIWORK">
             (input) INTEGER
             The dimension of the array IWORK.
             If N .LE. 1,                LIWORK must be at least 1.
             If JOBZ  = 'N' and N .GT. 1, LIWORK must be at least 1.
             If JOBZ  = 'V' and N .GT. 1, LIWORK must be at least 3 + 5*N.
             
             If LIWORK = -1, then a workspace query is assumed; the
             routine only calculates the optimal sizes of the WORK and
             IWORK arrays, returns these values as the first entries of
             the WORK and IWORK arrays, and no error message related to
             LWORK or LIWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
             to converge; i off-diagonal elements of an intermediate
             tridiagonal form did not converge to zero;
             if INFO = i and JOBZ = 'V', then the algorithm failed
             to compute an eigenvalue while working on the submatrix
             lying in rows and columns INFO/(N+1) through
             mod(INFO,N+1).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSBEV">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSBEV computes all the eigenvalues and, optionally, eigenvectors of
             a real symmetric band matrix A.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSBEV.Run(System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSBEV computes all the eigenvalues and, optionally, eigenvectors of
             a real symmetric band matrix A.
             
            </summary>
             <param name="JOBZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only;
             = 'V':  Compute eigenvalues and eigenvectors.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="KD">
             (input) INTEGER
             The number of superdiagonals of the matrix A if UPLO = 'U',
             or the number of subdiagonals if UPLO = 'L'.  KD .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
             On entry, the upper or lower triangle of the symmetric band
             matrix A, stored in the first KD+1 rows of the array.  The
             j-th column of A is stored in the j-th column of the array AB
             as follows:
             if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd).LE.i.LE.j;
             if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j.LE.i.LE.min(n,j+kd).
             
             On exit, AB is overwritten by values generated during the
             reduction to tridiagonal form.  If UPLO = 'U', the first
             superdiagonal and the diagonal of the tridiagonal matrix T
             are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
             the diagonal and first subdiagonal of T are returned in the
             first two rows of AB.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. KD + 1.
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             If INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension (LDZ, N)
             If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
             eigenvectors of the matrix A, with the i-th column of Z
             holding the eigenvector associated with W(i).
             If JOBZ = 'N', then Z is not referenced.
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  LDZ .GE. 1, and if
             JOBZ = 'V', LDZ .GE. max(1,N).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, the algorithm failed to converge; i
             off-diagonal elements of an intermediate tridiagonal
             form did not converge to zero.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORM2R">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORM2R overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORM2R.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORM2R overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q or Q' from the Left
             = 'R': apply Q or Q' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply Q  (No transpose)
             = 'T': apply Q' (Transpose)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,K)
             The i-th column must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGEQRF in the first k columns of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             If SIDE = 'L', LDA .GE. max(1,M);
             if SIDE = 'R', LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQRF.
            </param>
             <param name="C">
             * Q  if SIDE = 'R' and TRANS = 'N', or
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L',
             (M) if SIDE = 'R'
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAPY2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
             overflow.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAPY2.Run(System.Double,System.Double)">
             <summary>
             Purpose
             =======
             
             DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
             overflow.
             
            </summary>
             <param name="X">
             (input) DOUBLE PRECISION
            </param>
             <param name="Y">
             (input) DOUBLE PRECISION
             X and Y specify the values x and y.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLALS0">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLALS0 applies back the multiplying factors of either the left or the
             right singular vector matrix of a diagonal matrix appended by a row
             to the right hand side matrix B in solving the least squares problem
             using the divide-and-conquer SVD approach.
             
             For the left singular vector matrix, three types of orthogonal
             matrices are involved:
             
             (1L) Givens rotations: the number of such rotations is GIVPTR; the
             pairs of columns/rows they were applied to are stored in GIVCOL;
             and the C- and S-values of these rotations are stored in GIVNUM.
             
             (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
             row, and for J=2:N, PERM(J)-th row of B is to be moved to the
             J-th row.
             
             (3L) The left singular vector matrix of the remaining matrix.
             
             For the right singular vector matrix, four types of orthogonal
             matrices are involved:
             
             (1R) The right singular vector matrix of the remaining matrix.
             
             (2R) If SQRE = 1, one extra Givens rotation to generate the right
             null space.
             
             (3R) The inverse transformation of (2L).
             
             (4R) The inverse transformation of (1L).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLALS0.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLALS0 applies back the multiplying factors of either the left or the
             right singular vector matrix of a diagonal matrix appended by a row
             to the right hand side matrix B in solving the least squares problem
             using the divide-and-conquer SVD approach.
             
             For the left singular vector matrix, three types of orthogonal
             matrices are involved:
             
             (1L) Givens rotations: the number of such rotations is GIVPTR; the
             pairs of columns/rows they were applied to are stored in GIVCOL;
             and the C- and S-values of these rotations are stored in GIVNUM.
             
             (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
             row, and for J=2:N, PERM(J)-th row of B is to be moved to the
             J-th row.
             
             (3L) The left singular vector matrix of the remaining matrix.
             
             For the right singular vector matrix, four types of orthogonal
             matrices are involved:
             
             (1R) The right singular vector matrix of the remaining matrix.
             
             (2R) If SQRE = 1, one extra Givens rotation to generate the right
             null space.
             
             (3R) The inverse transformation of (2L).
             
             (4R) The inverse transformation of (1L).
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether singular vectors are to be computed in
             factored form:
             = 0: Left singular vector matrix.
             = 1: Right singular vector matrix.
            </param>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block. NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block. NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has row dimension N = NL + NR + 1,
             and column dimension M = N + SQRE.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of columns of B and BX. NRHS must be at least 1.
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension ( LDB, NRHS )
             On input, B contains the right hand sides of the least
             squares problem in rows 1 through M. On output, B contains
             the solution X in rows 1 through N.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of B. LDB must be at least
             max(1,MAX( M, N ) ).
            </param>
             <param name="BX">
             (workspace) DOUBLE PRECISION array, dimension ( LDBX, NRHS )
            </param>
             <param name="LDBX">
             (input) INTEGER
             The leading dimension of BX.
            </param>
             <param name="PERM">
             (input) INTEGER array, dimension ( N )
             The permutations (from deflation and sorting) applied
             to the two blocks.
            </param>
             <param name="GIVPTR">
             (input) INTEGER
             The number of Givens rotations which took place in this
             subproblem.
            </param>
             <param name="GIVCOL">
             (input) INTEGER array, dimension ( LDGCOL, 2 )
             Each pair of numbers indicates a pair of rows/columns
             involved in a Givens rotation.
            </param>
             <param name="LDGCOL">
             (input) INTEGER
             The leading dimension of GIVCOL, must be at least N.
            </param>
             <param name="GIVNUM">
             (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
             Each number indicates the C or S value used in the
             corresponding Givens rotation.
            </param>
             <param name="LDGNUM">
             (input) INTEGER
             The leading dimension of arrays DIFR, POLES and
             GIVNUM, must be at least K.
            </param>
             <param name="POLES">
             (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
             On entry, POLES(1:K, 1) contains the new singular
             values obtained from solving the secular equation, and
             POLES(1:K, 2) is an array containing the poles in the secular
             equation.
            </param>
             <param name="DIFL">
             (input) DOUBLE PRECISION array, dimension ( K ).
             On entry, DIFL(I) is the distance between I-th updated
             (undeflated) singular value and the I-th (undeflated) old
             singular value.
            </param>
             <param name="DIFR">
             (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 ).
             On entry, DIFR(I, 1) contains the distances between I-th
             updated (undeflated) singular value and the I+1-th
             (undeflated) old singular value. And DIFR(I, 2) is the
             normalizing factor for the I-th right singular vector.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( K )
             Contain the components of the deflation-adjusted updating row
             vector.
            </param>
             <param name="K">
             (input) INTEGER
             Contains the dimension of the non-deflated matrix,
             This is the order of the related secular equation. 1 .LE. K .LE.N.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION
             C contains garbage if SQRE =0 and the C-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="S">
             (input) DOUBLE PRECISION
             S contains garbage if SQRE =0 and the S-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension ( K )
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED9">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED9 finds the roots of the secular equation, as defined by the
             values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
             appropriate calls to DLAED4 and then stores the new matrix of
             eigenvectors for use in calculating the next level of Z vectors.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED9.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED9 finds the roots of the secular equation, as defined by the
             values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
             appropriate calls to DLAED4 and then stores the new matrix of
             eigenvectors for use in calculating the next level of Z vectors.
             
            </summary>
             <param name="K">
             (input) INTEGER
             The number of terms in the rational function to be solved by
             DLAED4.  K .GE. 0.
            </param>
             <param name="KSTART">
             (input) INTEGER
            </param>
             <param name="KSTOP">
             (input) INTEGER
             The updated eigenvalues Lambda(I), KSTART .LE. I .LE. KSTOP
             are to be computed.  1 .LE. KSTART .LE. KSTOP .LE. K.
            </param>
             <param name="N">
             (input) INTEGER
             The number of rows and columns in the Q matrix.
             N .GE. K (delation may result in N .GT. K).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (N)
             D(I) contains the updated eigenvalues
             for KSTART .LE. I .LE. KSTOP.
            </param>
             <param name="Q">
             (workspace) DOUBLE PRECISION array, dimension (LDQ,N)
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max( 1, N ).
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The value of the parameter in the rank one update equation.
             RHO .GE. 0 required.
            </param>
             <param name="DLAMDA">
             (input) DOUBLE PRECISION array, dimension (K)
             The first K elements of this array contain the old roots
             of the deflated updating problem.  These are the poles
             of the secular equation.
            </param>
             <param name="W">
             (input) DOUBLE PRECISION array, dimension (K)
             The first K elements of this array contain the components
             of the deflation-adjusted updating vector.
            </param>
             <param name="S">
             (output) DOUBLE PRECISION array, dimension (LDS, K)
             Will contain the eigenvectors of the repaired matrix which
             will be stored for subsequent Z vector calculation and
             multiplied by the previously accumulated eigenvectors
             to update the system.
            </param>
             <param name="LDS">
             (input) INTEGER
             The leading dimension of S.  LDS .GE. max( 1, K ).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an eigenvalue did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGETF2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGETF2 computes an LU factorization of a general m-by-n matrix A
             using partial pivoting with row interchanges.
             
             The factorization has the form
             A = P * L * U
             where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m .GT. n), and U is upper
             triangular (upper trapezoidal if m .LT. n).
             
             This is the right-looking Level 2 BLAS version of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGETF2.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGETF2 computes an LU factorization of a general m-by-n matrix A
             using partial pivoting with row interchanges.
             
             The factorization has the form
             A = P * L * U
             where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m .GT. n), and U is upper
             triangular (upper trapezoidal if m .LT. n).
             
             This is the right-looking Level 2 BLAS version of the algorithm.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n matrix to be factored.
             On exit, the factors L and U from the factorization
             A = P*L*U; the unit diagonal elements of L are not stored.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (min(M,N))
             The pivot indices; for 1 .LE. i .LE. min(M,N), row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -k, the k-th argument had an illegal value
             .GT. 0: if INFO = k, U(k,k) is exactly zero. The factorization
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGESDD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGESDD computes the singular value decomposition (SVD) of a real
             M-by-N matrix A, optionally computing the left and right singular
             vectors.  If singular vectors are desired, it uses a
             divide-and-conquer algorithm.
             
             The SVD is written
             
             A = U * SIGMA * transpose(V)
             
             where SIGMA is an M-by-N matrix which is zero except for its
             min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
             V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
             are the singular values of A; they are real and non-negative, and
             are returned in descending order.  The first min(m,n) columns of
             U and V are the left and right singular vectors of A.
             
             Note that the routine returns VT = V**T, not V.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGESDD.Run(System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGESDD computes the singular value decomposition (SVD) of a real
             M-by-N matrix A, optionally computing the left and right singular
             vectors.  If singular vectors are desired, it uses a
             divide-and-conquer algorithm.
             
             The SVD is written
             
             A = U * SIGMA * transpose(V)
             
             where SIGMA is an M-by-N matrix which is zero except for its
             min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
             V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
             are the singular values of A; they are real and non-negative, and
             are returned in descending order.  The first min(m,n) columns of
             U and V are the left and right singular vectors of A.
             
             Note that the routine returns VT = V**T, not V.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
             <param name="JOBZ">
             (input) CHARACTER*1
             Specifies options for computing all or part of the matrix U:
             = 'A':  all M columns of U and all N rows of V**T are
             returned in the arrays U and VT;
             = 'S':  the first min(M,N) columns of U and the first
             min(M,N) rows of V**T are returned in the arrays U
             and VT;
             = 'O':  If M .GE. N, the first N columns of U are overwritten
             on the array A and all rows of V**T are returned in
             the array VT;
             otherwise, all columns of U are returned in the
             array U and the first M rows of V**T are overwritten
             in the array A;
             = 'N':  no columns of U or rows of V**T are computed.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the input matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the input matrix A.  N .GE. 0.
            </param>
             <param name="A">
             = U * SIGMA * transpose(V)
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="S">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The singular values of A, sorted so that S(i) .GE. S(i+1).
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
             UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M .LT. N;
             UCOL = min(M,N) if JOBZ = 'S'.
             If JOBZ = 'A' or JOBZ = 'O' and M .LT. N, U contains the M-by-M
             orthogonal matrix U;
             if JOBZ = 'S', U contains the first min(M,N) columns of U
             (the left singular vectors, stored columnwise);
             if JOBZ = 'O' and M .GE. N, or JOBZ = 'N', U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. 1; if
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M .LT. N, LDU .GE. M.
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array, dimension (LDVT,N)
             If JOBZ = 'A' or JOBZ = 'O' and M .GE. N, VT contains the
             N-by-N orthogonal matrix V**T;
             if JOBZ = 'S', VT contains the first min(M,N) rows of
             V**T (the right singular vectors, stored rowwise);
             if JOBZ = 'O' and M .LT. N, or JOBZ = 'N', VT is not referenced.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. 1; if
             JOBZ = 'A' or JOBZ = 'O' and M .GE. N, LDVT .GE. N;
             if JOBZ = 'S', LDVT .GE. min(M,N).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. 1.
             If JOBZ = 'N',
             LWORK .GE. 3*min(M,N) + max(max(M,N),7*min(M,N)).
             If JOBZ = 'O',
             LWORK .GE. 3*min(M,N)*min(M,N) + 
             max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
             If JOBZ = 'S' or 'A'
             LWORK .GE. 3*min(M,N)*min(M,N) +
             max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
             For good performance, LWORK should generally be larger.
             If LWORK = -1 but other input arguments are legal, WORK(1)
             returns the optimal LWORK.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (8*min(M,N))
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  DBDSDC did not converge, updating process failed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEBD2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEBD2 reduces a real general m by n matrix A to upper or lower
             bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
             
             If m .GE. n, B is upper bidiagonal; if m .LT. n, B is lower bidiagonal.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEBD2.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEBD2 reduces a real general m by n matrix A to upper or lower
             bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
             
             If m .GE. n, B is upper bidiagonal; if m .LT. n, B is lower bidiagonal.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows in the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns in the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n general matrix to be reduced.
             On exit,
             if m .GE. n, the diagonal and the first superdiagonal are
             overwritten with the upper bidiagonal matrix B; the
             elements below the diagonal, with the array TAUQ, represent
             the orthogonal matrix Q as a product of elementary
             reflectors, and the elements above the first superdiagonal,
             with the array TAUP, represent the orthogonal matrix P as
             a product of elementary reflectors;
             if m .LT. n, the diagonal and the first subdiagonal are
             overwritten with the lower bidiagonal matrix B; the
             elements below the first subdiagonal, with the array TAUQ,
             represent the orthogonal matrix Q as a product of
             elementary reflectors, and the elements above the diagonal,
             with the array TAUP, represent the orthogonal matrix P as
             a product of elementary reflectors.
             See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The diagonal elements of the bidiagonal matrix B:
             D(i) = A(i,i).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
             The off-diagonal elements of the bidiagonal matrix B:
             if m .GE. n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
             if m .LT. n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </param>
             <param name="TAUQ">
             (output) DOUBLE PRECISION array dimension (min(M,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Q. See Further Details.
            </param>
             <param name="TAUP">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix P. See Further Details.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (max(M,N))
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit.
             .LT. 0: if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.CBABK2.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement.
            </param>
             <param name="N">
             is the order of the matrix.
            </param>
             <param name="LOW">
             and igh are integers determined by  cbal.
            </param>
             <param name="SCALE">
             contains information determining the permutations
             and scaling factors used by  cbal.
            </param>
             <param name="M">
             is the number of eigenvectors to be back transformed.
            </param>
             <param name="ZR">
             and zi contain the real and imaginary parts,
             respectively, of the eigenvectors to be
             back transformed in their first m columns.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.ComplexMatrix">
            <summary>
            Represents a Complex Matrix.
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.ComplexMatrix._Data">
            <summary>
            Los datos de la matriz, los datos se almacenan en un un array unidimensional,
            Los elementos se almacenan por columnas, esto para que sean compatible con los Arrays de Fortran
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.ComplexMatrix._RowCount">
            <summary>
            El numero de renglones
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.ComplexMatrix._ColumnCount">
            <summary>
            El numero de columnas
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the MatrixComplex class of the given size.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.#ctor(System.Int32,System.Int32,DotNumerics.Complex[])">
            <summary>
            Initializes a new instance of the MatrixComplex class of the given size using a array
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="Data">The data</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MatrixComplex class of the given size.
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.#ctor(System.Int32,DotNumerics.Complex[])">
            <summary>
            Initializes a new instance of the MatrixComplex class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="Data">The data</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.CheckMatrixDimensions(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>Check if size(this) == size(B) </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.CheckMatrixDimensions(DotNumerics.LinearAlgebra.Matrix)">
            <summary>Check if size(this) == size(B) </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.ElemntsMult(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Element-by-element multiplication: aij = aij*bij
            </summary>
            <param name="B">The B MatrixComplex</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.Add(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            In place addition A=A+B
            </summary>
            <param name="B">The B MatrixComplex</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.Multiply(System.Double)">
            <summary>
            In place scalar-matrix multiplication, A=s*A
            </summary>
            <param name="s">The scalar s.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.MultiplyC(DotNumerics.Complex)">
            <summary>
            In place scalar-matrix multiplication, A=c*A
            </summary>
            <param name="s">The scalar s.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.Subtract(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            In place matrix subtraction, A=A-B.
            </summary>
            <param name="B">The B MatrixComplex.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.UnaryMinus">
            <summary>
            In place unary minus -A.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.GetColumnVectors">
            <summary>
            Gets the column vectors of this matrix.
            </summary>
            <returns>The columns vectors.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.GetRowVectors">
            <summary>
            Gets the row vectors of this matrix.
            </summary>
            <returns>The row vectors.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.GetReal">
            <summary>
            Gets a matrix that contains the real part of this matrix.
            </summary>
            <returns>A matrix that contains the real part of this matrix. </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.GetImag">
            <summary>
            Gets a matrix that contains the imaginary part of this matrix.
            </summary>
            <returns>A matrix that contains the imaginary part of this matrix. </returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.SetReal(DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Sets the real part of the elements of this matrix equal to the elemnets of a real matrix.
            </summary>
            <param name="RM">A matrix that contains the values of the real part.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.SetImag(DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Sets the imaginary part of the elements of this matrix equal to the elemnets of a real matrix.
            </summary>
            <param name="IM">A matrix that contains the values of the imaginary part.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.MatrixToString">
            <summary>
            Returns the string of the  matrix.
            </summary>
            <returns>The string of the  matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.MatrixToString(System.String)">
            <summary>
            Returns the string of the  matrix.
            </summary>
            <param name="format">A numeric format string.</param>
            <returns>The string of the  matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.op_Multiply(DotNumerics.LinearAlgebra.ComplexMatrix,DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Matrix multiplication.
            </summary>
            <param name="A"> The left side matrix of the multiplication operator.</param>
            <param name="B">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the matrix multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.op_Multiply(DotNumerics.LinearAlgebra.BaseMatrix,DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Matrix multiplication.
            </summary>
            <param name="A"> The left side matrix of the multiplication operator.</param>
            <param name="B">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the matrix multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.op_Multiply(DotNumerics.Complex,DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>complex-Matrix multiplication.</summary>
            <param name="c"> The left side scalar of the multiplication operator.</param>
            <param name="B">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.op_Addition(DotNumerics.LinearAlgebra.ComplexMatrix,DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.op_Subtraction(DotNumerics.LinearAlgebra.ComplexMatrix,DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DotNumerics.LinearAlgebra.ComplexMatrix.CopyToArray" -->
        <member name="M:DotNumerics.LinearAlgebra.ComplexMatrix.CopyToJaggedArray">
            <summary>
            Copy all elements of this matrix to a jagged array.
            </summary>
            <returns>A jagged array.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexMatrix.Data">
            <summary>
            Los datos de la matriz
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexMatrix.RowCount">
            <summary>
            Returns the number of rows.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexMatrix.ColumnCount">
            <summary>
            Returns the number of columns.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexMatrix.IsSquare">
            <summary>
            Gets a value indicating if the matrix is square.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.ComplexMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of a element of the matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The matrix value at (row, column).</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.MatrixView">
            <summary>
            Displays and edit a matrix in a grid.
            </summary>
        </member>
        <member name="F:DotNumerics.LinearAlgebra.MatrixView.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.#ctor">
            <summary>
            Initializes a new instance of the MatrixView class.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.Matrix(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            Sets the matrix to show.
            </summary>
            <param name="matrix">A real matrix.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.Matrix(DotNumerics.LinearAlgebra.ComplexMatrix)">
            <summary>
            Sets the matrix to show.
            </summary>
            <param name="matrix">A complex matrix.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.RemoveMatrix">
            <summary>
            Remove the matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.MatrixView.RefreshMatrix">
            <summary>
            Refreshes the value of the matrix.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.MatrixView.ReadOnly">
            <summary>
            Gets or sets a value indicating whether the user can edit the cells of the control.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.MatrixView.FormatProvider">
            <summary>
            Gets or sets the object used to provide culture-specific formatting of System.Windows.Forms.DataGridView cell values.
            </summary>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.MatrixView.Format">
            <summary>
            Gets or sets the format string applied to the textual content of a cell.
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSBEVD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSBEVD computes all the eigenvalues and, optionally, eigenvectors of
             a real symmetric band matrix A. If eigenvectors are desired, it uses
             a divide and conquer algorithm.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSBEVD.Run(System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSBEVD computes all the eigenvalues and, optionally, eigenvectors of
             a real symmetric band matrix A. If eigenvectors are desired, it uses
             a divide and conquer algorithm.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
             <param name="JOBZ">
             (input) CHARACTER*1
             = 'N':  Compute eigenvalues only;
             = 'V':  Compute eigenvalues and eigenvectors.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  Upper triangle of A is stored;
             = 'L':  Lower triangle of A is stored.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="KD">
             (input) INTEGER
             The number of superdiagonals of the matrix A if UPLO = 'U',
             or the number of subdiagonals if UPLO = 'L'.  KD .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
             On entry, the upper or lower triangle of the symmetric band
             matrix A, stored in the first KD+1 rows of the array.  The
             j-th column of A is stored in the j-th column of the array AB
             as follows:
             if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd).LE.i.LE.j;
             if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j.LE.i.LE.min(n,j+kd).
             
             On exit, AB is overwritten by values generated during the
             reduction to tridiagonal form.  If UPLO = 'U', the first
             superdiagonal and the diagonal of the tridiagonal matrix T
             are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
             the diagonal and first subdiagonal of T are returned in the
             first two rows of AB.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. KD + 1.
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             If INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension (LDZ, N)
             If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
             eigenvectors of the matrix A, with the i-th column of Z
             holding the eigenvector associated with W(i).
             If JOBZ = 'N', then Z is not referenced.
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  LDZ .GE. 1, and if
             JOBZ = 'V', LDZ .GE. max(1,N).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array,
             dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             IF N .LE. 1,                LWORK must be at least 1.
             If JOBZ  = 'N' and N .GT. 2, LWORK must be at least 2*N.
             If JOBZ  = 'V' and N .GT. 2, LWORK must be at least
             ( 1 + 5*N + 2*N**2 ).
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal sizes of the WORK and IWORK
             arrays, returns these values as the first entries of the WORK
             and IWORK arrays, and no error message related to LWORK or
             LIWORK is issued by XERBLA.
            </param>
             <param name="IWORK">
             (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
             On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </param>
             <param name="LIWORK">
             (input) INTEGER
             The dimension of the array LIWORK.
             If JOBZ  = 'N' or N .LE. 1, LIWORK must be at least 1.
             If JOBZ  = 'V' and N .GT. 2, LIWORK must be at least 3 + 5*N.
             
             If LIWORK = -1, then a workspace query is assumed; the
             routine only calculates the optimal sizes of the WORK and
             IWORK arrays, returns these values as the first entries of
             the WORK and IWORK arrays, and no error message related to
             LWORK or LIWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, the algorithm failed to converge; i
             off-diagonal elements of an intermediate tridiagonal
             form did not converge to zero.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMQL">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMQL overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMQL.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMQL overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,K)
             The i-th column must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGEQLF in the last k columns of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             If SIDE = 'L', LDA .GE. max(1,M);
             if SIDE = 'R', LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQLF.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGQR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGQR generates an M-by-N real matrix Q with orthonormal columns,
             which is defined as the first N columns of a product of K elementary
             reflectors of order M
             
             Q  =  H(1) H(2) . . . H(k)
             
             as returned by DGEQRF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGQR.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGQR generates an M-by-N real matrix Q with orthonormal columns,
             which is defined as the first N columns of a product of K elementary
             reflectors of order M
             
             Q  =  H(1) H(2) . . . H(k)
             
             as returned by DGEQRF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. M .GE. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the i-th column must contain the vector which
             defines the elementary reflector H(i), for i = 1,2,...,k, as
             returned by DGEQRF in the first k columns of its array
             argument A.
             On exit, the M-by-N matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQRF.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N).
             For optimum performance LWORK .GE. N*NB, where NB is the
             optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASWP">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASWP performs a series of row interchanges on the matrix A.
             One row interchange is initiated for each of rows K1 through K2 of A.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASWP.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLASWP performs a series of row interchanges on the matrix A.
             One row interchange is initiated for each of rows K1 through K2 of A.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the matrix of column dimension N to which the row
             interchanges will be applied.
             On exit, the permuted matrix.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
            </param>
             <param name="K1">
             (input) INTEGER
             The first element of IPIV for which a row interchange will
             be done.
            </param>
             <param name="K2">
             (input) INTEGER
             The last element of IPIV for which a row interchange will
             be done.
            </param>
             <param name="IPIV">
             (input) INTEGER array, dimension (K2*abs(INCX))
             The vector of pivot indices.  Only the elements in positions
             K1 through K2 of IPIV are accessed.
             IPIV(K) = L implies rows K and L are to be interchanged.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between successive values of IPIV.  If IPIV
             is negative, the pivots are applied in reverse order.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARZT">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARZT forms the triangular factor T of a real block reflector
             H of order .GT. n, which is defined as a product of k elementary
             reflectors.
             
             If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
             
             If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
             
             If STOREV = 'C', the vector which defines the elementary reflector
             H(i) is stored in the i-th column of the array V, and
             
             H  =  I - V * T * V'
             
             If STOREV = 'R', the vector which defines the elementary reflector
             H(i) is stored in the i-th row of the array V, and
             
             H  =  I - V' * T * V
             
             Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARZT.Run(System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARZT forms the triangular factor T of a real block reflector
             H of order .GT. n, which is defined as a product of k elementary
             reflectors.
             
             If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
             
             If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
             
             If STOREV = 'C', the vector which defines the elementary reflector
             H(i) is stored in the i-th column of the array V, and
             
             H  =  I - V * T * V'
             
             If STOREV = 'R', the vector which defines the elementary reflector
             H(i) is stored in the i-th row of the array V, and
             
             H  =  I - V' * T * V
             
             Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
             
            </summary>
             <param name="DIRECT">
             (input) CHARACTER*1
             Specifies the order in which the elementary reflectors are
             multiplied to form the block reflector:
             = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
             = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </param>
             <param name="STOREV">
             (input) CHARACTER*1
             Specifies how the vectors which define the elementary
             reflectors are stored (see also Further Details):
             = 'C': columnwise                        (not supported yet)
             = 'R': rowwise
            </param>
             <param name="N">
             (input) INTEGER
             The order of the block reflector H. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The order of the triangular factor T (= the number of
             elementary reflectors). K .GE. 1.
            </param>
             <param name="V">
             (input/output) DOUBLE PRECISION array, dimension
             (LDV,K) if STOREV = 'C'
             (LDV,N) if STOREV = 'R'
             The matrix V. See further details.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V.
             If STOREV = 'C', LDV .GE. max(1,N); if STOREV = 'R', LDV .GE. K.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i).
            </param>
             <param name="T">
             (output) DOUBLE PRECISION array, dimension (LDT,K)
             The k by k triangular factor T of the block reflector.
             If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
             lower triangular. The rest of the array is not used.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. K.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANTR">
             <summary>
             -- LAPACK auxiliary routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             October 31, 1992
             Purpose
             =======
             
             DLANTR  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             trapezoidal or triangular matrix A.
             
             Description
             ===========
             
             DLANTR returns the value
             
             DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANTR.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLANTR  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             trapezoidal or triangular matrix A.
             
             Description
             ===========
             
             DLANTR returns the value
             
             DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies the value to be returned in DLANTR as described
             above.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the matrix A is upper or lower trapezoidal.
             = 'U':  Upper trapezoidal
             = 'L':  Lower trapezoidal
             Note that A is triangular instead of trapezoidal if M = N.
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             Specifies whether or not the matrix A has unit diagonal.
             = 'N':  Non-unit diagonal
             = 'U':  Unit diagonal
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0, and if
             UPLO = 'U', M .LE. N.  When M = 0, DLANTR is set to zero.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0, and if
             UPLO = 'L', N .LE. M.  When N = 0, DLANTR is set to zero.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The trapezoidal matrix A (A is triangular if M = N).
             If UPLO = 'U', the leading m by n upper trapezoidal part of
             the array A contains the upper trapezoidal matrix, and the
             strictly lower triangular part of A is not referenced.
             If UPLO = 'L', the leading m by n lower trapezoidal part of
             the array A contains the lower trapezoidal matrix, and the
             strictly upper triangular part of A is not referenced.  Note
             that when DIAG = 'U', the diagonal elements of A are not
             referenced and are assumed to be one.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(M,1).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (LWORK),
             where LWORK .GE. M when NORM = 'I'; otherwise, WORK is not
             referenced.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLANGE">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLANGE  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real matrix A.
             
             Description
             ===========
             
             DLANGE returns the value
             
             DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLANGE.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLANGE  returns the value of the one norm,  or the Frobenius norm, or
             the  infinity norm,  or the  element of  largest absolute value  of a
             real matrix A.
             
             Description
             ===========
             
             DLANGE returns the value
             
             DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
             
             where  norm1  denotes the  one norm of a matrix (maximum column sum),
             normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
             normF  denotes the  Frobenius norm of a matrix (square root of sum of
             squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies the value to be returned in DLANGE as described
             above.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.  When M = 0,
             DLANGE is set to zero.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.  When N = 0,
             DLANGE is set to zero.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The m by n matrix A.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(M,1).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
             where LWORK .GE. M when NORM = 'I'; otherwise, WORK is not
             referenced.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAHR2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
             matrix A so that elements below the k-th subdiagonal are zero. The
             reduction is performed by an orthogonal similarity transformation
             Q' * A * Q. The routine returns the matrices V and T which determine
             Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
             
             This is an auxiliary routine called by DGEHRD.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAHR2.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
             matrix A so that elements below the k-th subdiagonal are zero. The
             reduction is performed by an orthogonal similarity transformation
             Q' * A * Q. The routine returns the matrices V and T which determine
             Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
             
             This is an auxiliary routine called by DGEHRD.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.
            </param>
             <param name="K">
             (input) INTEGER
             The offset for the reduction. Elements below the k-th
             subdiagonal in the first NB columns are reduced to zero.
             K .LT. N.
            </param>
             <param name="NB">
             (input) INTEGER
             The number of columns to be reduced.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N-K+1)
             On entry, the n-by-(n-k+1) general matrix A.
             On exit, the elements on and above the k-th subdiagonal in
             the first NB columns are overwritten with the corresponding
             elements of the reduced matrix; the elements below the k-th
             subdiagonal, with the array TAU, represent the matrix Q as a
             product of elementary reflectors. The other columns of A are
             unchanged. See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (NB)
             The scalar factors of the elementary reflectors. See Further
             Details.
            </param>
             <param name="T">
             (output) DOUBLE PRECISION array, dimension (LDT,NB)
             The upper triangular matrix T.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T.  LDT .GE. NB.
            </param>
             <param name="Y">
             (output) DOUBLE PRECISION array, dimension (LDY,NB)
             The n-by-nb matrix Y.
            </param>
             <param name="LDY">
             (input) INTEGER
             The leading dimension of the array Y. LDY .GE. N.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED8">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED8 merges the two sets of eigenvalues together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             eigenvalues are close together or if there is a tiny element in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED8.Run(System.Int32,System.Int32@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED8 merges the two sets of eigenvalues together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             eigenvalues are close together or if there is a tiny element in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             = 0:  Compute eigenvalues only.
             = 1:  Compute eigenvectors of original dense symmetric matrix
             also.  On entry, Q contains the orthogonal matrix used
             to reduce the original matrix to tridiagonal form.
            </param>
             <param name="K">
             (output) INTEGER
             The number of non-deflated eigenvalues, and the order of the
             related secular equation.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="QSIZ">
             (input) INTEGER
             The dimension of the orthogonal matrix used to reduce
             the full matrix to tridiagonal form.  QSIZ .GE. N if ICOMPQ = 1.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the eigenvalues of the two submatrices to be
             combined.  On exit, the trailing (N-K) updated eigenvalues
             (those which were deflated) sorted into increasing order.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             If ICOMPQ = 0, Q is not referenced.  Otherwise,
             on entry, Q contains the eigenvectors of the partially solved
             system which has been previously updated in matrix
             multiplies with other partially solved eigensystems.
             On exit, Q contains the trailing (N-K) updated eigenvectors
             (those which were deflated) in its last N-K columns.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="INDXQ">
             (input) INTEGER array, dimension (N)
             The permutation which separately sorts the two sub-problems
             in D into ascending order.  Note that elements in the second
             half of this permutation must first have CUTPNT added to
             their values in order to be accurate.
            </param>
             <param name="RHO">
             (input/output) DOUBLE PRECISION
             On entry, the off-diagonal element associated with the rank-1
             cut which originally split the two submatrices which are now
             being recombined.
             On exit, RHO has been modified to the value required by
             DLAED3.
            </param>
             <param name="CUTPNT">
             (input) INTEGER
             The location of the last eigenvalue in the leading
             sub-matrix.  min(1,N) .LE. CUTPNT .LE. N.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (N)
             On entry, Z contains the updating vector (the last row of
             the first sub-eigenvector matrix and the first row of the
             second sub-eigenvector matrix).
             On exit, the contents of Z are destroyed by the updating
             process.
            </param>
             <param name="DLAMDA">
             (output) DOUBLE PRECISION array, dimension (N)
             A copy of the first K eigenvalues which will be used by
             DLAED3 to form the secular equation.
            </param>
             <param name="Q2">
             (output) DOUBLE PRECISION array, dimension (LDQ2,N)
             If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
             a copy of the first K eigenvectors which will be used by
             DLAED7 in a matrix multiply (DGEMM) to update the new
             eigenvectors.
            </param>
             <param name="LDQ2">
             (input) INTEGER
             The leading dimension of the array Q2.  LDQ2 .GE. max(1,N).
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             The first k values of the final deflation-altered z-vector and
             will be passed to DLAED3.
            </param>
             <param name="PERM">
             (output) INTEGER array, dimension (N)
             The permutations (from deflation and sorting) to be applied
             to each eigenblock.
            </param>
             <param name="GIVPTR">
             (output) INTEGER
             The number of Givens rotations which took place in this
             subproblem.
            </param>
             <param name="GIVCOL">
             (output) INTEGER array, dimension (2, N)
             Each pair of numbers indicates a pair of columns to take place
             in a Givens rotation.
            </param>
             <param name="GIVNUM">
             (output) DOUBLE PRECISION array, dimension (2, N)
             Each number indicates the S value to be used in the
             corresponding Givens rotation.
            </param>
             <param name="INDXP">
             (workspace) INTEGER array, dimension (N)
             The permutation used to place deflated values of D at the end
             of the array.  INDXP(1:K) points to the nondeflated D-values
             and INDXP(K+1:N) points to the deflated eigenvalues.
            </param>
             <param name="INDX">
             (workspace) INTEGER array, dimension (N)
             The permutation used to sort the contents of D into ascending
             order.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLACPY">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLACPY copies all or part of a two-dimensional matrix A to another
             matrix B.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLACPY.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLACPY copies all or part of a two-dimensional matrix A to another
             matrix B.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies the part of the matrix A to be copied to B.
             = 'U':      Upper triangular part
             = 'L':      Lower triangular part
             Otherwise:  All of the matrix A
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The m by n matrix A.  If UPLO = 'U', only the upper triangle
             or trapezoid is accessed; if UPLO = 'L', only the lower
             triangle or trapezoid is accessed.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="B">
             (output) DOUBLE PRECISION array, dimension (LDB,N)
             On exit, B = A in the locations specified by UPLO.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,M).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGESVD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGESVD computes the singular value decomposition (SVD) of a real
             M-by-N matrix A, optionally computing the left and/or right singular
             vectors. The SVD is written
             
             A = U * SIGMA * transpose(V)
             
             where SIGMA is an M-by-N matrix which is zero except for its
             min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
             V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
             are the singular values of A; they are real and non-negative, and
             are returned in descending order.  The first min(m,n) columns of
             U and V are the left and right singular vectors of A.
             
             Note that the routine returns V**T, not V.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGESVD.Run(System.String,System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGESVD computes the singular value decomposition (SVD) of a real
             M-by-N matrix A, optionally computing the left and/or right singular
             vectors. The SVD is written
             
             A = U * SIGMA * transpose(V)
             
             where SIGMA is an M-by-N matrix which is zero except for its
             min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
             V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
             are the singular values of A; they are real and non-negative, and
             are returned in descending order.  The first min(m,n) columns of
             U and V are the left and right singular vectors of A.
             
             Note that the routine returns V**T, not V.
             
            </summary>
             <param name="JOBU">
             (input) CHARACTER*1
             Specifies options for computing all or part of the matrix U:
             = 'A':  all M columns of U are returned in array U:
             = 'S':  the first min(m,n) columns of U (the left singular
             vectors) are returned in the array U;
             = 'O':  the first min(m,n) columns of U (the left singular
             vectors) are overwritten on the array A;
             = 'N':  no columns of U (no left singular vectors) are
             computed.
            </param>
             <param name="JOBVT">
             (input) CHARACTER*1
             Specifies options for computing all or part of the matrix
             V**T:
             = 'A':  all N rows of V**T are returned in the array VT;
             = 'S':  the first min(m,n) rows of V**T (the right singular
             vectors) are returned in the array VT;
             = 'O':  the first min(m,n) rows of V**T (the right singular
             vectors) are overwritten on the array A;
             = 'N':  no rows of V**T (no right singular vectors) are
             computed.
             
             JOBVT and JOBU cannot both be 'O'.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the input matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the input matrix A.  N .GE. 0.
            </param>
             <param name="A">
             = U * SIGMA * transpose(V)
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="S">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The singular values of A, sorted so that S(i) .GE. S(i+1).
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
             (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
             If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
             if JOBU = 'S', U contains the first min(m,n) columns of U
             (the left singular vectors, stored columnwise);
             if JOBU = 'N' or 'O', U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. 1; if
             JOBU = 'S' or 'A', LDU .GE. M.
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array, dimension (LDVT,N)
             If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
             V**T;
             if JOBVT = 'S', VT contains the first min(m,n) rows of
             V**T (the right singular vectors, stored rowwise);
             if JOBVT = 'N' or 'O', VT is not referenced.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. 1; if
             JOBVT = 'A', LDVT .GE. N; if JOBVT = 'S', LDVT .GE. min(M,N).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
             if INFO .GT. 0, WORK(2:MIN(M,N)) contains the unconverged
             superdiagonal elements of an upper bidiagonal matrix B
             whose diagonal is in S (not necessarily sorted). B
             satisfies A = U * B * VT, so it has the same singular values
             as A, and singular vectors related by U and VT.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             LWORK .GE. MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
             For good performance, LWORK should generally be larger.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if DBDSQR did not converge, INFO specifies how many
             superdiagonals of an intermediate bidiagonal form B
             did not converge to zero. See the description of WORK
             above for details.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGELSY">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGELSY computes the minimum-norm solution to a real linear least
             squares problem:
             minimize || A * X - B ||
             using a complete orthogonal factorization of A.  A is an M-by-N
             matrix which may be rank-deficient.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
             The routine first computes a QR factorization with column pivoting:
             A * P = Q * [ R11 R12 ]
             [  0  R22 ]
             with R11 defined as the largest leading submatrix whose estimated
             condition number is less than 1/RCOND.  The order of R11, RANK,
             is the effective rank of A.
             
             Then, R22 is considered to be negligible, and R12 is annihilated
             by orthogonal transformations from the right, arriving at the
             complete orthogonal factorization:
             A * P = Q * [ T11 0 ] * Z
             [  0  0 ]
             The minimum-norm solution is then
             X = P * Z' [ inv(T11)*Q1'*B ]
             [        0       ]
             where Q1 consists of the first RANK columns of Q.
             
             This routine is basically identical to the original xGELSX except
             three differences:
             o The call to the subroutine xGEQPF has been substituted by the
             the call to the subroutine xGEQP3. This subroutine is a Blas-3
             version of the QR factorization with column pivoting.
             o Matrix B (the right hand side) is updated with Blas-3.
             o The permutation of matrix B (the right hand side) is faster and
             more simple.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGELSY.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGELSY computes the minimum-norm solution to a real linear least
             squares problem:
             minimize || A * X - B ||
             using a complete orthogonal factorization of A.  A is an M-by-N
             matrix which may be rank-deficient.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
             The routine first computes a QR factorization with column pivoting:
             A * P = Q * [ R11 R12 ]
             [  0  R22 ]
             with R11 defined as the largest leading submatrix whose estimated
             condition number is less than 1/RCOND.  The order of R11, RANK,
             is the effective rank of A.
             
             Then, R22 is considered to be negligible, and R12 is annihilated
             by orthogonal transformations from the right, arriving at the
             complete orthogonal factorization:
             A * P = Q * [ T11 0 ] * Z
             [  0  0 ]
             The minimum-norm solution is then
             X = P * Z' [ inv(T11)*Q1'*B ]
             [        0       ]
             where Q1 consists of the first RANK columns of Q.
             
             This routine is basically identical to the original xGELSX except
             three differences:
             o The call to the subroutine xGEQPF has been substituted by the
             the call to the subroutine xGEQP3. This subroutine is a Blas-3
             version of the QR factorization with column pivoting.
             o Matrix B (the right hand side) is updated with Blas-3.
             o The permutation of matrix B (the right hand side) is faster and
             more simple.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of
             columns of matrices B and X. NRHS .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, A has been overwritten by details of its
             complete orthogonal factorization.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the M-by-NRHS right hand side matrix B.
             On exit, the N-by-NRHS solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,M,N).
            </param>
             <param name="JPVT">
             (input/output) INTEGER array, dimension (N)
             On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
             to the front of AP, otherwise column i is a free column.
             On exit, if JPVT(i) = k, then the i-th column of AP
             was the k-th column of A.
            </param>
             <param name="RCOND">
             (input) DOUBLE PRECISION
             RCOND is used to determine the effective rank of A, which
             is defined as the order of the largest leading triangular
             submatrix R11 in the QR factorization with pivoting of A,
             whose estimated condition number .LT. 1/RCOND.
            </param>
             <param name="RANK">
             (output) INTEGER
             The effective rank of A, i.e., the order of the submatrix
             R11.  This is the same as the order of the submatrix T11
             in the complete orthogonal factorization of A.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             The unblocked strategy requires that:
             LWORK .GE. MAX( MN+3*N+1, 2*MN+NRHS ),
             where MN = min( M, N ).
             The block algorithm requires that:
             LWORK .GE. MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
             where NB is an upper bound on the blocksize returned
             by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
             and DORMRZ.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: If INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGELQF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGELQF computes an LQ factorization of a real M-by-N matrix A:
             A = L * Q.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGELQF.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGELQF computes an LQ factorization of a real M-by-N matrix A:
             A = L * Q.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and below the diagonal of the array
             contain the m-by-min(m,n) lower trapezoidal matrix L (L is
             lower triangular if m .LE. n); the elements above the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of elementary reflectors (see Further Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. M*NB, where NB is the
             optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.CG.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="NM">
             must be set to the row dimension of the two-dimensional
            </param>
             <param name="N">
             is the order of the matrix  a=(ar,ai).
            </param>
             <param name="AR">
             and  ai  contain the real and imaginary parts,
            </param>
             <param name="WR">
             and  wi  contain the real and imaginary parts,
            </param>
             <param name="MATZ">
             is an integer variable set equal to zero if
            </param>
             <param name="ZR">
             and  zi  contain the real and imaginary parts,
            </param>
             <param name="IERR">
             is an integer output variable set equal to an error
             completion code described in the documentation for comqr
             and comqr2.  the normal completion code is zero.
            </param>
        </member>
        <member name="T:DotNumerics.Optimization.L_BFGS_B">
            <summary>
            Class used to minimizes a function of several variables by using Limited memory BroydenFletcherGoldfarbShanno (L-BFGS) method. This class can be used for unconstrained and bounded constrained minimization.
            </summary>
        </member>
        <member name="T:DotNumerics.Optimization.xMinimizationBase">
            <summary>
            Represents a base class for optimization classes. 
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._Variables">
            <summary>
            All the variables.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._FreeVariables">
            <summary>
            The initial guess .
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._Tolerance">
            <summary>
            Desired accuracy for the solution.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._MaxFunEvaluations">
            <summary>
            Maximum number of function evaluations.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._FunEvaluations">
            <summary>
            The number of function evaluations used to compute the minimum.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.xMinimizationBase._NumFreeVariables">
            <summary>
            The number of variables.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.xMinimizationBase.MaxFunEvaluations">
            <summary>
            Maximum number of function evaluations.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.xMinimizationBase.FunEvaluations">
            <summary>
            The number of function evaluations used to compute the minimum.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.xMinimizationBase.Tolerance">
            <summary>
            Desired accuracy for the solution.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.L_BFGS_B._AccuracyFactor">
            <summary>
            Accuracy factor
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.L_BFGS_B.#ctor">
            <summary>
            Initializes a new instance of the L_BFG_S class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.L_BFGS_B.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,System.Double[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="initialGuess">Array of size N containing the initial guess. N is the number of variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.L_BFGS_B.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,DotNumerics.Optimization.OptVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.L_BFGS_B.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,DotNumerics.Optimization.OptBoundVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="P:DotNumerics.Optimization.L_BFGS_B.AccuracyFactor">
            <summary>
            Accuracy factor. The iteration will stop when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} is least than AccuracyFactor*epsmch
            where epsmch is the machine precision. Typical values for AccuracyFactor: 1E12 for low accuracy; 1E7 for moderate accuracy; 
            1E1 for extremely high accuracy.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.DPOFA.Run(System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32@)">
             <param name="A">
             double precision(lda, n)
             the symmetric matrix to be factored.  only the
             diagonal and upper triangle are used.
            </param>
             <param name="LDA">
             integer
             the leading dimension of the array  a .
            </param>
             <param name="N">
             integer
             the order of the matrix  a .
            </param>
             <param name="INFO">
             integer
             = 0  for normal return.
             = k  signals an error condition.  the leading minor
             of order  k  is not positive definite.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.TridiagonalMatrix">
            <summary>
            Represents a Tridiagonal Matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the TridiagonalMatrix class of the given size.
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.#ctor(System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the TridiagonalMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="Data">The data</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.Random(System.Int32)">
            <summary>Generate a TridiagonalMatrix with random elements</summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.op_Addition(DotNumerics.LinearAlgebra.TridiagonalMatrix,DotNumerics.LinearAlgebra.TridiagonalMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.op_Subtraction(DotNumerics.LinearAlgebra.TridiagonalMatrix,DotNumerics.LinearAlgebra.TridiagonalMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.op_Multiply(System.Double,DotNumerics.LinearAlgebra.TridiagonalMatrix)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.TridiagonalMatrix.op_Implicit(DotNumerics.LinearAlgebra.TridiagonalMatrix)~DotNumerics.LinearAlgebra.Matrix">
            <summary>
            Implicit TridiagonalMatrix to Matrix conversion.
            </summary>
            <param name="tridiagonal"> The TridiagonalMatrix.</param>
            <returns>The Matrix.</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.Matrix">
            <summary>
            Represents a general Matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the Matrix class of the given size.
            </summary>
            <param name="size">Size</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the Matrix class of the given size.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Initializes a new instance of the Matrix class using a array.
            </summary>
            <param name="data">The data of the matrix.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the Matrix class of the given size using a array.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="Data">The data, the data is copied.</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.AddInplace(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            In place addition A=A+B
            </summary>
            <param name="B">The Matrix</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.SubtractInplace(DotNumerics.LinearAlgebra.BaseMatrix)">
            <summary>
            In place matrix subtraction, A=A-B
            </summary>
            <param name="B">The Matrix</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.UnaryMinus">
            <summary>
            Unary minus.
            </summary>
            <returns> -this</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.op_Addition(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.op_Subtraction(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.op_UnaryNegation(DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Unary minus.
            </summary>
            <param name="A"> The Matric.</param>
            <returns>Matrix r[i] = -this[i]</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.op_Multiply(System.Double,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.op_Multiply(DotNumerics.LinearAlgebra.Matrix,System.Double)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.Clone">
            <summary>
            Creates a copy of the matrix.
            </summary>
            <returns>The copy of the Matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.Random(System.Int32,System.Int32)">
            <summary>Generate a matrix with random elements</summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <returns>An m-by-n matrix with uniformly distributed
            random elements in <c>[0, 1)</c> interval.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.Matrix.Random(System.Int32,System.Int32,System.Int32)">
            <summary>Generate a matrix with random elements</summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="Seed">
            A number used to calculate a starting value for the pseudo-random number
            sequence. If a negative number is specified, the absolute value of the number
            is used.
            </param>
            <returns>
            An m-by-n matrix with uniformly distributed
            random elements in <c>[0, 1)</c> interval.
            </returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRTRS">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTRTRS solves a triangular system of the form
             
             A * X = B  or  A**T * X = B,
             
             where A is a triangular matrix of order N, and B is an N-by-NRHS
             matrix.  A check is made to verify that A is nonsingular.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRTRS.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTRTRS solves a triangular system of the form
             
             A * X = B  or  A**T * X = B,
             
             where A is a triangular matrix of order N, and B is an N-by-NRHS
             matrix.  A check is made to verify that A is nonsingular.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  A is upper triangular;
             = 'L':  A is lower triangular.
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             Specifies the form of the system of equations:
             = 'N':  A * X = B  (No transpose)
             = 'T':  A**T * X = B  (Transpose)
             = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             = 'N':  A is non-unit triangular;
             = 'U':  A is unit triangular.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="A">
             * X = B  or  A**T * X = B,
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, if INFO = 0, the solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: if INFO = i, the i-th diagonal element of A is zero,
             indicating that the matrix is singular and the solutions
             X have not been computed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRMM">
             <summary>
             Purpose
             =======
             
             DTRMM  performs one of the matrix-matrix operations
             
             B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
             
             where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
             non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
             
             op( A ) = A   or   op( A ) = A'.
             
             Parameters
             ==========
             
             SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
             
             SIDE = 'L' or 'l'   B := alpha*op( A )*B.
             
             SIDE = 'R' or 'r'   B := alpha*B*op( A ).
             
             Unchanged on exit.
             
             UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
             
             TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
             
             TRANSA = 'N' or 'n'   op( A ) = A.
             
             TRANSA = 'T' or 't'   op( A ) = A'.
             
             TRANSA = 'C' or 'c'   op( A ) = A'.
             
             Unchanged on exit.
             
             DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
             
             M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.
             
             ALPHA  - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.
             
             B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
             
             LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRMM.Run(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DTRMM  performs one of the matrix-matrix operations
             
             B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
             
             where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
             non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
             
             op( A ) = A   or   op( A ) = A'.
             
             Parameters
             ==========
             
             SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
             
             SIDE = 'L' or 'l'   B := alpha*op( A )*B.
             
             SIDE = 'R' or 'r'   B := alpha*B*op( A ).
             
             Unchanged on exit.
             
             UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
             
             TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
             
             TRANSA = 'N' or 'n'   op( A ) = A.
             
             TRANSA = 'T' or 't'   op( A ) = A'.
             
             TRANSA = 'C' or 'c'   op( A ) = A'.
             
             Unchanged on exit.
             
             DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
             
             M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.
             
             N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.
             
             ALPHA  - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.
             
             A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.
             
             LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.
             
             B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
             
             LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.
            </summary>
             <param name="SIDE">
             - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
             
             SIDE = 'L' or 'l'   B := alpha*op( A )*B.
             
             SIDE = 'R' or 'r'   B := alpha*B*op( A ).
             
             Unchanged on exit.
            </param>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
            </param>
             <param name="TRANSA">
             - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
             
             TRANSA = 'N' or 'n'   op( A ) = A.
             
             TRANSA = 'T' or 't'   op( A ) = A'.
             
             TRANSA = 'C' or 'c'   op( A ) = A'.
             
             Unchanged on exit.
            </param>
             <param name="DIAG">
             - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
            </param>
             <param name="M">
             - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="B">
             := alpha*op( A )*B,   or   B := alpha*B*op( A ),
            </param>
             <param name="LDB">
             - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYMV">
             <summary>
             Purpose
             =======
             
             DSYMV  performs the matrix-vector  operation
             
             y := alpha*A*x + beta*y,
             
             where alpha and beta are scalars, x and y are n element vectors and
             A is an n by n symmetric matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYMV.Run(System.String,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DSYMV  performs the matrix-vector  operation
             
             y := alpha*A*x + beta*y,
             
             where alpha and beta are scalars, x and y are n element vectors and
             A is an n by n symmetric matrix.
             
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
             
             UPLO = 'U' or 'u'   Only the upper triangular part of A
             is to be referenced.
             
             UPLO = 'L' or 'l'   Only the lower triangular part of A
             is to be referenced.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </param>
             <param name="BETA">
             - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.
            </param>
             <param name="Y">
             := alpha*A*x + beta*y,
            </param>
             <param name="INCY">
             - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLATRZ">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLATRZ factors the M-by-(M+L) real upper trapezoidal matrix
             [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means
             of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
             matrix and, R and A1 are M-by-M upper triangular matrices.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLATRZ.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLATRZ factors the M-by-(M+L) real upper trapezoidal matrix
             [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means
             of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
             matrix and, R and A1 are M-by-M upper triangular matrices.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="L">
             (input) INTEGER
             The number of columns of the matrix A containing the
             meaningful part of the Householder vectors. N-M .GE. L .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the leading M-by-N upper trapezoidal part of the
             array A must contain the matrix to be factorized.
             On exit, the leading M-by-M upper triangular part of A
             contains the upper triangular matrix R, and elements N-L+1 to
             N of the first M rows of A, with the array TAU, represent the
             orthogonal matrix Z as a product of M elementary reflectors.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (M)
             The scalar factors of the elementary reflectors.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (M)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASQ6">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASQ6 computes one dqd (shift equal to zero) transform in
             ping-pong form, with protection against underflow and overflow.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASQ6.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLASQ6 computes one dqd (shift equal to zero) transform in
             ping-pong form, with protection against underflow and overflow.
             
            </summary>
             <param name="I0">
             (input) INTEGER
             First index.
            </param>
             <param name="N0">
             (input) INTEGER
             Last index.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
             an extra argument.
            </param>
             <param name="PP">
             (input) INTEGER
             PP=0 for ping, PP=1 for pong.
            </param>
             <param name="DMIN">
             (output) DOUBLE PRECISION
             Minimum value of d.
            </param>
             <param name="DMIN1">
             (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).
            </param>
             <param name="DMIN2">
             (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).
            </param>
             <param name="DN">
             (output) DOUBLE PRECISION
             d(N0), the last value of d.
            </param>
             <param name="DNM1">
             (output) DOUBLE PRECISION
             d(N0-1).
            </param>
             <param name="DNM2">
             (output) DOUBLE PRECISION
             d(N0-2).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASCL">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASCL multiplies the M by N real matrix A by the real scalar
             CTO/CFROM.  This is done without over/underflow as long as the final
             result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
             A may be full, upper triangular, lower triangular, upper Hessenberg,
             or banded.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASCL.Run(System.String,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASCL multiplies the M by N real matrix A by the real scalar
             CTO/CFROM.  This is done without over/underflow as long as the final
             result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
             A may be full, upper triangular, lower triangular, upper Hessenberg,
             or banded.
             
            </summary>
             <param name="TYPE">
             (input) CHARACTER*1
             TYPE indices the storage type of the input matrix.
             = 'G':  A is a full matrix.
             = 'L':  A is a lower triangular matrix.
             = 'U':  A is an upper triangular matrix.
             = 'H':  A is an upper Hessenberg matrix.
             = 'B':  A is a symmetric band matrix with lower bandwidth KL
             and upper bandwidth KU and with the only the lower
             half stored.
             = 'Q':  A is a symmetric band matrix with lower bandwidth KL
             and upper bandwidth KU and with the only the upper
             half stored.
             = 'Z':  A is a band matrix with lower bandwidth KL and upper
             bandwidth KU.
            </param>
             <param name="KL">
             (input) INTEGER
             The lower bandwidth of A.  Referenced only if TYPE = 'B',
             'Q' or 'Z'.
            </param>
             <param name="KU">
             (input) INTEGER
             The upper bandwidth of A.  Referenced only if TYPE = 'B',
             'Q' or 'Z'.
            </param>
             <param name="CFROM">
             (input) DOUBLE PRECISION
            </param>
             <param name="CTO">
             (input) DOUBLE PRECISION
             The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
             without over/underflow if the final result CTO*A(I,J)/CFROM
             can be represented without over/underflow.  CFROM must be
             nonzero.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             The matrix to be multiplied by CTO/CFROM.  See TYPE for the
             storage type.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="INFO">
             (output) INTEGER
             0  - successful exit
             .LT.0 - if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARZB">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARZB applies a real block reflector H or its transpose H**T to
             a real distributed M-by-N  C from the left or the right.
             
             Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARZB.Run(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARZB applies a real block reflector H or its transpose H**T to
             a real distributed M-by-N  C from the left or the right.
             
             Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply H or H' from the Left
             = 'R': apply H or H' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply H (No transpose)
             = 'C': apply H' (Transpose)
            </param>
             <param name="DIRECT">
             (input) CHARACTER*1
             Indicates how H is formed from a product of elementary
             reflectors
             = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
             = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </param>
             <param name="STOREV">
             (input) CHARACTER*1
             Indicates how the vectors which define the elementary
             reflectors are stored:
             = 'C': Columnwise                        (not supported yet)
             = 'R': Rowwise
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C.
            </param>
             <param name="K">
             (input) INTEGER
             The order of the matrix T (= the number of elementary
             reflectors whose product defines the block reflector).
            </param>
             <param name="L">
             (input) INTEGER
             The number of columns of the matrix V containing the
             meaningful part of the Householder reflectors.
             If SIDE = 'L', M .GE. L .GE. 0, if SIDE = 'R', N .GE. L .GE. 0.
            </param>
             <param name="V">
             (input) DOUBLE PRECISION array, dimension (LDV,NV).
             If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V.
             If STOREV = 'C', LDV .GE. L; if STOREV = 'R', LDV .GE. K.
            </param>
             <param name="T">
             (input) DOUBLE PRECISION array, dimension (LDT,K)
             The triangular K-by-K matrix T in the representation of the
             block reflector.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. K.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
            </param>
             <param name="LDWORK">
             (input) INTEGER
             The leading dimension of the array WORK.
             If SIDE = 'L', LDWORK .GE. max(1,N);
             if SIDE = 'R', LDWORK .GE. max(1,M).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLALSA">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLALSA is an itermediate step in solving the least squares problem
             by computing the SVD of the coefficient matrix in compact form (The
             singular vectors are computed as products of simple orthorgonal
             matrices.).
             
             If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
             matrix of an upper bidiagonal matrix to the right hand side; and if
             ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
             right hand side. The singular vector matrices were generated in
             compact form by DLALSA.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLALSA.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLALSA is an itermediate step in solving the least squares problem
             by computing the SVD of the coefficient matrix in compact form (The
             singular vectors are computed as products of simple orthorgonal
             matrices.).
             
             If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
             matrix of an upper bidiagonal matrix to the right hand side; and if
             ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
             right hand side. The singular vector matrices were generated in
             compact form by DLALSA.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether the left or the right singular vector
             matrix is involved.
             = 0: Left singular vector matrix
             = 1: Right singular vector matrix
            </param>
             <param name="SMLSIZ">
             (input) INTEGER
             The maximum size of the subproblems at the bottom of the
             computation tree.
            </param>
             <param name="N">
             (input) INTEGER
             The row and column dimensions of the upper bidiagonal matrix.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of columns of B and BX. NRHS must be at least 1.
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension ( LDB, NRHS )
             On input, B contains the right hand sides of the least
             squares problem in rows 1 through M.
             On output, B contains the solution X in rows 1 through N.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of B in the calling subprogram.
             LDB must be at least max(1,MAX( M, N ) ).
            </param>
             <param name="BX">
             (output) DOUBLE PRECISION array, dimension ( LDBX, NRHS )
             On exit, the result of applying the left or right singular
             vector matrix to B.
            </param>
             <param name="LDBX">
             (input) INTEGER
             The leading dimension of BX.
            </param>
             <param name="U">
             (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
             On entry, U contains the left singular vector matrices of all
             subproblems at the bottom level.
            </param>
             <param name="LDU">
             (input) INTEGER, LDU = .GT. N.
             The leading dimension of arrays U, VT, DIFL, DIFR,
             POLES, GIVNUM, and Z.
            </param>
             <param name="VT">
             (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
             On entry, VT' contains the right singular vector matrices of
             all subproblems at the bottom level.
            </param>
             <param name="K">
             (input) INTEGER array, dimension ( N ).
            </param>
             <param name="DIFL">
             (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
             where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
            </param>
             <param name="DIFR">
             (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
             On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
             distances between singular values on the I-th level and
             singular values on the (I -1)-th level, and DIFR(*, 2 * I)
             record the normalizing factors of the right singular vectors
             matrices of subproblems on I-th level.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
             On entry, Z(1, I) contains the components of the deflation-
             adjusted updating row vector for subproblems on the I-th
             level.
            </param>
             <param name="POLES">
             (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
             On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
             singular values involved in the secular equations on the I-th
             level.
            </param>
             <param name="GIVPTR">
             (input) INTEGER array, dimension ( N ).
             On entry, GIVPTR( I ) records the number of Givens
             rotations performed on the I-th problem on the computation
             tree.
            </param>
             <param name="GIVCOL">
             (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
             On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
             locations of Givens rotations performed on the I-th level on
             the computation tree.
            </param>
             <param name="LDGCOL">
             (input) INTEGER, LDGCOL = .GT. N.
             The leading dimension of arrays GIVCOL and PERM.
            </param>
             <param name="PERM">
             (input) INTEGER array, dimension ( LDGCOL, NLVL ).
             On entry, PERM(*, I) records permutations done on the I-th
             level of the computation tree.
            </param>
             <param name="GIVNUM">
             (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
             On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
             values of Givens rotations performed on the I-th level on the
             computation tree.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION array, dimension ( N ).
             On entry, if the I-th subproblem is not square,
             C( I ) contains the C-value of a Givens rotation related to
             the right null space of the I-th subproblem.
            </param>
             <param name="S">
             (input) DOUBLE PRECISION array, dimension ( N ).
             On entry, if the I-th subproblem is not square,
             S( I ) contains the S-value of a Givens rotation related to
             the right null space of the I-th subproblem.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array.
             The dimension must be at least N.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array.
             The dimension must be at least 3 * N
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED7">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED7 computes the updated eigensystem of a diagonal
             matrix after modification by a rank-one symmetric matrix. This
             routine is used only for the eigenproblem which requires all
             eigenvalues and optionally eigenvectors of a dense symmetric matrix
             that has been reduced to tridiagonal form.  DLAED1 handles
             the case in which all eigenvalues and eigenvectors of a symmetric
             tridiagonal matrix are desired.
             
             T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
             
             where Z = Q'u, u is a vector of length N with ones in the
             CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
             
             The eigenvectors of the original matrix are stored in Q, and the
             eigenvalues are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple eigenvalues or if there is a zero in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLAED8.
             
             The second stage consists of calculating the updated
             eigenvalues. This is done by finding the roots of the secular
             equation via the routine DLAED4 (as called by DLAED9).
             This routine also calculates the eigenvectors of the current
             problem.
             
             The final stage consists of computing the updated eigenvectors
             directly using the updated eigenvalues.  The eigenvectors for
             the current problem are multiplied with the eigenvectors from
             the overall problem.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED7.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED7 computes the updated eigensystem of a diagonal
             matrix after modification by a rank-one symmetric matrix. This
             routine is used only for the eigenproblem which requires all
             eigenvalues and optionally eigenvectors of a dense symmetric matrix
             that has been reduced to tridiagonal form.  DLAED1 handles
             the case in which all eigenvalues and eigenvectors of a symmetric
             tridiagonal matrix are desired.
             
             T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
             
             where Z = Q'u, u is a vector of length N with ones in the
             CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
             
             The eigenvectors of the original matrix are stored in Q, and the
             eigenvalues are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple eigenvalues or if there is a zero in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLAED8.
             
             The second stage consists of calculating the updated
             eigenvalues. This is done by finding the roots of the secular
             equation via the routine DLAED4 (as called by DLAED9).
             This routine also calculates the eigenvectors of the current
             problem.
             
             The final stage consists of computing the updated eigenvectors
             directly using the updated eigenvalues.  The eigenvectors for
             the current problem are multiplied with the eigenvectors from
             the overall problem.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             = 0:  Compute eigenvalues only.
             = 1:  Compute eigenvectors of original dense symmetric matrix
             also.  On entry, Q contains the orthogonal matrix used
             to reduce the original matrix to tridiagonal form.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="QSIZ">
             (input) INTEGER
             The dimension of the orthogonal matrix used to reduce
             the full matrix to tridiagonal form.  QSIZ .GE. N if ICOMPQ = 1.
            </param>
             <param name="TLVLS">
             (input) INTEGER
             The total number of merging levels in the overall divide and
             conquer tree.
            </param>
             <param name="CURLVL">
             (input) INTEGER
             The current level in the overall merge routine,
             0 .LE. CURLVL .LE. TLVLS.
            </param>
             <param name="CURPBM">
             (input) INTEGER
             The current problem in the current level in the overall
             merge routine (counting from upper left to lower right).
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the eigenvalues of the rank-1-perturbed matrix.
             On exit, the eigenvalues of the repaired matrix.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
             On entry, the eigenvectors of the rank-1-perturbed matrix.
             On exit, the eigenvectors of the repaired tridiagonal matrix.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="INDXQ">
             (output) INTEGER array, dimension (N)
             The permutation which will reintegrate the subproblem just
             solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
             will be in ascending order.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The subdiagonal element used to create the rank-1
             modification.
            </param>
             <param name="CUTPNT">
             (input) INTEGER
             Contains the location of the last eigenvalue in the leading
             sub-matrix.  min(1,N) .LE. CUTPNT .LE. N.
            </param>
             <param name="QSTORE">
             (input/output) DOUBLE PRECISION array, dimension (N**2+1)
             Stores eigenvectors of submatrices encountered during
             divide and conquer, packed together. QPTR points to
             beginning of the submatrices.
            </param>
             <param name="QPTR">
             (input/output) INTEGER array, dimension (N+2)
             List of indices pointing to beginning of submatrices stored
             in QSTORE. The submatrices are numbered starting at the
             bottom left of the divide and conquer tree, from left to
             right and bottom to top.
            </param>
             <param name="PRMPTR">
             (input) INTEGER array, dimension (N lg N)
             Contains a list of pointers which indicate where in PERM a
             level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
             indicates the size of the permutation and also the size of
             the full, non-deflated problem.
            </param>
             <param name="PERM">
             (input) INTEGER array, dimension (N lg N)
             Contains the permutations (from deflation and sorting) to be
             applied to each eigenblock.
            </param>
             <param name="GIVPTR">
             (input) INTEGER array, dimension (N lg N)
             Contains a list of pointers which indicate where in GIVCOL a
             level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
             indicates the number of Givens rotations.
            </param>
             <param name="GIVCOL">
             (input) INTEGER array, dimension (2, N lg N)
             Each pair of numbers indicates a pair of columns to take place
             in a Givens rotation.
            </param>
             <param name="GIVNUM">
             (input) DOUBLE PRECISION array, dimension (2, N lg N)
             Each number indicates the S value to be used in the
             corresponding Givens rotation.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (3*N+QSIZ*N)
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (4*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an eigenvalue did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGELQ2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGELQ2 computes an LQ factorization of a real m by n matrix A:
             A = L * Q.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGELQ2.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGELQ2 computes an LQ factorization of a real m by n matrix A:
             A = L * Q.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n matrix A.
             On exit, the elements on and below the diagonal of the array
             contain the m by min(m,n) lower trapezoidal matrix L (L is
             lower triangular if m .LE. n); the elements above the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of elementary reflectors (see Further Details).
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Details).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (M)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DBDSQR">
             <summary>
             -- LAPACK routine (version 3.1.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             January 2007
             Purpose
             =======
             
             DBDSQR computes the singular values and, optionally, the right and/or
             left singular vectors from the singular value decomposition (SVD) of
             a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
             zero-shift QR algorithm.  The SVD of B has the form
             
             B = Q * S * P**T
             
             where S is the diagonal matrix of singular values, Q is an orthogonal
             matrix of left singular vectors, and P is an orthogonal matrix of
             right singular vectors.  If left singular vectors are requested, this
             subroutine actually returns U*Q instead of Q, and, if right singular
             vectors are requested, this subroutine returns P**T*VT instead of
             P**T, for given real input matrices U and VT.  When U and VT are the
             orthogonal matrices that reduce a general matrix A to bidiagonal
             form:  A = U*B*VT, as computed by DGEBRD, then
             
             A = (U*Q) * S * (P**T*VT)
             
             is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
             for a given real input matrix C.
             
             See "Computing  Small Singular Values of Bidiagonal Matrices With
             Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
             LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
             no. 5, pp. 873-912, Sept 1990) and
             "Accurate singular values and differential qd algorithms," by
             B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
             Department, University of California at Berkeley, July 1992
             for a detailed description of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DBDSQR.Run(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DBDSQR computes the singular values and, optionally, the right and/or
             left singular vectors from the singular value decomposition (SVD) of
             a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
             zero-shift QR algorithm.  The SVD of B has the form
             
             B = Q * S * P**T
             
             where S is the diagonal matrix of singular values, Q is an orthogonal
             matrix of left singular vectors, and P is an orthogonal matrix of
             right singular vectors.  If left singular vectors are requested, this
             subroutine actually returns U*Q instead of Q, and, if right singular
             vectors are requested, this subroutine returns P**T*VT instead of
             P**T, for given real input matrices U and VT.  When U and VT are the
             orthogonal matrices that reduce a general matrix A to bidiagonal
             form:  A = U*B*VT, as computed by DGEBRD, then
             
             A = (U*Q) * S * (P**T*VT)
             
             is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
             for a given real input matrix C.
             
             See "Computing  Small Singular Values of Bidiagonal Matrices With
             Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
             LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
             no. 5, pp. 873-912, Sept 1990) and
             "Accurate singular values and differential qd algorithms," by
             B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
             Department, University of California at Berkeley, July 1992
             for a detailed description of the algorithm.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  B is upper bidiagonal;
             = 'L':  B is lower bidiagonal.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix B.  N .GE. 0.
            </param>
             <param name="NCVT">
             (input) INTEGER
             The number of columns of the matrix VT. NCVT .GE. 0.
            </param>
             <param name="NRU">
             (input) INTEGER
             The number of rows of the matrix U. NRU .GE. 0.
            </param>
             <param name="NCC">
             (input) INTEGER
             The number of columns of the matrix C. NCC .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the n diagonal elements of the bidiagonal matrix B.
             On exit, if INFO=0, the singular values of B in decreasing
             order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, the N-1 offdiagonal elements of the bidiagonal
             matrix B. 
             On exit, if INFO = 0, E is destroyed; if INFO .GT. 0, D and E
             will contain the diagonal and superdiagonal elements of a
             bidiagonal matrix orthogonally equivalent to the one given
             as input.
            </param>
             <param name="VT">
             (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
             On entry, an N-by-NCVT matrix VT.
             On exit, VT is overwritten by P**T * VT.
             Not referenced if NCVT = 0.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.
             LDVT .GE. max(1,N) if NCVT .GT. 0; LDVT .GE. 1 if NCVT = 0.
            </param>
             <param name="U">
             (input/output) DOUBLE PRECISION array, dimension (LDU, N)
             On entry, an NRU-by-N matrix U.
             On exit, U is overwritten by U * Q.
             Not referenced if NRU = 0.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. max(1,NRU).
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
             On entry, an N-by-NCC matrix C.
             On exit, C is overwritten by Q**T * C.
             Not referenced if NCC = 0.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C.
             LDC .GE. max(1,N) if NCC .GT. 0; LDC .GE.1 if NCC = 0.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (2*N)
             if NCVT = NRU = NCC = 0, (max(1, 4*N)) otherwise
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  If INFO = -i, the i-th argument had an illegal value
             .GT. 0:  the algorithm did not converge; D and E contain the
             elements of a bidiagonal matrix which is orthogonally
             similar to the input matrix B;  if INFO = i, i
             elements of E have not converged to zero.
            </param>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeF">
            <summary>
            F  - ROUGH ESTIMATE OF FUNCTION VALUE AT SOLUTION
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeW">
            <summary>
            W      - (REAL*8) WORK VECTOR OF LENGTH AT LEAST 14*N
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeLW">
            <summary>
            (INTEGER) THE DECLARED DIMENSION OF W
            W      - (REAL*8) WORK VECTOR OF LENGTH AT LEAST 14*N
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeMAXIT">
            <summary>
            MAXIMUM NUMBER OF INNER ITERATIONS PER STEP
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeMSGLVL">
            <summary>
            DETERMINES QUANTITY OF PRINTED OUTPUT, 0 = NONE, 1 = ONE LINE PER MAJOR ITERATION.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeETA">
            <summary>
            SEVERITY OF THE LINESEARCH
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeSTEPMX">
            <summary>
            MAXIMUM ALLOWABLE STEP IN THE LINESEARCH
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.TNDriver.MeIPIVOT">
            <summary>
            WORK VECTOR OF LENGTH AT LEAST N, USED
            TO RECORD WHICH VARIABLES ARE AT THEIR BOUNDS.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.TN.TNDriver.ETA">
            <summary>
            SEVERITY OF THE LINESEARCH
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.TN.TNDriver.STEPMX">
            <summary>
            MAXIMUM ALLOWABLE STEP IN THE LINESEARCH
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TN.SFUN.MeFunEvaluations">
            <summary>
            The number of function evaluations used to compute the minimum.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.TN.SFUN.FunEvaluations">
            <summary>
            The number of function evaluations used to compute the minimum.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.FREEV.Run(System.Int32,System.Int32@,System.Int32[]@,System.Int32,System.Int32@,System.Int32@,System.Int32[]@,System.Int32,System.Int32[],System.Int32,System.Boolean@,System.Boolean,System.Boolean,System.Int32,System.Int32)">
             <param name="INDEX">
             is an integer array of dimension n
             for i=1,...,nfree, index(i) are the indices of free variables
             for i=nfree+1,...,n, index(i) are the indices of bound variables
             On entry after the first iteration, index gives 
             the free variables at the previous iteration.
             On exit it gives the free variables based on the determination
             in cauchy using the array iwhere.
            </param>
             <param name="INDX2">
             is an integer array of dimension n
             On entry indx2 is unspecified.
             On exit with iter.GT.0, indx2 indicates which variables
             have changed status since the previous iteration.
             For i= 1,...,nenter, indx2(i) have changed from bound to free.
             For i= ileave+1,...,n, indx2(i) have changed from free to bound.
             
             
             *  *  *
            </param>
             <param name="CNSTND">
             is a logical variable indicating whether bounds are present
            </param>
             <param name="ITER">
             .GT. 0, and finds the index set of free and active variables
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.LinearEquations">
            <summary>
            Computes the solution to a system of linear equations.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.#ctor">
            <summary>
            Initializes a new instance of the LinearEquations class.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Computes the solution to a real system of linear equations A * X = B, where A is a general matrix. 
            </summary>
            <param name="A">The square matrix.</param>
            <param name="B">The vector containing the right-hand side of the linear system.</param>
            <returns>A vector containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(System.Double[0:,0:],System.Double[])">
            <summary>
            Computes the solution to a real system of linear equations A * X = B, where A is a general matrix. 
            </summary>
            <param name="A">The square matrix.</param>
            <param name="B">The vector containing the right-hand side of the linear system.</param>
            <returns>A vector containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the solution to a real system of linear equations A * X = B, where A is a general matrix. 
            </summary>
            <param name="A">The square matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.SolveInplace(DotNumerics.LinearAlgebra.Matrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            In place, Computes the solution to a real system of linear equations A * X = B
            </summary>
            <param name="A">The square matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(DotNumerics.LinearAlgebra.BandMatrix,DotNumerics.LinearAlgebra.Vector)">
            <summary>
            Computes the solution to a real system of linear equations
            A * X = B, where A is a band matrix.
            </summary>
            <param name="A">The band matrix.</param>
            <param name="B">The vector containing the right-hand side of the linear system.</param>
            <returns>A vector containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(DotNumerics.LinearAlgebra.BandMatrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the solution to a real system of linear equations
            A * X = B, where A is a band matrix.
            </summary>
            <param name="A">The band matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution to the linear system of equations.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.LinearEquations.Solve(DotNumerics.LinearAlgebra.TridiagonalMatrix,DotNumerics.LinearAlgebra.Matrix)">
            <summary>
            Computes the solution to a real system of linear equations
            A * X = B, where A is a tridiagonal matrix.
            </summary>
            <param name="A">The tridiagonal matrix.</param>
            <param name="B">The matrix containing the right-hand side of the linear system.</param>
            <returns>A matrix containing the solution to the linear system of equations.</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTREVC">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTREVC computes some or all of the right and/or left eigenvectors of
             a real upper quasi-triangular matrix T.
             Matrices of this type are produced by the Schur factorization of
             a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
             
             The right eigenvector x and the left eigenvector y of T corresponding
             to an eigenvalue w are defined by:
             
             T*x = w*x,     (y**H)*T = w*(y**H)
             
             where y**H denotes the conjugate transpose of y.
             The eigenvalues are not input to this routine, but are read directly
             from the diagonal blocks of T.
             
             This routine returns the matrices X and/or Y of right and left
             eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
             input matrix.  If Q is the orthogonal factor that reduces a matrix
             A to Schur form T, then Q*X and Q*Y are the matrices of right and
             left eigenvectors of A.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTREVC.Run(System.String,System.String,System.Boolean[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTREVC computes some or all of the right and/or left eigenvectors of
             a real upper quasi-triangular matrix T.
             Matrices of this type are produced by the Schur factorization of
             a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
             
             The right eigenvector x and the left eigenvector y of T corresponding
             to an eigenvalue w are defined by:
             
             T*x = w*x,     (y**H)*T = w*(y**H)
             
             where y**H denotes the conjugate transpose of y.
             The eigenvalues are not input to this routine, but are read directly
             from the diagonal blocks of T.
             
             This routine returns the matrices X and/or Y of right and left
             eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
             input matrix.  If Q is the orthogonal factor that reduces a matrix
             A to Schur form T, then Q*X and Q*Y are the matrices of right and
             left eigenvectors of A.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'R':  compute right eigenvectors only;
             = 'L':  compute left eigenvectors only;
             = 'B':  compute both right and left eigenvectors.
            </param>
             <param name="HOWMNY">
             (input) CHARACTER*1
             = 'A':  compute all right and/or left eigenvectors;
             = 'B':  compute all right and/or left eigenvectors,
             backtransformed by the matrices in VR and/or VL;
             = 'S':  compute selected right and/or left eigenvectors,
             as indicated by the logical array SELECT.
            </param>
             <param name="SELECT">
             (input/output) LOGICAL array, dimension (N)
             If HOWMNY = 'S', SELECT specifies the eigenvectors to be
             computed.
             If w(j) is a real eigenvalue, the corresponding real
             eigenvector is computed if SELECT(j) is .TRUE..
             If w(j) and w(j+1) are the real and imaginary parts of a
             complex eigenvalue, the corresponding complex eigenvector is
             computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
             on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
             .FALSE..
             Not referenced if HOWMNY = 'A' or 'B'.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix T. N .GE. 0.
            </param>
             <param name="T">
             (input) DOUBLE PRECISION array, dimension (LDT,N)
             The upper quasi-triangular matrix T in Schur canonical form.
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. max(1,N).
            </param>
             <param name="VL">
             (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
             On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
             contain an N-by-N matrix Q (usually the orthogonal matrix Q
             of Schur vectors returned by DHSEQR).
             On exit, if SIDE = 'L' or 'B', VL contains:
             if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
             if HOWMNY = 'B', the matrix Q*Y;
             if HOWMNY = 'S', the left eigenvectors of T specified by
             SELECT, stored consecutively in the columns
             of VL, in the same order as their
             eigenvalues.
             A complex eigenvector corresponding to a complex eigenvalue
             is stored in two consecutive columns, the first holding the
             real part, and the second the imaginary part.
             Not referenced if SIDE = 'R'.
            </param>
             <param name="LDVL">
             (input) INTEGER
             The leading dimension of the array VL.  LDVL .GE. 1, and if
             SIDE = 'L' or 'B', LDVL .GE. N.
            </param>
             <param name="VR">
             (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
             On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
             contain an N-by-N matrix Q (usually the orthogonal matrix Q
             of Schur vectors returned by DHSEQR).
             On exit, if SIDE = 'R' or 'B', VR contains:
             if HOWMNY = 'A', the matrix X of right eigenvectors of T;
             if HOWMNY = 'B', the matrix Q*X;
             if HOWMNY = 'S', the right eigenvectors of T specified by
             SELECT, stored consecutively in the columns
             of VR, in the same order as their
             eigenvalues.
             A complex eigenvector corresponding to a complex eigenvalue
             is stored in two consecutive columns, the first holding the
             real part and the second the imaginary part.
             Not referenced if SIDE = 'L'.
            </param>
             <param name="LDVR">
             (input) INTEGER
             The leading dimension of the array VR.  LDVR .GE. 1, and if
             SIDE = 'R' or 'B', LDVR .GE. N.
            </param>
             <param name="MM">
             (input) INTEGER
             The number of columns in the arrays VL and/or VR. MM .GE. M.
            </param>
             <param name="M">
             (output) INTEGER
             The number of columns in the arrays VL and/or VR actually
             used to store the eigenvectors.
             If HOWMNY = 'A' or 'B', M is set to N.
             Each selected real eigenvector occupies one column and each
             selected complex eigenvector occupies two columns.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (3*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORML2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORML2 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORML2.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORML2 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q or Q' from the Left
             = 'R': apply Q or Q' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply Q  (No transpose)
             = 'T': apply Q' (Transpose)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGELQF in the first k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGELQF.
            </param>
             <param name="C">
             * Q  if SIDE = 'R' and TRANS = 'N', or
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L',
             (M) if SIDE = 'R'
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGBR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGBR generates one of the real orthogonal matrices Q or P**T
             determined by DGEBRD when reducing a real matrix A to bidiagonal
             form: A = Q * B * P**T.  Q and P**T are defined as products of
             elementary reflectors H(i) or G(i) respectively.
             
             If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
             is of order M:
             if m .GE. k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
             columns of Q, where m .GE. n .GE. k;
             if m .LT. k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
             M-by-M matrix.
             
             If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
             is of order N:
             if k .LT. n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
             rows of P**T, where n .GE. m .GE. k;
             if k .GE. n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
             an N-by-N matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGBR.Run(System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGBR generates one of the real orthogonal matrices Q or P**T
             determined by DGEBRD when reducing a real matrix A to bidiagonal
             form: A = Q * B * P**T.  Q and P**T are defined as products of
             elementary reflectors H(i) or G(i) respectively.
             
             If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
             is of order M:
             if m .GE. k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
             columns of Q, where m .GE. n .GE. k;
             if m .LT. k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
             M-by-M matrix.
             
             If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
             is of order N:
             if k .LT. n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
             rows of P**T, where n .GE. m .GE. k;
             if k .GE. n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
             an N-by-N matrix.
             
            </summary>
             <param name="VECT">
             (input) CHARACTER*1
             Specifies whether the matrix Q or the matrix P**T is
             required, as defined in the transformation applied by DGEBRD:
             = 'Q':  generate Q;
             = 'P':  generate P**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q or P**T to be returned.
             M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q or P**T to be returned.
             N .GE. 0.
             If VECT = 'Q', M .GE. N .GE. min(M,K);
             if VECT = 'P', N .GE. M .GE. min(N,K).
            </param>
             <param name="K">
             (input) INTEGER
             If VECT = 'Q', the number of columns in the original M-by-K
             matrix reduced by DGEBRD.
             If VECT = 'P', the number of rows in the original K-by-N
             matrix reduced by DGEBRD.
             K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the vectors which define the elementary reflectors,
             as returned by DGEBRD.
             On exit, the M-by-N matrix Q or P**T.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension
             (min(M,K)) if VECT = 'Q'
             (min(N,K)) if VECT = 'P'
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i) or G(i), which determines Q or P**T, as
             returned by DGEBRD in its array argument TAUQ or TAUP.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,min(M,N)).
             For optimum performance LWORK .GE. min(M,N)*NB, where NB
             is the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASQ5">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASQ5 computes one dqds transform in ping-pong form, one
             version for IEEE machines another for non IEEE machines.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASQ5.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Boolean)">
             <summary>
             Purpose
             =======
             
             DLASQ5 computes one dqds transform in ping-pong form, one
             version for IEEE machines another for non IEEE machines.
             
            </summary>
             <param name="I0">
             (input) INTEGER
             First index.
            </param>
             <param name="N0">
             (input) INTEGER
             Last index.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
             an extra argument.
            </param>
             <param name="PP">
             (input) INTEGER
             PP=0 for ping, PP=1 for pong.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION
             This is the shift.
            </param>
             <param name="DMIN">
             (output) DOUBLE PRECISION
             Minimum value of d.
            </param>
             <param name="DMIN1">
             (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).
            </param>
             <param name="DMIN2">
             (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).
            </param>
             <param name="DN">
             (output) DOUBLE PRECISION
             d(N0), the last value of d.
            </param>
             <param name="DNM1">
             (output) DOUBLE PRECISION
             d(N0-1).
            </param>
             <param name="DNM2">
             (output) DOUBLE PRECISION
             d(N0-2).
            </param>
             <param name="IEEE">
             (input) LOGICAL
             Flag for IEEE or non IEEE arithmetic.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAIC1">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAIC1 applies one step of incremental condition estimation in
             its simplest version:
             
             Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
             lower triangular matrix L, such that
             twonorm(L*x) = sest
             Then DLAIC1 computes sestpr, s, c such that
             the vector
             [ s*x ]
             xhat = [  c  ]
             is an approximate singular vector of
             [ L     0  ]
             Lhat = [ w' gamma ]
             in the sense that
             twonorm(Lhat*xhat) = sestpr.
             
             Depending on JOB, an estimate for the largest or smallest singular
             value is computed.
             
             Note that [s c]' and sestpr**2 is an eigenpair of the system
             
             diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
             [ gamma ]
             
             where  alpha =  x'*w.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAIC1.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double,System.Double[],System.Int32,System.Double,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAIC1 applies one step of incremental condition estimation in
             its simplest version:
             
             Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
             lower triangular matrix L, such that
             twonorm(L*x) = sest
             Then DLAIC1 computes sestpr, s, c such that
             the vector
             [ s*x ]
             xhat = [  c  ]
             is an approximate singular vector of
             [ L     0  ]
             Lhat = [ w' gamma ]
             in the sense that
             twonorm(Lhat*xhat) = sestpr.
             
             Depending on JOB, an estimate for the largest or smallest singular
             value is computed.
             
             Note that [s c]' and sestpr**2 is an eigenpair of the system
             
             diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
             [ gamma ]
             
             where  alpha =  x'*w.
             
            </summary>
             <param name="JOB">
             (input) INTEGER
             = 1: an estimate for the largest singular value is computed.
             = 2: an estimate for the smallest singular value is computed.
            </param>
             <param name="J">
             (input) INTEGER
             Length of X and W
            </param>
             <param name="X">
             (input) DOUBLE PRECISION array, dimension (J)
             The j-vector x.
            </param>
             <param name="SEST">
             (input) DOUBLE PRECISION
             Estimated singular value of j by j matrix L
            </param>
             <param name="W">
             (input) DOUBLE PRECISION array, dimension (J)
             The j-vector w.
            </param>
             <param name="GAMMA">
             (input) DOUBLE PRECISION
             The diagonal element gamma.
            </param>
             <param name="SESTPR">
             (output) DOUBLE PRECISION
             Estimated singular value of (j+1) by (j+1) matrix Lhat.
            </param>
             <param name="S">
             (output) DOUBLE PRECISION
             Sine needed in forming xhat.
            </param>
             <param name="C">
             (output) DOUBLE PRECISION
             Cosine needed in forming xhat.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAGS2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
             that if ( UPPER ) then
             
             U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
             ( 0  A3 )     ( x  x  )
             and
             V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
             ( 0  B3 )     ( x  x  )
             
             or if ( .NOT.UPPER ) then
             
             U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
             ( A2 A3 )     ( 0  x  )
             and
             V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
             ( B2 B3 )     ( 0  x  )
             
             The rows of the transformed A and B are parallel, where
             
             U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
             ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
             
             Z' denotes the transpose of Z.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAGS2.Run(System.Boolean,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
             that if ( UPPER ) then
             
             U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
             ( 0  A3 )     ( x  x  )
             and
             V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
             ( 0  B3 )     ( x  x  )
             
             or if ( .NOT.UPPER ) then
             
             U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
             ( A2 A3 )     ( 0  x  )
             and
             V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
             ( B2 B3 )     ( 0  x  )
             
             The rows of the transformed A and B are parallel, where
             
             U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
             ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
             
             Z' denotes the transpose of Z.
            </summary>
             <param name="UPPER">
             (input) LOGICAL
             = .TRUE.: the input matrices A and B are upper triangular.
             = .FALSE.: the input matrices A and B are lower triangular.
            </param>
             <param name="A1">
             (input) DOUBLE PRECISION
            </param>
             <param name="A2">
             (input) DOUBLE PRECISION
            </param>
             <param name="A3">
             (input) DOUBLE PRECISION
             On entry, A1, A2 and A3 are elements of the input 2-by-2
             upper (lower) triangular matrix A.
            </param>
             <param name="B1">
             (input) DOUBLE PRECISION
            </param>
             <param name="B2">
             (input) DOUBLE PRECISION
            </param>
             <param name="B3">
             (input) DOUBLE PRECISION
             On entry, B1, B2 and B3 are elements of the input 2-by-2
             upper (lower) triangular matrix B.
            </param>
             <param name="CSU">
             (output) DOUBLE PRECISION
            </param>
             <param name="SNU">
             (output) DOUBLE PRECISION
             The desired orthogonal matrix U.
            </param>
             <param name="CSV">
             (output) DOUBLE PRECISION
            </param>
             <param name="SNV">
             (output) DOUBLE PRECISION
             The desired orthogonal matrix V.
            </param>
             <param name="CSQ">
             (output) DOUBLE PRECISION
            </param>
             <param name="SNQ">
             (output) DOUBLE PRECISION
             The desired orthogonal matrix Q.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED6">
             <summary>
             -- LAPACK routine (version 3.1.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             February 2007
             Purpose
             =======
             
             DLAED6 computes the positive or negative root (closest to the origin)
             of
             z(1)        z(2)        z(3)
             f(x) =   rho + --------- + ---------- + ---------
             d(1)-x      d(2)-x      d(3)-x
             
             It is assumed that
             
             if ORGATI = .true. the root is between d(2) and d(3);
             otherwise it is between d(1) and d(2)
             
             This routine will be called by DLAED4 when necessary. In most cases,
             the root sought is the smallest in magnitude, though it might not be
             in some extremely rare situations.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED6.Run(System.Int32,System.Boolean,System.Double,System.Double[],System.Int32,System.Double[],System.Int32,System.Double,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED6 computes the positive or negative root (closest to the origin)
             of
             z(1)        z(2)        z(3)
             f(x) =   rho + --------- + ---------- + ---------
             d(1)-x      d(2)-x      d(3)-x
             
             It is assumed that
             
             if ORGATI = .true. the root is between d(2) and d(3);
             otherwise it is between d(1) and d(2)
             
             This routine will be called by DLAED4 when necessary. In most cases,
             the root sought is the smallest in magnitude, though it might not be
             in some extremely rare situations.
             
            </summary>
             <param name="KNITER">
             (input) INTEGER
             Refer to DLAED4 for its significance.
            </param>
             <param name="ORGATI">
             (input) LOGICAL
             If ORGATI is true, the needed root is between d(2) and
             d(3); otherwise it is between d(1) and d(2).  See
             DLAED4 for further details.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             Refer to the equation f(x) above.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension (3)
             D satisfies d(1) .LT. d(2) .LT. d(3).
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (3)
             Each of the elements in z must be positive.
            </param>
             <param name="FINIT">
             (input) DOUBLE PRECISION
             The value of f at 0. It is more accurate than the one
             evaluated inside this routine (if someone wants to do
             so).
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION
             The root of the equation f(x).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .GT. 0: if INFO = 1, failure to converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGSVD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGSVD computes the generalized singular value decomposition (GSVD)
             of an M-by-N real matrix A and P-by-N real matrix B:
             
             U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
             
             where U, V and Q are orthogonal matrices, and Z' is the transpose
             of Z.  Let K+L = the effective numerical rank of the matrix (A',B')',
             then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
             D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
             following structures, respectively:
             
             If M-K-L .GE. 0,
             
             K  L
             D1 =     K ( I  0 )
             L ( 0  C )
             M-K-L ( 0  0 )
             
             K  L
             D2 =   L ( 0  S )
             P-L ( 0  0 )
             
             N-K-L  K    L
             ( 0 R ) = K (  0   R11  R12 )
             L (  0    0   R22 )
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
             S = diag( BETA(K+1),  ... , BETA(K+L) ),
             C**2 + S**2 = I.
             
             R is stored in A(1:K+L,N-K-L+1:N) on exit.
             
             If M-K-L .LT. 0,
             
             K M-K K+L-M
             D1 =   K ( I  0    0   )
             M-K ( 0  C    0   )
             
             K M-K K+L-M
             D2 =   M-K ( 0  S    0  )
             K+L-M ( 0  0    I  )
             P-L ( 0  0    0  )
             
             N-K-L  K   M-K  K+L-M
             ( 0 R ) =     K ( 0    R11  R12  R13  )
             M-K ( 0     0   R22  R23  )
             K+L-M ( 0     0    0   R33  )
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(M) ),
             S = diag( BETA(K+1),  ... , BETA(M) ),
             C**2 + S**2 = I.
             
             (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
             ( 0  R22 R23 )
             in B(M-K+1:L,N+M-K-L+1:N) on exit.
             
             The routine computes C, S, R, and optionally the orthogonal
             transformation matrices U, V and Q.
             
             In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
             A and B implicitly gives the SVD of A*inv(B):
             A*inv(B) = U*(D1*inv(D2))*V'.
             If ( A',B')' has orthonormal columns, then the GSVD of A and B is
             also equal to the CS decomposition of A and B. Furthermore, the GSVD
             can be used to derive the solution of the eigenvalue problem:
             A'*A x = lambda* B'*B x.
             In some literature, the GSVD of A and B is presented in the form
             U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
             where U and V are orthogonal and X is nonsingular, D1 and D2 are
             ``diagonal''.  The former GSVD form can be converted to the latter
             form by taking the nonsingular matrix X as
             
             X = Q*( I   0    )
             ( 0 inv(R) ).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGSVD.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGSVD computes the generalized singular value decomposition (GSVD)
             of an M-by-N real matrix A and P-by-N real matrix B:
             
             U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
             
             where U, V and Q are orthogonal matrices, and Z' is the transpose
             of Z.  Let K+L = the effective numerical rank of the matrix (A',B')',
             then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
             D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
             following structures, respectively:
             
             If M-K-L .GE. 0,
             
             K  L
             D1 =     K ( I  0 )
             L ( 0  C )
             M-K-L ( 0  0 )
             
             K  L
             D2 =   L ( 0  S )
             P-L ( 0  0 )
             
             N-K-L  K    L
             ( 0 R ) = K (  0   R11  R12 )
             L (  0    0   R22 )
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
             S = diag( BETA(K+1),  ... , BETA(K+L) ),
             C**2 + S**2 = I.
             
             R is stored in A(1:K+L,N-K-L+1:N) on exit.
             
             If M-K-L .LT. 0,
             
             K M-K K+L-M
             D1 =   K ( I  0    0   )
             M-K ( 0  C    0   )
             
             K M-K K+L-M
             D2 =   M-K ( 0  S    0  )
             K+L-M ( 0  0    I  )
             P-L ( 0  0    0  )
             
             N-K-L  K   M-K  K+L-M
             ( 0 R ) =     K ( 0    R11  R12  R13  )
             M-K ( 0     0   R22  R23  )
             K+L-M ( 0     0    0   R33  )
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(M) ),
             S = diag( BETA(K+1),  ... , BETA(M) ),
             C**2 + S**2 = I.
             
             (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
             ( 0  R22 R23 )
             in B(M-K+1:L,N+M-K-L+1:N) on exit.
             
             The routine computes C, S, R, and optionally the orthogonal
             transformation matrices U, V and Q.
             
             In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
             A and B implicitly gives the SVD of A*inv(B):
             A*inv(B) = U*(D1*inv(D2))*V'.
             If ( A',B')' has orthonormal columns, then the GSVD of A and B is
             also equal to the CS decomposition of A and B. Furthermore, the GSVD
             can be used to derive the solution of the eigenvalue problem:
             A'*A x = lambda* B'*B x.
             In some literature, the GSVD of A and B is presented in the form
             U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
             where U and V are orthogonal and X is nonsingular, D1 and D2 are
             ``diagonal''.  The former GSVD form can be converted to the latter
             form by taking the nonsingular matrix X as
             
             X = Q*( I   0    )
             ( 0 inv(R) ).
             
            </summary>
             <param name="JOBU">
             (input) CHARACTER*1
             = 'U':  Orthogonal matrix U is computed;
             = 'N':  U is not computed.
            </param>
             <param name="JOBV">
             (input) CHARACTER*1
             = 'V':  Orthogonal matrix V is computed;
             = 'N':  V is not computed.
            </param>
             <param name="JOBQ">
             (input) CHARACTER*1
             = 'Q':  Orthogonal matrix Q is computed;
             = 'N':  Q is not computed.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrices A and B.  N .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of rows of the matrix B.  P .GE. 0.
            </param>
             <param name="K">
             L
            </param>
             <param name="L">
             ( 0  C )
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, A contains the triangular matrix R, or part of R.
             See Purpose for details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,N)
             On entry, the P-by-N matrix B.
             On exit, B contains the triangular matrix R if M-K-L .LT. 0.
             See Purpose for details.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,P).
            </param>
             <param name="ALPHA">
             (output) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="BETA">
             (output) DOUBLE PRECISION array, dimension (N)
             On exit, ALPHA and BETA contain the generalized singular
             value pairs of A and B;
             ALPHA(1:K) = 1,
             BETA(1:K)  = 0,
             and if M-K-L .GE. 0,
             ALPHA(K+1:K+L) = C,
             BETA(K+1:K+L)  = S,
             or if M-K-L .LT. 0,
             ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
             BETA(K+1:M) =S, BETA(M+1:K+L) =1
             and
             ALPHA(K+L+1:N) = 0
             BETA(K+L+1:N)  = 0
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU,M)
             If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
             If JOBU = 'N', U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U. LDU .GE. max(1,M) if
             JOBU = 'U'; LDU .GE. 1 otherwise.
            </param>
             <param name="V">
             (output) DOUBLE PRECISION array, dimension (LDV,P)
             If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
             If JOBV = 'N', V is not referenced.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V. LDV .GE. max(1,P) if
             JOBV = 'V'; LDV .GE. 1 otherwise.
            </param>
             <param name="Q">
             (output) DOUBLE PRECISION array, dimension (LDQ,N)
             If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
             If JOBQ = 'N', Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q. LDQ .GE. max(1,N) if
             JOBQ = 'Q'; LDQ .GE. 1 otherwise.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array,
             dimension (max(3*N,M,P)+N)
            </param>
             <param name="IWORK">
             (workspace/output) INTEGER array, dimension (N)
             On exit, IWORK stores the sorting information. More
             precisely, the following loop will sort ALPHA
             for I = K+1, min(M,K+L)
             swap ALPHA(I) and ALPHA(IWORK(I))
             endfor
             such that ALPHA(1) .GE. ALPHA(2) .GE. ... .GE. ALPHA(N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, the Jacobi-type procedure failed to
             converge.  For further details, see subroutine DTGSJA.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGESV">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGESV computes the solution to a real system of linear equations
             A * X = B,
             where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
             
             The LU decomposition with partial pivoting and row interchanges is
             used to factor A as
             A = P * L * U,
             where P is a permutation matrix, L is unit lower triangular, and U is
             upper triangular.  The factored form of A is then used to solve the
             system of equations A * X = B.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGESV.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGESV computes the solution to a real system of linear equations
             A * X = B,
             where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
             
             The LU decomposition with partial pivoting and row interchanges is
             used to factor A as
             A = P * L * U,
             where P is a permutation matrix, L is unit lower triangular, and U is
             upper triangular.  The factored form of A is then used to solve the
             system of equations A * X = B.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of linear equations, i.e., the order of the
             matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the N-by-N coefficient matrix A.
             On exit, the factors L and U from the factorization
             A = P*L*U; the unit diagonal elements of L are not stored.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (N)
             The pivot indices that define the permutation matrix P;
             row i of the matrix was interchanged with row IPIV(i).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the N-by-NRHS matrix of right hand side matrix B.
             On exit, if INFO = 0, the N-by-NRHS solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
             has been completed, but the factor U is exactly
             singular, so the solution could not be computed.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DEC.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="A">
             = MATRIX TO BE TRIANGULARIZED.
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOL.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="A">
             = TRIANGULARIZED MATRIX OBTAINED FROM DEC.
            </param>
             <param name="B">
             = RIGHT HAND SIDE VECTOR.
            </param>
             <param name="IP">
             = PIVOT VECTOR OBTAINED FROM DEC.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DECH.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             = ORDER OF MATRIX A.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="A">
             = MATRIX TO BE TRIANGULARIZED.
            </param>
             <param name="LB">
             = LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED, LB.GE.1).
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOLH.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             = ORDER OF MATRIX A.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="A">
             = TRIANGULARIZED MATRIX OBTAINED FROM DECH.
            </param>
             <param name="LB">
             = LOWER BANDWIDTH OF A.
            </param>
             <param name="B">
             = RIGHT HAND SIDE VECTOR.
            </param>
             <param name="IP">
             = PIVOT VECTOR OBTAINED FROM DEC.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DECC.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAYS  AR AND AI .
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOLC.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAYS  AR AND AI.
            </param>
             <param name="IP">
             = PIVOT VECTOR OBTAINED FROM DEC.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DECHC.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAYS  AR AND AI .
            </param>
             <param name="LB">
             = LOWER BANDWIDTH OF A (DIAGONAL NOT COUNTED), LB.GE.1.
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOLHC.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             = ORDER OF MATRIX.
            </param>
             <param name="NDIM">
             = DECLARED DIMENSION OF ARRAYS  AR AND AI.
            </param>
             <param name="LB">
             = LOWER BANDWIDTH OF A.
            </param>
             <param name="IP">
             = PIVOT VECTOR OBTAINED FROM DEC.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DECB.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             ORDER OF THE ORIGINAL MATRIX A.
            </param>
             <param name="NDIM">
             DECLARED DIMENSION OF ARRAY  A.
            </param>
             <param name="A">
             CONTAINS THE MATRIX IN BAND STORAGE.   THE COLUMNS  
             OF THE MATRIX ARE STORED IN THE COLUMNS OF  A  AND
             THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS 
             ML+1 THROUGH 2*ML+MU+1 OF  A.
            </param>
             <param name="ML">
             LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="MU">
             UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="IP">
             INDEX VECTOR OF PIVOT INDICES.
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOLB.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             ORDER OF MATRIX A.
            </param>
             <param name="NDIM">
             DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="A">
             TRIANGULARIZED MATRIX OBTAINED FROM DECB.
            </param>
             <param name="ML">
             LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="MU">
             UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="B">
             RIGHT HAND SIDE VECTOR.
            </param>
             <param name="IP">
             PIVOT VECTOR OBTAINED FROM DECB.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.DECBC.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <param name="N">
             ORDER OF THE ORIGINAL MATRIX A.
            </param>
             <param name="NDIM">
             DECLARED DIMENSION OF ARRAY  A.
            </param>
             <param name="ML">
             LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="MU">
             UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="IP">
             INDEX VECTOR OF PIVOT INDICES.
            </param>
             <param name="IER">
             = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE
             SINGULAR AT STAGE K.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.SOLBC.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[],System.Int32)">
             <param name="N">
             ORDER OF MATRIX A.
            </param>
             <param name="NDIM">
             DECLARED DIMENSION OF ARRAY  A .
            </param>
             <param name="ML">
             LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="MU">
             UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED).
            </param>
             <param name="IP">
             PIVOT VECTOR OBTAINED FROM DECBC.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.Radau5.ELMHES.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement;
            </param>
             <param name="N">
             is the order of the matrix;
            </param>
             <param name="LOW">
             and igh are integers determined by the balancing
             subroutine  balanc.      if  balanc  has not been used,
             set low=1, igh=n;
            </param>
             <param name="A">
             contains the input matrix.
            </param>
             <param name="INT">
             contains information on the rows and columns
             interchanged in the reduction.
             only elements low through igh are used.
            </param>
        </member>
        <member name="T:DotNumerics.Optimization.TruncatedNewton">
            <summary>
            Minimization a multivariate function using a Truncated Newton algorithm. This class can be used for unconstrained and bounded constrained minimization.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TruncatedNewton._Accuracy">
            <summary>
            The accuracy of the computed function values.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TruncatedNewton._SearchSeverity">
            <summary>
            The severity of the linesearch.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.TruncatedNewton._MaximunStep">
            <summary>
            The maximum allowable step in the linesearch.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.TruncatedNewton.#ctor">
            <summary>
            Initializes a new instance of the MinTruncatedNewton class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.TruncatedNewton.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,System.Double[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="initialGuess">Array of size N containing the initial guess. N is the number of variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.TruncatedNewton.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,DotNumerics.Optimization.OptVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.TruncatedNewton.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptMultivariateGradient,DotNumerics.Optimization.OptBoundVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="gradient">A delegate that computes the gradient.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="P:DotNumerics.Optimization.TruncatedNewton.Accuracy">
            <summary>
            The accuracy of the computed function values.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.TruncatedNewton.SearchSeverity">
            <summary>
            The severity of the linesearch.
            </summary>
        </member>
        <member name="P:DotNumerics.Optimization.TruncatedNewton.MaximunStep">
            <summary>
            The maximum allowable step in the linesearch.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.SETULB.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double@,System.Double[]@,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,DotNumerics.Optimization.LBFGSB.BFGSTask@,System.Int32,DotNumerics.Optimization.LBFGSB.BFGSTask@,System.Boolean[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32)">
             <param name="N">
             is an integer variable.
             On entry n is the dimension of the problem.
             On exit n is unchanged.
            </param>
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric corrections
             used to define the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="X">
             is a double precision array of dimension n.
             On entry x is an approximation to the solution.
             On exit x is the current approximation.
            </param>
             <param name="L">
             is a double precision array of dimension n.
             On entry l is the lower bound on x.
             On exit l is unchanged.
            </param>
             <param name="U">
             is a double precision array of dimension n.
             On entry u is the upper bound on x.
             On exit u is unchanged.
            </param>
             <param name="NBD">
             is an integer array of dimension n.
             On entry nbd represents the type of bounds imposed on the
             variables, and must be specified as follows:
             nbd(i)=0 if x(i) is unbounded,
             1 if x(i) has only a lower bound,
             2 if x(i) has both lower and upper bounds, and
             3 if x(i) has only an upper bound.
             On exit nbd is unchanged.
            </param>
             <param name="F">
             is a double precision variable.
             On first entry f is unspecified.
             On final exit f is the value of the function at x.
            </param>
             <param name="G">
             is a double precision array of dimension n.
             On first entry g is unspecified.
             On final exit g is the value of the gradient at x.
            </param>
             <param name="FACTR">
             is a double precision variable.
             On entry factr .GE. 0 is specified by the user.  The iteration
             will stop when
             
             (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} .LE. factr*epsmch
             
             where epsmch is the machine precision, which is automatically
             generated by the code. Typical values for factr: 1.d+12 for
             low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
             high accuracy.
             On exit factr is unchanged.
            </param>
             <param name="PGTOL">
             is a double precision variable.
             On entry pgtol .GE. 0 is specified by the user.  The iteration
             will stop when
             
             max{|proj g_i | i = 1, ..., n} .LE. pgtol
             
             where pg_i is the ith component of the projected gradient.   
             On exit pgtol is unchanged.
            </param>
             <param name="WA">
             is a double precision working array of length 
             (2mmax + 4)nmax + 12mmax^2 + 12mmax.
            </param>
             <param name="IWA">
             is an integer working array of length 3nmax.
            </param>
             <param name="TASK">
             is a working string of characters of length 60 indicating
             the current job when entering and quitting this subroutine.
            </param>
             <param name="IPRINT">
             is an integer variable that must be set by the user.
             It controls the frequency and type of output generated:
             iprint.LT.0    no output is generated;
             iprint=0    print only one line at the last iteration;
             0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
             iprint=99   print details of every iteration except n-vectors;
             iprint=100  print also the changes of active set and final x;
             iprint.GT.100  print details of every iteration including x and g;
             When iprint .GT. 0, the file iterate.dat will be created to
             summarize the iteration.
            </param>
             <param name="CSAVE">
             is a working string of characters of length 60.
            </param>
             <param name="LSAVE">
             is a logical working array of dimension 4.
             On exit with 'task' = NEW_X, the following information is 
             available:
             If lsave(1) = .true.  then  the initial X has been replaced by
             its projection in the feasible set;
             If lsave(2) = .true.  then  the problem is constrained;
             If lsave(3) = .true.  then  each variable has upper and lower
             bounds;
            </param>
             <param name="ISAVE">
             is an integer working array of dimension 44.
             On exit with 'task' = NEW_X, the following information is 
             available:
             isave(22) = the total number of intervals explored in the 
             search of Cauchy points;
             isave(26) = the total number of skipped BFGS updates before 
             the current iteration;
             isave(30) = the number of current iteration;
             isave(31) = the total number of BFGS updates prior the current
             iteration;
             isave(33) = the number of intervals explored in the search of
             Cauchy point in the current iteration;
             isave(34) = the total number of function and gradient 
             evaluations;
             isave(36) = the number of function value or gradient
             evaluations in the current iteration;
             if isave(37) = 0  then the subspace argmin is within the box;
             if isave(37) = 1  then the subspace argmin is beyond the box;
             isave(38) = the number of free variables in the current
             iteration;
             isave(39) = the number of active constraints in the current
             iteration;
             n + 1 - isave(40) = the number of variables leaving the set of
             active constraints in the current iteration;
             isave(41) = the number of variables entering the set of active
             constraints in the current iteration.
            </param>
             <param name="DSAVE">
             is a double precision working array of dimension 29.
             On exit with 'task' = NEW_X, the following information is
             available:
             dsave(1) = current 'theta' in the BFGS matrix;
             dsave(2) = f(x) in the previous iteration;
             dsave(3) = factr*epsmch;
             dsave(4) = 2-norm of the line search direction vector;
             dsave(5) = the machine precision epsmch generated by the code;
             dsave(7) = the accumulated time spent on searching for
             Cauchy points;
             dsave(8) = the accumulated time spent on
             subspace minimization;
             dsave(9) = the accumulated time spent on line search;
             dsave(11) = the slope of the line search function at
             the current point of line search;
             dsave(12) = the maximum relative step length imposed in
             line search;
             dsave(13) = the infinity norm of the projected gradient;
             dsave(14) = the relative step length in the line search;
             dsave(15) = the slope of the line search function at
             the starting point of the line search;
             dsave(16) = the square of the 2-norm of the line search
             direction vector.
            </param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.DTRSL.Run(System.Double[],System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <param name="T">
             * x = b
            </param>
             <param name="LDT">
             integer
             ldt is the leading dimension of the array t.
            </param>
             <param name="N">
             integer
             n is the order of the system.
            </param>
             <param name="B">
             double precision(n).
             b contains the right hand side of the system.
            </param>
             <param name="JOB">
             integer
             job specifies what kind of system is to be solved.
             if job is
             
             00   solve t*x=b, t lower triangular,
             01   solve t*x=b, t upper triangular,
             10   solve trans(t)*x=b, t lower triangular,
             11   solve trans(t)*x=b, t upper triangular.
            </param>
             <param name="INFO">
             integer
             info contains zero if the system is nonsingular.
             otherwise info contains the index of
             the first zero diagonal element of t.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.SymmetricBandMatrix">
            <summary>
            Represents a  symmetric band matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the SymmetricBandMatrix class of the given size.
            </summary>
            <param name="size">Size</param>
            <param name="BandWidth">Number of bands below or above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the SymmetricBandMatrix class of the given size using a array
            </summary>
            <param name="size">Size</param>
            <param name="BandWidth">Number of bands below or above the main diagonal</param>
            <param name="Data">The matix data </param>>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.Clone">
            <summary>
            Creates a copy of the matrix.
            </summary>
            <returns>The copy of the Matrix.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.Random(System.Int32,System.Int32)">
            <summary>Generate a BandMatrix with random elements</summary>
            <param name="size">Size</param>
            <param name="BandWidth">Number of bands below or above the main diagonal</param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.op_Addition(DotNumerics.LinearAlgebra.SymmetricBandMatrix,DotNumerics.LinearAlgebra.SymmetricBandMatrix)">
            <summary>
            Matrix addition.
            </summary>
            <param name="A">The left side matrix of the addition operator.</param>
            <param name="B">The right side matrix of the addition operator.</param>
            <returns>A matrix that represents the result of the matrix addition.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.op_Subtraction(DotNumerics.LinearAlgebra.SymmetricBandMatrix,DotNumerics.LinearAlgebra.SymmetricBandMatrix)">
            <summary>
            Matrix subtraction.
            </summary>
            <param name="A"> The left side matrix of the subtraction operator.</param>
            <param name="B">The right side matrix of the subtraction operator.</param>
            <returns>A matrix that represents the result of the matrix subtraction.</returns>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.SymmetricBandMatrix.op_Multiply(System.Double,DotNumerics.LinearAlgebra.SymmetricBandMatrix)">
            <summary>
            Scalar-Matrix multiplication.
            </summary>
            <param name="s"> The left side scalar of the multiplication operator.</param>
            <param name="A">The right side matrix of the multiplication operator.</param>
            <returns>A matrix that represents the result of the multiplication.</returns>
        </member>
        <member name="P:DotNumerics.LinearAlgebra.SymmetricBandMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of a element of the matrix.
            </summary>
            <param name="row">The row value (zero-based).</param>
            <param name="column">The column value (zero-based).</param>
            <returns>The matrix value at (row, column).</returns>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRCON">
             <summary>
             -- LAPACK routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             March 31, 1993
             Purpose
             =======
             
             DTRCON estimates the reciprocal of the condition number of a
             triangular matrix A, in either the 1-norm or the infinity-norm.
             
             The norm of A is computed and an estimate is obtained for
             norm(inv(A)), then the reciprocal of the condition number is
             computed as
             RCOND = 1 / ( norm(A) * norm(inv(A)) ).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRCON.Run(System.String,System.String,System.String,System.Int32,System.Double[],System.Int32,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTRCON estimates the reciprocal of the condition number of a
             triangular matrix A, in either the 1-norm or the infinity-norm.
             
             The norm of A is computed and an estimate is obtained for
             norm(inv(A)), then the reciprocal of the condition number is
             computed as
             RCOND = 1 / ( norm(A) * norm(inv(A)) ).
             
            </summary>
             <param name="NORM">
             (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
             = '1' or 'O':  1-norm;
             = 'I':         Infinity-norm.
            </param>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  A is upper triangular;
             = 'L':  A is lower triangular.
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             = 'N':  A is non-unit triangular;
             = 'U':  A is unit triangular.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             The triangular matrix A.  If UPLO = 'U', the leading N-by-N
             upper triangular part of the array A contains the upper
             triangular matrix, and the strictly lower triangular part of
             A is not referenced.  If UPLO = 'L', the leading N-by-N lower
             triangular part of the array A contains the lower triangular
             matrix, and the strictly upper triangular part of A is not
             referenced.  If DIAG = 'U', the diagonal elements of A are
             also not referenced and are assumed to be 1.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="RCOND">
             (output) DOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (3*N)
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGTR">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGTR generates a real orthogonal matrix Q which is defined as the
             product of n-1 elementary reflectors of order N, as returned by
             DSYTRD:
             
             if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
             
             if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGTR.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGTR generates a real orthogonal matrix Q which is defined as the
             product of n-1 elementary reflectors of order N, as returned by
             DSYTRD:
             
             if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
             
             if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U': Upper triangle of A contains elementary reflectors
             from DSYTRD;
             = 'L': Lower triangle of A contains elementary reflectors
             from DSYTRD.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix Q. N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the vectors which define the elementary reflectors,
             as returned by DSYTRD.
             On exit, the N-by-N orthogonal matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (N-1)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DSYTRD.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N-1).
             For optimum performance LWORK .GE. (N-1)*NB, where NB is
             the optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD8">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD8 finds the square roots of the roots of the secular equation,
             as defined by the values in DSIGMA and Z. It makes the appropriate
             calls to DLASD4, and stores, for each  element in D, the distance
             to its two nearest poles (elements in DSIGMA). It also updates
             the arrays VF and VL, the first and last components of all the
             right singular vectors of the original bidiagonal matrix.
             
             DLASD8 is called from DLASD6.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD8.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD8 finds the square roots of the roots of the secular equation,
             as defined by the values in DSIGMA and Z. It makes the appropriate
             calls to DLASD4, and stores, for each  element in D, the distance
             to its two nearest poles (elements in DSIGMA). It also updates
             the arrays VF and VL, the first and last components of all the
             right singular vectors of the original bidiagonal matrix.
             
             DLASD8 is called from DLASD6.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether singular vectors are to be computed in
             factored form in the calling routine:
             = 0: Compute singular values only.
             = 1: Compute singular vectors in factored form as well.
            </param>
             <param name="K">
             (input) INTEGER
             The number of terms in the rational function to be solved
             by DLASD4.  K .GE. 1.
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension ( K )
             On output, D contains the updated singular values.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( K )
             The first K elements of this array contain the components
             of the deflation-adjusted updating row vector.
            </param>
             <param name="VF">
             (input/output) DOUBLE PRECISION array, dimension ( K )
             On entry, VF contains  information passed through DBEDE8.
             On exit, VF contains the first K components of the first
             components of all right singular vectors of the bidiagonal
             matrix.
            </param>
             <param name="VL">
             (input/output) DOUBLE PRECISION array, dimension ( K )
             On entry, VL contains  information passed through DBEDE8.
             On exit, VL contains the first K components of the last
             components of all right singular vectors of the bidiagonal
             matrix.
            </param>
             <param name="DIFL">
             (output) DOUBLE PRECISION array, dimension ( K )
             On exit, DIFL(I) = D(I) - DSIGMA(I).
            </param>
             <param name="DIFR">
             (output) DOUBLE PRECISION array,
             dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
             dimension ( K ) if ICOMPQ = 0.
             On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
             defined and will not be referenced.
             
             If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
             normalizing factors for the right singular vector matrix.
            </param>
             <param name="LDDIFR">
             (input) INTEGER
             The leading dimension of DIFR, must be at least K.
            </param>
             <param name="DSIGMA">
             (input) DOUBLE PRECISION array, dimension ( K )
             The first K elements of this array contain the old roots
             of the deflated updating problem.  These are the poles
             of the secular equation.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension at least 3 * K
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAHQR">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAHQR is an auxiliary routine called by DHSEQR to update the
             eigenvalues and Schur decomposition already computed by DHSEQR, by
             dealing with the Hessenberg submatrix in rows and columns ILO to
             IHI.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAHQR.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAHQR is an auxiliary routine called by DHSEQR to update the
             eigenvalues and Schur decomposition already computed by DHSEQR, by
             dealing with the Hessenberg submatrix in rows and columns ILO to
             IHI.
             
            </summary>
             <param name="WANTT">
             (input) LOGICAL
             = .TRUE. : the full Schur form T is required;
             = .FALSE.: only eigenvalues are required.
            </param>
             <param name="WANTZ">
             (input) LOGICAL
             = .TRUE. : the matrix of Schur vectors Z is required;
             = .FALSE.: Schur vectors are not required.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that H is already upper quasi-triangular in
             rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
             ILO = 1). DLAHQR works primarily with the Hessenberg
             submatrix in rows and columns ILO to IHI, but applies
             transformations to all of H if WANTT is .TRUE..
             1 .LE. ILO .LE. max(1,IHI); IHI .LE. N.
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO is zero and if WANTT is .TRUE., H is upper
             quasi-triangular in rows and columns ILO:IHI, with any
             2-by-2 diagonal blocks in standard form. If INFO is zero
             and WANTT is .FALSE., the contents of H are unspecified on
             exit.  The output state of H if INFO is nonzero is given
             below under the description of INFO.
            </param>
             <param name="LDH">
             (input) INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </param>
             <param name="WR">
             (output) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="WI">
             (output) DOUBLE PRECISION array, dimension (N)
             The real and imaginary parts, respectively, of the computed
             eigenvalues ILO to IHI are stored in the corresponding
             elements of WR and WI. If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., the
             eigenvalues are stored in the same order as on the diagonal
             of the Schur form returned in H, with WR(i) = H(i,i), and, if
             H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
             WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
             If WANTZ is .TRUE., on entry Z must contain the current
             matrix Z of transformations accumulated by DHSEQR, and on
             exit Z has been updated; transformations are applied only to
             the submatrix Z(ILOZ:IHIZ,ILO:IHI).
             If WANTZ is .FALSE., Z is not referenced.
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z. LDZ .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             =   0: successful exit
             .GT. 0: If INFO = i, DLAHQR failed to compute all the
             eigenvalues ILO to IHI in a total of 30 iterations
             per eigenvalue; elements i+1:ihi of WR and WI
             contain those eigenvalues which have been
             successfully computed.
             
             If INFO .GT. 0 and WANTT is .FALSE., then on exit,
             the remaining unconverged eigenvalues are the
             eigenvalues of the upper Hessenberg matrix rows
             and columns ILO thorugh INFO of the final, output
             value of H.
             
             If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)       (initial value of H)*U  = U*(final value of H)
             where U is an orthognal matrix.    The final
             value of H is upper Hessenberg and triangular in
             rows and columns INFO+1 through IHI.
             
             If INFO .GT. 0 and WANTZ is .TRUE., then on exit
             (final value of Z)  = (initial value of Z)*U
             where U is the orthogonal matrix in (*)
             (regardless of the value of WANTT.)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED5">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This subroutine computes the I-th eigenvalue of a symmetric rank-one
             modification of a 2-by-2 diagonal matrix
             
             diag( D )  +  RHO *  Z * transpose(Z) .
             
             The diagonal elements in the array D are assumed to satisfy
             
             D(i) .LT. D(j)  for  i .LT. j .
             
             We also assume RHO .GT. 0 and that the Euclidean norm of the vector
             Z is one.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED5.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double,System.Double@)">
             <summary>
             Purpose
             =======
             
             This subroutine computes the I-th eigenvalue of a symmetric rank-one
             modification of a 2-by-2 diagonal matrix
             
             diag( D )  +  RHO *  Z * transpose(Z) .
             
             The diagonal elements in the array D are assumed to satisfy
             
             D(i) .LT. D(j)  for  i .LT. j .
             
             We also assume RHO .GT. 0 and that the Euclidean norm of the vector
             Z is one.
             
            </summary>
             <param name="I">
             (input) INTEGER
             The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension (2)
             The original eigenvalues.  We assume D(1) .LT. D(2).
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (2)
             The components of the updating vector.
            </param>
             <param name="DELTA">
             (output) DOUBLE PRECISION array, dimension (2)
             The vector DELTA contains the information necessary
             to construct the eigenvectors.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The scalar in the symmetric updating formula.
            </param>
             <param name="DLAM">
             (output) DOUBLE PRECISION
             The computed lambda_I, the I-th updated eigenvalue.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DBDSDC">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DBDSDC computes the singular value decomposition (SVD) of a real
             N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
             using a divide and conquer method, where S is a diagonal matrix
             with non-negative diagonal elements (the singular values of B), and
             U and VT are orthogonal matrices of left and right singular vectors,
             respectively. DBDSDC can be used to compute all singular values,
             and optionally, singular vectors or singular vectors in compact form.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.  See DLASD3 for details.
             
             The code currently calls DLASDQ if singular values only are desired.
             However, it can be slightly modified to compute singular values
             using the divide and conquer method.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DBDSDC.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DBDSDC computes the singular value decomposition (SVD) of a real
             N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
             using a divide and conquer method, where S is a diagonal matrix
             with non-negative diagonal elements (the singular values of B), and
             U and VT are orthogonal matrices of left and right singular vectors,
             respectively. DBDSDC can be used to compute all singular values,
             and optionally, singular vectors or singular vectors in compact form.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.  See DLASD3 for details.
             
             The code currently calls DLASDQ if singular values only are desired.
             However, it can be slightly modified to compute singular values
             using the divide and conquer method.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             = 'U':  B is upper bidiagonal.
             = 'L':  B is lower bidiagonal.
            </param>
             <param name="COMPQ">
             (input) CHARACTER*1
             Specifies whether singular vectors are to be computed
             as follows:
             = 'N':  Compute singular values only;
             = 'P':  Compute singular values and compute singular
             vectors in compact form;
             = 'I':  Compute singular values and singular vectors.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix B.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the n diagonal elements of the bidiagonal matrix B.
             On exit, if INFO=0, the singular values of B.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, the elements of E contain the offdiagonal
             elements of the bidiagonal matrix whose SVD is desired.
             On exit, E has been destroyed.
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU,N)
             If  COMPQ = 'I', then:
             On exit, if INFO = 0, U contains the left singular vectors
             of the bidiagonal matrix.
             For other values of COMPQ, U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U.  LDU .GE. 1.
             If singular vectors are desired, then LDU .GE. max( 1, N ).
            </param>
             <param name="VT">
             (output) DOUBLE PRECISION array, dimension (LDVT,N)
             If  COMPQ = 'I', then:
             On exit, if INFO = 0, VT' contains the right singular
             vectors of the bidiagonal matrix.
             For other values of COMPQ, VT is not referenced.
            </param>
             <param name="LDVT">
             (input) INTEGER
             The leading dimension of the array VT.  LDVT .GE. 1.
             If singular vectors are desired, then LDVT .GE. max( 1, N ).
            </param>
             <param name="Q">
             (output) DOUBLE PRECISION array, dimension (LDQ)
             If  COMPQ = 'P', then:
             On exit, if INFO = 0, Q and IQ contain the left
             and right singular vectors in a compact form,
             requiring O(N log N) space instead of 2*N**2.
             In particular, Q contains all the DOUBLE PRECISION data in
             LDQ .GE. N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
             words of memory, where SMLSIZ is returned by ILAENV and
             is equal to the maximum size of the subproblems at the
             bottom of the computation tree (usually about 25).
             For other values of COMPQ, Q is not referenced.
            </param>
             <param name="IQ">
             (output) INTEGER array, dimension (LDIQ)
             If  COMPQ = 'P', then:
             On exit, if INFO = 0, Q and IQ contain the left
             and right singular vectors in a compact form,
             requiring O(N log N) space instead of 2*N**2.
             In particular, IQ contains all INTEGER data in
             LDIQ .GE. N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
             words of memory, where SMLSIZ is returned by ILAENV and
             is equal to the maximum size of the subproblems at the
             bottom of the computation tree (usually about 25).
             For other values of COMPQ, IQ is not referenced.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             If COMPQ = 'N' then LWORK .GE. (4 * N).
             If COMPQ = 'P' then LWORK .GE. (6 * N).
             If COMPQ = 'I' then LWORK .GE. (3 * N**2 + 4 * N).
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (8*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  The algorithm failed to compute an singular value.
             The update process of divide and conquer failed.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.ErrorToleranceEnum">
            <summary>
            Specifies the type of the relative error and absolute error tolerances. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.ErrorToleranceEnum.Scalar">
            <summary>
            The relative error and absolute error tolerances are scalars. The program keeps the error of Y(I) below RelTol*Abs(Y[i]) + AbsTol. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.ErrorToleranceEnum.Array">
            <summary>
            The relative error and absolute error tolerances are arrays. In this case the program keeps the  error of Y(I) below RelTolArray[I]*Abs(Y(I))+AbsTolArray[i].
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.OdeFunction">
            <summary>
            Delegate defining the Ordinary Differential Equations (ODEs)  dy(i)/dt = f(i) = f(i,t,y(1),y(2),...,y(N)).
            </summary>
            <param name="t">The independent variable.</param>
            <param name="y">Array of size N containing the dependent variable values(y(1),y(2),...,y(N)).</param>
            <returns>A vector of size N, f(i) = dy(i)/dt that define the ordinary differential equations system, 
            where N is the number of differential equations.</returns>
        </member>
        <member name="T:DotNumerics.ODE.OdeJacobian">
            <summary>
            Delegate that compute the Jacobian matrix df/dy (size NxN), as a function of the scalar t and the vector y. 
            </summary>
            <param name="t">The independent variable.</param>
            <param name="y">Array of size N containing the dependent variable values(y(1),y(2),...,y(N)).</param>
            <returns>The Jacobian matrix df/dy (size NxN).</returns>
        </member>
        <member name="T:DotNumerics.ODE.OdeSolution">
            <summary>
            Delegate used for solution otput.
            </summary>
            <param name="t">The value of t where the solution is calculated.</param>
            <param name="y">A array containing the solution of the differential equations at the value t.</param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.ACTIVE.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32,System.Boolean@,System.Boolean@,System.Boolean@)">
             <param name="IWHERE">
             is an integer array of dimension n.
             On entry iwhere is unspecified.
             On exit iwhere(i)=-1  if x(i) has no bounds
             3   if l(i)=u(i)
             0   otherwise.
             In cauchy, iwhere is given finer gradations.
             
             
             *  *  *
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTREXC">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTREXC reorders the real Schur factorization of a real matrix
             A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
             moved to row ILST.
             
             The real Schur form T is reordered by an orthogonal similarity
             transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
             is updated by postmultiplying it with Z.
             
             T must be in Schur canonical form (as returned by DHSEQR), that is,
             block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
             2-by-2 diagonal block has its diagonal elements equal and its
             off-diagonal elements of opposite sign.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTREXC.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTREXC reorders the real Schur factorization of a real matrix
             A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
             moved to row ILST.
             
             The real Schur form T is reordered by an orthogonal similarity
             transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
             is updated by postmultiplying it with Z.
             
             T must be in Schur canonical form (as returned by DHSEQR), that is,
             block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
             2-by-2 diagonal block has its diagonal elements equal and its
             off-diagonal elements of opposite sign.
             
            </summary>
             <param name="COMPQ">
             (input) CHARACTER*1
             = 'V':  update the matrix Q of Schur vectors;
             = 'N':  do not update Q.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix T. N .GE. 0.
            </param>
             <param name="T">
             must be in Schur canonical form (as returned by DHSEQR), that is,
            </param>
             <param name="LDT">
             (input) INTEGER
             The leading dimension of the array T. LDT .GE. max(1,N).
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
             On exit, if COMPQ = 'V', Q has been postmultiplied by the
             orthogonal transformation matrix Z which reorders T.
             If COMPQ = 'N', Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="IFST">
             (input/output) INTEGER
            </param>
             <param name="ILST">
             (input/output) INTEGER
             Specify the reordering of the diagonal blocks of T.
             The block with row index IFST is moved to row ILST, by a
             sequence of transpositions between adjacent blocks.
             On exit, if IFST pointed on entry to the second row of a
             2-by-2 block, it is changed to point to the first row; ILST
             always points to the first row of the block in its final
             position (which may differ from its input value by +1 or -1).
             1 .LE. IFST .LE. N; 1 .LE. ILST .LE. N.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             = 1:  two adjacent blocks were too close to swap (the problem
             is very ill-conditioned); T may have been partially
             reordered, and ILST points to the first row of the
             current position of the block being moved.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTGSJA">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTGSJA computes the generalized singular value decomposition (GSVD)
             of two real upper triangular (or trapezoidal) matrices A and B.
             
             On entry, it is assumed that matrices A and B have the following
             forms, which may be obtained by the preprocessing subroutine DGGSVP
             from a general M-by-N matrix A and P-by-N matrix B:
             
             N-K-L  K    L
             A =    K ( 0    A12  A13 ) if M-K-L .GE. 0;
             L ( 0     0   A23 )
             M-K-L ( 0     0    0  )
             
             N-K-L  K    L
             A =  K ( 0    A12  A13 ) if M-K-L .LT. 0;
             M-K ( 0     0   A23 )
             
             N-K-L  K    L
             B =  L ( 0     0   B13 )
             P-L ( 0     0    0  )
             
             where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
             upper triangular; A23 is L-by-L upper triangular if M-K-L .GE. 0,
             otherwise A23 is (M-K)-by-L upper trapezoidal.
             
             On exit,
             
             U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
             
             where U, V and Q are orthogonal matrices, Z' denotes the transpose
             of Z, R is a nonsingular upper triangular matrix, and D1 and D2 are
             ``diagonal'' matrices, which are of the following structures:
             
             If M-K-L .GE. 0,
             
             K  L
             D1 =     K ( I  0 )
             L ( 0  C )
             M-K-L ( 0  0 )
             
             K  L
             D2 = L   ( 0  S )
             P-L ( 0  0 )
             
             N-K-L  K    L
             ( 0 R ) = K (  0   R11  R12 ) K
             L (  0    0   R22 ) L
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
             S = diag( BETA(K+1),  ... , BETA(K+L) ),
             C**2 + S**2 = I.
             
             R is stored in A(1:K+L,N-K-L+1:N) on exit.
             
             If M-K-L .LT. 0,
             
             K M-K K+L-M
             D1 =   K ( I  0    0   )
             M-K ( 0  C    0   )
             
             K M-K K+L-M
             D2 =   M-K ( 0  S    0   )
             K+L-M ( 0  0    I   )
             P-L ( 0  0    0   )
             
             N-K-L  K   M-K  K+L-M
             ( 0 R ) =    K ( 0    R11  R12  R13  )
             M-K ( 0     0   R22  R23  )
             K+L-M ( 0     0    0   R33  )
             
             where
             C = diag( ALPHA(K+1), ... , ALPHA(M) ),
             S = diag( BETA(K+1),  ... , BETA(M) ),
             C**2 + S**2 = I.
             
             R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
             (  0  R22 R23 )
             in B(M-K+1:L,N+M-K-L+1:N) on exit.
             
             The computation of the orthogonal transformation matrices U, V or Q
             is optional.  These matrices may either be formed explicitly, or they
             may be postmultiplied into input matrices U1, V1, or Q1.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTGSJA.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTGSJA computes the generalized singular value decomposition (GSVD)
             of two real upper triangular (or trapezoidal) matrices A and B.
             
             On entry, it is assumed that matrices A and B have the following
             forms, which may be obtained by the preprocessing subroutine DGGSVP
             from a general M-by-N matrix A and P-by-N matrix B:
             
             N-K-L  K    L
             A =    K ( 0    A12  A13 ) if M-K-L .GE. 0;
             L ( 0     0   A23 )
             M-K-L ( 0     0    0  )
             
             N-K-L  K    L
             A =  K ( 0    A12  A13 ) if M-K-L .LT. 0;
             M-K ( 0     0   A23 )
             
             N-K-L  K    L
             B =  L ( 0     0   B13 )
             P-L ( 0     0    0  )
             
             where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
             upper triangular; A23 is L-by-L upper triangular if M-K-L .GE. 0,
             otherwise A23 is (M-K)-by-L upper trapezoidal.
             
             On exit,
             
             U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
             
             where U, V and Q are orthogonal matrices, Z' denotes the transpose
             of Z, R is a nonsingular upper triangular matrix, and D1 and D2 are
             ``diagonal'' matrices, which are of the following structures:
             
             If M-K-L .GE. 0,
             
             K  L
             D1 =     K ( I  0 )
             L ( 0  C )
             M-K-L ( 0  0 )
             
             K  L
             D2 = L   ( 0  S )
             P-L ( 0  0 )
             
             N-K-L  K    L
             ( 0 R ) = K (  0   R11  R12 ) K
             L (  0    0   R22 ) L
             
             where
             
             C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
             S = diag( BETA(K+1),  ... , BETA(K+L) ),
             C**2 + S**2 = I.
             
             R is stored in A(1:K+L,N-K-L+1:N) on exit.
             
             If M-K-L .LT. 0,
             
             K M-K K+L-M
             D1 =   K ( I  0    0   )
             M-K ( 0  C    0   )
             
             K M-K K+L-M
             D2 =   M-K ( 0  S    0   )
             K+L-M ( 0  0    I   )
             P-L ( 0  0    0   )
             
             N-K-L  K   M-K  K+L-M
             ( 0 R ) =    K ( 0    R11  R12  R13  )
             M-K ( 0     0   R22  R23  )
             K+L-M ( 0     0    0   R33  )
             
             where
             C = diag( ALPHA(K+1), ... , ALPHA(M) ),
             S = diag( BETA(K+1),  ... , BETA(M) ),
             C**2 + S**2 = I.
             
             R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
             (  0  R22 R23 )
             in B(M-K+1:L,N+M-K-L+1:N) on exit.
             
             The computation of the orthogonal transformation matrices U, V or Q
             is optional.  These matrices may either be formed explicitly, or they
             may be postmultiplied into input matrices U1, V1, or Q1.
             
            </summary>
             <param name="JOBU">
             (input) CHARACTER*1
             = 'U':  U must contain an orthogonal matrix U1 on entry, and
             the product U1*U is returned;
             = 'I':  U is initialized to the unit matrix, and the
             orthogonal matrix U is returned;
             = 'N':  U is not computed.
            </param>
             <param name="JOBV">
             (input) CHARACTER*1
             = 'V':  V must contain an orthogonal matrix V1 on entry, and
             the product V1*V is returned;
             = 'I':  V is initialized to the unit matrix, and the
             orthogonal matrix V is returned;
             = 'N':  V is not computed.
            </param>
             <param name="JOBQ">
             (input) CHARACTER*1
             = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
             the product Q1*Q is returned;
             = 'I':  Q is initialized to the unit matrix, and the
             orthogonal matrix Q is returned;
             = 'N':  Q is not computed.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of rows of the matrix B.  P .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrices A and B.  N .GE. 0.
            </param>
             <param name="K">
             L
            </param>
             <param name="L">
             ( 0     0   A23 )
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
             matrix R or part of R.  See Purpose for details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,N)
             On entry, the P-by-N matrix B.
             On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
             a part of R.  See Purpose for details.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,P).
            </param>
             <param name="TOLA">
             (input) DOUBLE PRECISION
            </param>
             <param name="TOLB">
             (input) DOUBLE PRECISION
             TOLA and TOLB are the convergence criteria for the Jacobi-
             Kogbetliantz iteration procedure. Generally, they are the
             same as used in the preprocessing step, say
             TOLA = max(M,N)*norm(A)*MAZHEPS,
             TOLB = max(P,N)*norm(B)*MAZHEPS.
            </param>
             <param name="ALPHA">
             (output) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="BETA">
             (output) DOUBLE PRECISION array, dimension (N)
             On exit, ALPHA and BETA contain the generalized singular
             value pairs of A and B;
             ALPHA(1:K) = 1,
             BETA(1:K)  = 0,
             and if M-K-L .GE. 0,
             ALPHA(K+1:K+L) = diag(C),
             BETA(K+1:K+L)  = diag(S),
             or if M-K-L .LT. 0,
             ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
             BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
             Furthermore, if K+L .LT. N,
             ALPHA(K+L+1:N) = 0 and
             BETA(K+L+1:N)  = 0.
            </param>
             <param name="U">
             (input/output) DOUBLE PRECISION array, dimension (LDU,M)
             On entry, if JOBU = 'U', U must contain a matrix U1 (usually
             the orthogonal matrix returned by DGGSVP).
             On exit,
             if JOBU = 'I', U contains the orthogonal matrix U;
             if JOBU = 'U', U contains the product U1*U.
             If JOBU = 'N', U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U. LDU .GE. max(1,M) if
             JOBU = 'U'; LDU .GE. 1 otherwise.
            </param>
             <param name="V">
             (input/output) DOUBLE PRECISION array, dimension (LDV,P)
             On entry, if JOBV = 'V', V must contain a matrix V1 (usually
             the orthogonal matrix returned by DGGSVP).
             On exit,
             if JOBV = 'I', V contains the orthogonal matrix V;
             if JOBV = 'V', V contains the product V1*V.
             If JOBV = 'N', V is not referenced.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V. LDV .GE. max(1,P) if
             JOBV = 'V'; LDV .GE. 1 otherwise.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
             the orthogonal matrix returned by DGGSVP).
             On exit,
             if JOBQ = 'I', Q contains the orthogonal matrix Q;
             if JOBQ = 'Q', Q contains the product Q1*Q.
             If JOBQ = 'N', Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q. LDQ .GE. max(1,N) if
             JOBQ = 'Q'; LDQ .GE. 1 otherwise.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (2*N)
            </param>
             <param name="NCYCLE">
             (output) INTEGER
             The number of cycles required for convergence.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             = 1:  the procedure does not converge after MAXIT cycles.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSCAL">
             <summary>
             Purpose
             =======
             *
             scales a vector by a constant.
             uses unrolled loops for increment equal to one.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSCAL.Run(System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             *
             scales a vector by a constant.
             uses unrolled loops for increment equal to one.
             jack dongarra, linpack, 3/11/78.
             modified 3/93 to return if incx .le. 0.
             modified 12/3/93, array(1) declarations changed to array(*)
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMRZ">
             <summary>
             -- LAPACK routine (version 3.1.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             January 2007
             Purpose
             =======
             
             DORMRZ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMRZ.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMRZ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="L">
             (input) INTEGER
             The number of columns of the matrix A containing
             the meaningful part of the Householder reflectors.
             If SIDE = 'L', M .GE. L .GE. 0, if SIDE = 'R', N .GE. L .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DTZRZF in the last k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DTZRZF.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD7">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD7 merges the two sets of singular values together into a single
             sorted set. Then it tries to deflate the size of the problem. There
             are two ways in which deflation can occur:  when two or more singular
             values are close together or if there is a tiny entry in the Z
             vector. For each such occurrence the order of the related
             secular equation problem is reduced by one.
             
             DLASD7 is called from DLASD6.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD7.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double,System.Double,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@,System.Int32[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double@,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD7 merges the two sets of singular values together into a single
             sorted set. Then it tries to deflate the size of the problem. There
             are two ways in which deflation can occur:  when two or more singular
             values are close together or if there is a tiny entry in the Z
             vector. For each such occurrence the order of the related
             secular equation problem is reduced by one.
             
             DLASD7 is called from DLASD6.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether singular vectors are to be computed
             in compact form, as follows:
             = 0: Compute singular values only.
             = 1: Compute singular vectors of upper
             bidiagonal matrix in compact form.
            </param>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block. NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block. NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has
             N = NL + NR + 1 rows and
             M = N + SQRE .GE. N columns.
            </param>
             <param name="K">
             (output) INTEGER
             Contains the dimension of the non-deflated matrix, this is
             the order of the related secular equation. 1 .LE. K .LE.N.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension ( N )
             On entry D contains the singular values of the two submatrices
             to be combined. On exit D contains the trailing (N-K) updated
             singular values (those which were deflated) sorted into
             increasing order.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension ( M )
             On exit Z contains the updating row vector in the secular
             equation.
            </param>
             <param name="ZW">
             (workspace) DOUBLE PRECISION array, dimension ( M )
             Workspace for Z.
            </param>
             <param name="VF">
             (input/output) DOUBLE PRECISION array, dimension ( M )
             On entry, VF(1:NL+1) contains the first components of all
             right singular vectors of the upper block; and VF(NL+2:M)
             contains the first components of all right singular vectors
             of the lower block. On exit, VF contains the first components
             of all right singular vectors of the bidiagonal matrix.
            </param>
             <param name="VFW">
             (workspace) DOUBLE PRECISION array, dimension ( M )
             Workspace for VF.
            </param>
             <param name="VL">
             (input/output) DOUBLE PRECISION array, dimension ( M )
             On entry, VL(1:NL+1) contains the  last components of all
             right singular vectors of the upper block; and VL(NL+2:M)
             contains the last components of all right singular vectors
             of the lower block. On exit, VL contains the last components
             of all right singular vectors of the bidiagonal matrix.
            </param>
             <param name="VLW">
             (workspace) DOUBLE PRECISION array, dimension ( M )
             Workspace for VL.
            </param>
             <param name="ALPHA">
             (input) DOUBLE PRECISION
             Contains the diagonal element associated with the added row.
            </param>
             <param name="BETA">
             (input) DOUBLE PRECISION
             Contains the off-diagonal element associated with the added
             row.
            </param>
             <param name="DSIGMA">
             (output) DOUBLE PRECISION array, dimension ( N )
             Contains a copy of the diagonal elements (K-1 singular values
             and one zero) in the secular equation.
            </param>
             <param name="IDX">
             (workspace) INTEGER array, dimension ( N )
             This will contain the permutation used to sort the contents of
             D into ascending order.
            </param>
             <param name="IDXP">
             (workspace) INTEGER array, dimension ( N )
             This will contain the permutation used to place deflated
             values of D at the end of the array. On output IDXP(2:K)
             points to the nondeflated D-values and IDXP(K+1:N)
             points to the deflated singular values.
            </param>
             <param name="IDXQ">
             (input) INTEGER array, dimension ( N )
             This contains the permutation which separately sorts the two
             sub-problems in D into ascending order.  Note that entries in
             the first half of this permutation must first be moved one
             position backward; and entries in the second half
             must first have NL+1 added to their values.
            </param>
             <param name="PERM">
             (output) INTEGER array, dimension ( N )
             The permutations (from deflation and sorting) to be applied
             to each singular block. Not referenced if ICOMPQ = 0.
            </param>
             <param name="GIVPTR">
             (output) INTEGER
             The number of Givens rotations which took place in this
             subproblem. Not referenced if ICOMPQ = 0.
            </param>
             <param name="GIVCOL">
             (output) INTEGER array, dimension ( LDGCOL, 2 )
             Each pair of numbers indicates a pair of columns to take place
             in a Givens rotation. Not referenced if ICOMPQ = 0.
            </param>
             <param name="LDGCOL">
             (input) INTEGER
             The leading dimension of GIVCOL, must be at least N.
            </param>
             <param name="GIVNUM">
             (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
             Each number indicates the C or S value to be used in the
             corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </param>
             <param name="LDGNUM">
             (input) INTEGER
             The leading dimension of GIVNUM, must be at least N.
            </param>
             <param name="C">
             (output) DOUBLE PRECISION
             C contains garbage if SQRE =0 and the C-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="S">
             (output) DOUBLE PRECISION
             S contains garbage if SQRE =0 and the S-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARZ">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARZ applies a real elementary reflector H to a real M-by-N
             matrix C, from either the left or the right. H is represented in the
             form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix.
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARZ.Run(System.String,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARZ applies a real elementary reflector H to a real M-by-N
             matrix C, from either the left or the right. H is represented in the
             form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix.
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': form  H * C
             = 'R': form  C * H
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C.
            </param>
             <param name="L">
             (input) INTEGER
             The number of entries of the vector V containing
             the meaningful part of the Householder vectors.
             If SIDE = 'L', M .GE. L .GE. 0, if SIDE = 'R', N .GE. L .GE. 0.
            </param>
             <param name="V">
             (input) DOUBLE PRECISION array, dimension (1+(L-1)*abs(INCV))
             The vector v in the representation of H as returned by
             DTZRZF. V is not used if TAU = 0.
            </param>
             <param name="INCV">
             (input) INTEGER
             The increment between elements of v. INCV .LT..GT. 0.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION
             The value tau in the representation of H.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by the matrix H * C if SIDE = 'L',
             or C * H if SIDE = 'R'.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L'
             or (M) if SIDE = 'R'
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED4">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This subroutine computes the I-th updated eigenvalue of a symmetric
             rank-one modification to a diagonal matrix whose elements are
             given in the array d, and that
             
             D(i) .LT. D(j)  for  i .LT. j
             
             and that RHO .GT. 0.  This is arranged by the calling routine, and is
             no loss in generality.  The rank-one modified system is thus
             
             diag( D )  +  RHO *  Z * Z_transpose.
             
             where we assume the Euclidean norm of Z is 1.
             
             The method consists of approximating the rational functions in the
             secular equation by simpler interpolating rational functions.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED4.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double,System.Double@,System.Int32@)">
             <summary>
             Purpose
             =======
             
             This subroutine computes the I-th updated eigenvalue of a symmetric
             rank-one modification to a diagonal matrix whose elements are
             given in the array d, and that
             
             D(i) .LT. D(j)  for  i .LT. j
             
             and that RHO .GT. 0.  This is arranged by the calling routine, and is
             no loss in generality.  The rank-one modified system is thus
             
             diag( D )  +  RHO *  Z * Z_transpose.
             
             where we assume the Euclidean norm of Z is 1.
             
             The method consists of approximating the rational functions in the
             secular equation by simpler interpolating rational functions.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The length of all arrays.
            </param>
             <param name="I">
             (input) INTEGER
             The index of the eigenvalue to be computed.  1 .LE. I .LE. N.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension (N)
             The original eigenvalues.  It is assumed that they are in
             order, D(I) .LT. D(J)  for I .LT. J.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (N)
             The components of the updating vector.
            </param>
             <param name="DELTA">
             (output) DOUBLE PRECISION array, dimension (N)
             If N .GT. 2, DELTA contains (D(j) - lambda_I) in its  j-th
             component.  If N = 1, then DELTA(1) = 1. If N = 2, see DLAED5
             for detail. The vector DELTA contains the information necessary
             to construct the eigenvectors by DLAED3 and DLAED9.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The scalar in the symmetric updating formula.
            </param>
             <param name="DLAM">
             (output) DOUBLE PRECISION
             The computed lambda_I, the I-th updated eigenvalue.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .GT. 0:  if INFO = 1, the updating process failed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGTSV">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGTSV  solves the equation
             
             A*X = B,
             
             where A is an n by n tridiagonal matrix, by Gaussian elimination with
             partial pivoting.
             
             Note that the equation  A'*X = B  may be solved by interchanging the
             order of the arguments DU and DL.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGTSV.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGTSV  solves the equation
             
             A*X = B,
             
             where A is an n by n tridiagonal matrix, by Gaussian elimination with
             partial pivoting.
             
             Note that the equation  A'*X = B  may be solved by interchanging the
             order of the arguments DU and DL.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="DL">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, DL must contain the (n-1) sub-diagonal elements of
             A.
             
             On exit, DL is overwritten by the (n-2) elements of the
             second super-diagonal of the upper triangular matrix U from
             the LU factorization of A, in DL(1), ..., DL(n-2).
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, D must contain the diagonal elements of A.
             
             On exit, D is overwritten by the n diagonal elements of U.
            </param>
             <param name="DU">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, DU must contain the (n-1) super-diagonal elements
             of A.
             
             On exit, DU is overwritten by the (n-1) elements of the first
             super-diagonal of U.
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the N by NRHS matrix of right hand side matrix B.
             On exit, if INFO = 0, the N by NRHS solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: if INFO = i, U(i,i) is exactly zero, and the solution
             has not been computed.  The factorization has not been
             completed unless i = N.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGELSD">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGELSD computes the minimum-norm solution to a real linear least
             squares problem:
             minimize 2-norm(| b - A*x |)
             using the singular value decomposition (SVD) of A. A is an M-by-N
             matrix which may be rank-deficient.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
             The problem is solved in three steps:
             (1) Reduce the coefficient matrix A to bidiagonal form with
             Householder transformations, reducing the original problem
             into a "bidiagonal least squares problem" (BLS)
             (2) Solve the BLS using a divide and conquer approach.
             (3) Apply back all the Householder tranformations to solve
             the original least squares problem.
             
             The effective rank of A is determined by treating as zero those
             singular values which are less than RCOND times the largest singular
             value.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGELSD.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGELSD computes the minimum-norm solution to a real linear least
             squares problem:
             minimize 2-norm(| b - A*x |)
             using the singular value decomposition (SVD) of A. A is an M-by-N
             matrix which may be rank-deficient.
             
             Several right hand side vectors b and solution vectors x can be
             handled in a single call; they are stored as the columns of the
             M-by-NRHS right hand side matrix B and the N-by-NRHS solution
             matrix X.
             
             The problem is solved in three steps:
             (1) Reduce the coefficient matrix A to bidiagonal form with
             Householder transformations, reducing the original problem
             into a "bidiagonal least squares problem" (BLS)
             (2) Solve the BLS using a divide and conquer approach.
             (3) Apply back all the Householder tranformations to solve
             the original least squares problem.
             
             The effective rank of A is determined by treating as zero those
             singular values which are less than RCOND times the largest singular
             value.
             
             The divide and conquer algorithm makes very mild assumptions about
             floating point arithmetic. It will work on machines with a guard
             digit in add/subtract, or on those binary machines without guard
             digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
             Cray-2. It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of A. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of A. N .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrices B and X. NRHS .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, A has been destroyed.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the M-by-NRHS right hand side matrix B.
             On exit, B is overwritten by the N-by-NRHS solution
             matrix X.  If m .GE. n and RANK = n, the residual
             sum-of-squares for the solution in the i-th column is given
             by the sum of squares of elements n+1:m in that column.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,max(M,N)).
            </param>
             <param name="S">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The singular values of A in decreasing order.
             The condition number of A in the 2-norm = S(1)/S(min(m,n)).
            </param>
             <param name="RCOND">
             (input) DOUBLE PRECISION
             RCOND is used to determine the effective rank of A.
             Singular values S(i) .LE. RCOND*S(1) are treated as zero.
             If RCOND .LT. 0, machine precision is used instead.
            </param>
             <param name="RANK">
             (output) INTEGER
             The effective rank of A, i.e., the number of singular values
             which are greater than RCOND*S(1).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK must be at least 1.
             The exact minimum amount of workspace needed depends on M,
             N and NRHS. As long as LWORK is at least
             12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,
             if M is greater than or equal to N or
             12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,
             if M is less than N, the code will execute correctly.
             SMLSIZ is returned by ILAENV and is equal to the maximum
             size of the subproblems at the bottom of the computation
             tree (usually about 25), and
             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
             For good performance, LWORK should generally be larger.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (MAX(1,LIWORK))
             LIWORK .GE. 3 * MINMN * NLVL + 11 * MINMN,
             where MINMN = MIN( M,N ).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  the algorithm for computing the SVD failed to converge;
             if INFO = i, i off-diagonal elements of an intermediate
             bidiagonal form did not converge to zero.
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.CORTH.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement.
            </param>
             <param name="N">
             is the order of the matrix.
            </param>
             <param name="LOW">
             and igh are integers determined by the balancing
             subroutine  cbal.  if  cbal  has not been used,
             set low=1, igh=n.
            </param>
             <param name="AR">
             and ai contain the real and imaginary parts,
             respectively, of the complex input matrix.
            </param>
             <param name="ORTR">
             and orti contain further information about the
             transformations.  only elements low through igh are used.
            </param>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSEispack.CBAL.Run(System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32)">
             <param name="NM">
             must be set to the row dimension of two-dimensional
             array parameters as declared in the calling program
             dimension statement.
            </param>
             <param name="N">
             is the order of the matrix.
            </param>
             <param name="AR">
             and ai contain the real and imaginary parts,
             respectively, of the complex matrix to be balanced.
            </param>
             <param name="LOW">
             and igh are two integers such that ar(i,j) and ai(i,j)
             are equal to zero if
             (1) i is greater than j and
             (2) j=1,...,low-1 or i=igh+1,...,n.
            </param>
             <param name="SCALE">
             contains information determining the
             permutations and scaling factors used.
            </param>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.LEN_TRIM(System.String)">
             <summary>
            LEN_TRIM
            Description: Returns the length of the character argument without counting trailing blank
            characters.
            Syntax: result = LEN_TRIM (string [, kind])
            Class: Elemental function; Generic
            Arguments:
            string Must be of type character.
            kind (opt) Must be a scalar integer initialization expression.
            Examples
            LEN_TRIM ('   C  D   ') has the value 7.
            LEN_TRIM ('     ') has the value 0.
             </summary>
             <remarks>
              From Intel Fortran Language Reference
             </remarks>
             <param name="s"></param>
             <returns></returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.REPEAT(System.String,System.Int32)">
             <summary>
            REPEAT
            Description: Concatenates several copies of a string.
            Syntax: result = REPEAT (string, ncopies)
            Class: Transformational function; Generic
            Arguments:
            string Must be scalar and of type character.
            ncopies Must be scalar and of type integer. It must not be negative.
            Results: The result is a scalar of type character and length ncopies x LEN(string). The
            kind parameter is the same as string. The value of the result is the
            concatenation of ncopies copies of string.
                    Examples
            REPEAT ('S', 3) has the value SSS.
            REPEAT ('ABC', 0) has the value of a zero-length string.
             </summary>
             <remarks>
               From Intel Fortran Language Reference
             </remarks>
             <param name="s"></param>
             <param name="count"></param>
             <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DotNumerics.FortranLibrary.FortranLib.Sign(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:DotNumerics.FortranLibrary.FortranLib.Sign(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:DotNumerics.FortranLibrary.FortranLib.Sign(System.Double,System.Double)" -->
        <member name="M:DotNumerics.FortranLibrary.FortranLib.Mod(System.Int32,System.Int32)">
             <summary>
             Summary:
                 Returns the remainder resulting from the division of a specified number by
                 another specified number.
            
             Parameters:
               y:
                 A divisor.
            
               x:
                 A dividend.
            
             Returns:
                 A number equal to x - (y Q), where Q = Math.Truncate(x/y) 
             </summary>
             <param name="a1">A divisor.</param>
             <param name="a2">A dividend.</param>
             <returns>A number equal to x - (y Q), where Q = Math.Truncate(x/y)</returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.AMod(System.Single,System.Single)">
             <summary>
             Summary:
                 Returns the remainder resulting from the division of a specified number by
                 another specified number.
            
             Parameters:
               y:
                 A divisor.
            
               x:
                 A dividend.
            
             Returns:
                 A number equal to x - (y Q), where Q = Math.Truncate(x/y) 
             </summary>
             <param name="a1">A divisor.</param>
             <param name="a2">A dividend.</param>
             <returns>A number equal to x - (y Q), where Q = Math.Truncate(x/y)</returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.DMod(System.Double,System.Double)">
             <summary>
             Summary:
                 Returns the remainder resulting from the division of a specified number by
                 another specified number.
            
             Parameters:
               y:
                 A divisor.
            
               x:
                 A dividend.
            
             Returns:
                 A number equal to x - (y Q), where Q = Math.Truncate(x/y) 
             </summary>
             <param name="a1">A divisor.</param>
             <param name="a2">A dividend.</param>
             <returns>A number equal to x - (y Q), where Q = Math.Truncate(x/y)</returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.SCAN(System.String,System.String,System.Boolean)">
             <summary>
            SCAN(STRING, SET, BACK)
            Scan a string for any one of the characters in a set of characters.
            Argument Type and Attributes
            STRING must be of type character.
            SET must be of type character with the same kind type parameter
            as STRING.
                BACK (optional)
            must be of type logical.
            Class
            Elemental function
            Result Type and Attributes
            Default integer.
            Result Value
            v Case (i): If BACK is absent or is present with the value .FALSE. and if
            STRING contains at least one character that is in SET, the value of the result
            is the position of the leftmost character of STRING that is in SET.
            v Case (ii): If BACK is present with the value .TRUE. and if STRING contains
            at least one character that is in SET, the value of the result is the position of
            the rightmost character of STRING that is in SET.
            v Case (iii): The value of the result is zero if no character of STRING is in SET
            or if the length of STRING or SET is zero.
            Examples
            v Case (i): SCAN (FORTRAN, TR) has the value 3.
            v Case (ii): SCAN (FORTRAN, TR, BACK = .TRUE.) has the value 5.
            v Case (iii): SCAN (FORTRAN, BCD) has the value 0.
             </summary>
             <remarks>
               IBM XL Fortran for AIX
             </remarks>
             <param name="s"></param>
             <param name="value"></param>
             <param name="back"></param>
             <returns></returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.INDEX(System.String,System.String,System.Boolean)">
             <summary>
             INDEX
            INDEX(STRING, SUBSTRING, BACK)
            Returns the starting position of a substring within a string.
            Argument Type and Attributes
            STRING must be of type character.
            SUBSTRING must be of type character with the same kind type parameter
            as STRING.
            BACK (optional)
            must be of type logical.
            Class
            Elemental function
            Result Type and Attributes
            Default integer.
            Result Value
            v Case (i): If BACK is absent or present with the value .FALSE., the result is
            the minimum positive value of I such that STRING (I : I + LEN
            (SUBSTRING) - 1) = SUBSTRING or zero if there is no such value. Zero is
            returned if LEN (STRING) .LT. LEN (SUBSTRING). One is returned if LEN
            (SUBSTRING) = 0.
            v Case (ii): If BACK is present with the value .TRUE., the result is the
            maximum value of I less than or equal to LEN (STRING) - LEN
            (SUBSTRING) + 1, such that STRING (I : I + LEN (SUBSTRING) - 1) =
            SUBSTRING or zero if there is no such value. Zero is returned if LEN
            (STRING) .LT. LEN (SUBSTRING) and LEN (STRING) + 1 is returned if LEN
            (SUBSTRING) = 0.
            Examples
            INDEX (FORTRAN, R) has the value 3.
            INDEX (FORTRAN, R, BACK = .TRUE.) has the value 5.
             </summary>
             <remarks>
               IBM XL Fortran for AIX
             </remarks>
             <param name="s"></param>
             <param name="value"></param>
             <param name="back"></param>
             <returns></returns>    
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.ADJUSTL(System.String)">
             <summary>
            ADJUSTL(STRING)
            Adjust to the left, removing leading blanks and inserting trailing blanks.
            Argument Type and Attributes
            STRING must be of type character.
            Class
            Elemental function
            Result Type and Attributes
            Character of the same length and kind type parameter as STRING.
            Result Value
            The value of the result is the same as STRING except that any leading blanks
            have been deleted and the same number of trailing blanks have been inserted.
            Examples
            ADJUSTL (bWORD) has the value WORDb.
             </summary>
             <remarks>
               IBM XL Fortran for AIX
             </remarks>
             <param name="s"></param>
             <returns></returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.ADJUSTR(System.String)">
             <summary>
            ADJUSTR(STRING)
            Adjust to the right, removing trailing blanks and inserting leading blanks.
            Argument Type and Attributes
            STRING must be of type character.
            Class
            Elemental function
            Result Type and Attributes
            Character of the same length and kind type parameter as STRING.
            Result Value
            The value of the result is the same as STRING except that any trailing blanks
            have been deleted and the same number of leading blanks have been inserted.
            Examples
            ADJUSTR (WORDb) has the value bWORD.
             </summary>
             <remarks>
               IBM XL Fortran for AIX
             </remarks>
             <param name="s"></param>
             <returns></returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.Substring(System.Char[],System.Int32,System.Int32)">
             <summary>
            Retrieves a substring . The substring starts at a specified
            character position and finisch a specified position.
             </summary>
             <param name="s"></param>
             <param name="startIndex"></param>
             <param name="lastIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotNumerics.FortranLibrary.FortranLib.Substring(System.Char[],System.Int32)">
             <summary>
            Retrieves a substring . The substring starts at a specified
            character position.
             </summary>
             <param name="s"></param>
             <param name="startIndex"></param>
             <returns></returns>
        </member>
        <member name="T:DotNumerics.ODE.OdeExplicitRungeKutta45">
            <summary>
            Solves an initial-value problem for nonstiff ordinary differential equations using 
            the explicit Runge-Kutta method of order (4)5.
            dy(i)/dt = f(i,t,y(1),y(2),...,y(N)).  
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeExplicitRungeKutta45.#ctor">
            <summary>
            Initializes a new instance of the OdeExplicitRungeKutta45 class.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.OdeExplicitRungeKutta45.#ctor(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Initializes a new instance of the OdeExplicitRungeKutta45 class.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeExplicitRungeKutta45.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32)">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.ODE.OdeExplicitRungeKutta45.InitializeODEs(DotNumerics.ODE.OdeFunction,System.Int32,System.Double,System.Double[])">
            <summary>
            Method that initialize the ODE to solve.
            </summary>
            <param name="function">A function that evaluates the right side of the differential equations.</param>
            <param name="numEquations">The number of differential equations.</param>
            <param name="t0">The initial value for the independent variable.</param>
            <param name="y0">A vector of size N containing the initial conditions. N is the number of differential equations.</param>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.DCSTEP.Run(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double,System.Double,System.Boolean@,System.Double,System.Double)">
             <param name="STX">
             is a double precision variable.
             On entry stx is the best step obtained so far and is an
             endpoint of the interval that contains the minimizer. 
             On exit stx is the updated best step.
            </param>
             <param name="FX">
             is a double precision variable.
             On entry fx is the function at stx.
             On exit fx is the function at stx.
            </param>
             <param name="DX">
             is a double precision variable.
             On entry dx is the derivative of the function at 
             stx. The derivative must be negative in the direction of 
             the step, that is, dx and stp - stx must have opposite 
             signs.
             On exit dx is the derivative of the function at stx.
            </param>
             <param name="STY">
             is a double precision variable.
             On entry sty is the second endpoint of the interval that 
             contains the minimizer.
             On exit sty is the updated endpoint of the interval that 
             contains the minimizer.
            </param>
             <param name="FY">
             is a double precision variable.
             On entry fy is the function at sty.
             On exit fy is the function at sty.
            </param>
             <param name="DY">
             is a double precision variable.
             On entry dy is the derivative of the function at sty.
             On exit dy is the derivative of the function at the exit sty.
            </param>
             <param name="STP">
             is a double precision variable.
             On entry stp is the current step. If brackt is set to .true.
             then on input stp must be between stx and sty. 
             On exit stp is a new trial step.
            </param>
             <param name="FP">
             is a double precision variable.
             On entry fp is the function at stp
             On exit fp is unchanged.
            </param>
             <param name="DP">
             is a double precision variable.
             On entry dp is the the derivative of the function at stp.
             On exit dp is unchanged.
            </param>
             <param name="BRACKT">
             is an logical variable.
             On entry brackt specifies if a minimizer has been bracketed.
             Initially brackt must be set to .false.
             On exit brackt specifies if a minimizer has been bracketed.
             When a minimizer is bracketed brackt is set to .true.
            </param>
             <param name="STPMIN">
             is a double precision variable.
             On entry stpmin is a lower bound for the step.
             On exit stpmin is unchanged.
            </param>
             <param name="STPMAX">
             is a double precision variable.
             On entry stpmax is an upper bound for the step.
             On exit stpmax is unchanged.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORM2L">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORM2L overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORM2L.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORM2L overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q or Q' from the Left
             = 'R': apply Q or Q' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply Q  (No transpose)
             = 'T': apply Q' (Transpose)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension (LDA,K)
             The i-th column must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGEQLF in the last k columns of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.
             If SIDE = 'L', LDA .GE. max(1,M);
             if SIDE = 'R', LDA .GE. max(1,N).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQLF.
            </param>
             <param name="C">
             * Q  if SIDE = 'R' and TRANS = 'N', or
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L',
             (M) if SIDE = 'R'
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORG2R">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORG2R generates an m by n real matrix Q with orthonormal columns,
             which is defined as the first n columns of a product of k elementary
             reflectors of order m
             
             Q  =  H(1) H(2) . . . H(k)
             
             as returned by DGEQRF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORG2R.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORG2R generates an m by n real matrix Q with orthonormal columns,
             which is defined as the first n columns of a product of k elementary
             reflectors of order m
             
             Q  =  H(1) H(2) . . . H(k)
             
             as returned by DGEQRF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. M .GE. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the i-th column must contain the vector which
             defines the elementary reflector H(i), for i = 1,2,...,k, as
             returned by DGEQRF in the first k columns of its array
             argument A.
             On exit, the m-by-n matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQRF.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASQ2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASQ2 computes all the eigenvalues of the symmetric positive 
             definite tridiagonal matrix associated with the qd array Z to high
             relative accuracy are computed to high relative accuracy, in the
             absence of denormalization, underflow and overflow.
             
             To see the relation of Z to the tridiagonal matrix, let L be a
             unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
             let U be an upper bidiagonal matrix with 1's above and diagonal
             Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
             symmetric tridiagonal to which it is similar.
             
             Note : DLASQ2 defines a logical variable, IEEE, which is true
             on machines which follow ieee-754 floating-point standard in their
             handling of infinities and NaNs, and false otherwise. This variable
             is passed to DLAZQ3.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASQ2.Run(System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASQ2 computes all the eigenvalues of the symmetric positive 
             definite tridiagonal matrix associated with the qd array Z to high
             relative accuracy are computed to high relative accuracy, in the
             absence of denormalization, underflow and overflow.
             
             To see the relation of Z to the tridiagonal matrix, let L be a
             unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
             let U be an upper bidiagonal matrix with 1's above and diagonal
             Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
             symmetric tridiagonal to which it is similar.
             
             Note : DLASQ2 defines a logical variable, IEEE, which is true
             on machines which follow ieee-754 floating-point standard in their
             handling of infinities and NaNs, and false otherwise. This variable
             is passed to DLAZQ3.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of rows and columns in the matrix. N .GE. 0.
            </param>
             <param name="Z">
             (workspace) DOUBLE PRECISION array, dimension ( 4*N )
             On entry Z holds the qd array. On exit, entries 1 to N hold
             the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
             trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
             N .GT. 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
             holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
             shifts that failed.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if the i-th argument is a scalar and had an illegal
             value, then INFO = -i, if the i-th argument is an
             array and the j-entry had an illegal value, then
             INFO = -(i*100+j)
             .GT. 0: the algorithm failed
             = 1, a split was marked by a positive value in E
             = 2, current block of Z not diagonalized after 30*N
             iterations (in inner while loop)
             = 3, termination criterion of outer while loop not met 
             (program created more than N unreduced blocks)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD6">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASD6 computes the SVD of an updated upper bidiagonal matrix B
             obtained by merging two smaller ones by appending a row. This
             routine is used only for the problem which requires all singular
             values and optionally singular vector matrices in factored form.
             B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
             A related subroutine, DLASD1, handles the case in which all singular
             values and singular vectors of the bidiagonal matrix are desired.
             
             DLASD6 computes the SVD as follows:
             
             ( D1(in)  0    0     0 )
             B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
             (   0     0   D2(in) 0 )
             
             = U(out) * ( D(out) 0) * VT(out)
             
             where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
             with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
             elsewhere; and the entry b is empty if SQRE = 0.
             
             The singular values of B can be computed using D1, D2, the first
             components of all the right singular vectors of the lower block, and
             the last components of all the right singular vectors of the upper
             block. These components are stored and updated in VF and VL,
             respectively, in DLASD6. Hence U and VT are not explicitly
             referenced.
             
             The singular values are stored in D. The algorithm consists of two
             stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple singular values or if there is a zero
             in the Z vector. For each such occurence the dimension of the
             secular equation problem is reduced by one. This stage is
             performed by the routine DLASD7.
             
             The second stage consists of calculating the updated
             singular values. This is done by finding the roots of the
             secular equation via the routine DLASD4 (as called by DLASD8).
             This routine also updates VF and VL and computes the distances
             between the updated singular values and the old singular
             values.
             
             DLASD6 is called from DLASDA.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD6.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double@,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@,System.Int32[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@,System.Double@,System.Double@,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASD6 computes the SVD of an updated upper bidiagonal matrix B
             obtained by merging two smaller ones by appending a row. This
             routine is used only for the problem which requires all singular
             values and optionally singular vector matrices in factored form.
             B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
             A related subroutine, DLASD1, handles the case in which all singular
             values and singular vectors of the bidiagonal matrix are desired.
             
             DLASD6 computes the SVD as follows:
             
             ( D1(in)  0    0     0 )
             B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
             (   0     0   D2(in) 0 )
             
             = U(out) * ( D(out) 0) * VT(out)
             
             where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
             with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
             elsewhere; and the entry b is empty if SQRE = 0.
             
             The singular values of B can be computed using D1, D2, the first
             components of all the right singular vectors of the lower block, and
             the last components of all the right singular vectors of the upper
             block. These components are stored and updated in VF and VL,
             respectively, in DLASD6. Hence U and VT are not explicitly
             referenced.
             
             The singular values are stored in D. The algorithm consists of two
             stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple singular values or if there is a zero
             in the Z vector. For each such occurence the dimension of the
             secular equation problem is reduced by one. This stage is
             performed by the routine DLASD7.
             
             The second stage consists of calculating the updated
             singular values. This is done by finding the roots of the
             secular equation via the routine DLASD4 (as called by DLASD8).
             This routine also updates VF and VL and computes the distances
             between the updated singular values and the old singular
             values.
             
             DLASD6 is called from DLASDA.
             
            </summary>
             <param name="ICOMPQ">
             (input) INTEGER
             Specifies whether singular vectors are to be computed in
             factored form:
             = 0: Compute singular values only.
             = 1: Compute singular vectors in factored form as well.
            </param>
             <param name="NL">
             (input) INTEGER
             The row dimension of the upper block.  NL .GE. 1.
            </param>
             <param name="NR">
             (input) INTEGER
             The row dimension of the lower block.  NR .GE. 1.
            </param>
             <param name="SQRE">
             (input) INTEGER
             = 0: the lower block is an NR-by-NR square matrix.
             = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
             
             The bidiagonal matrix has row dimension N = NL + NR + 1,
             and column dimension M = N + SQRE.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension ( NL+NR+1 ).
             On entry D(1:NL,1:NL) contains the singular values of the
             upper block, and D(NL+2:N) contains the singular values
             of the lower block. On exit D(1:N) contains the singular
             values of the modified matrix.
            </param>
             <param name="VF">
             (input/output) DOUBLE PRECISION array, dimension ( M )
             On entry, VF(1:NL+1) contains the first components of all
             right singular vectors of the upper block; and VF(NL+2:M)
             contains the first components of all right singular vectors
             of the lower block. On exit, VF contains the first components
             of all right singular vectors of the bidiagonal matrix.
            </param>
             <param name="VL">
             (input/output) DOUBLE PRECISION array, dimension ( M )
             On entry, VL(1:NL+1) contains the  last components of all
             right singular vectors of the upper block; and VL(NL+2:M)
             contains the last components of all right singular vectors of
             the lower block. On exit, VL contains the last components of
             all right singular vectors of the bidiagonal matrix.
            </param>
             <param name="ALPHA">
             (input/output) DOUBLE PRECISION
             Contains the diagonal element associated with the added row.
            </param>
             <param name="BETA">
             (input/output) DOUBLE PRECISION
             Contains the off-diagonal element associated with the added
             row.
            </param>
             <param name="IDXQ">
             (output) INTEGER array, dimension ( N )
             This contains the permutation which will reintegrate the
             subproblem just solved back into sorted order, i.e.
             D( IDXQ( I = 1, N ) ) will be in ascending order.
            </param>
             <param name="PERM">
             (output) INTEGER array, dimension ( N )
             The permutations (from deflation and sorting) to be applied
             to each block. Not referenced if ICOMPQ = 0.
            </param>
             <param name="GIVPTR">
             (output) INTEGER
             The number of Givens rotations which took place in this
             subproblem. Not referenced if ICOMPQ = 0.
            </param>
             <param name="GIVCOL">
             (output) INTEGER array, dimension ( LDGCOL, 2 )
             Each pair of numbers indicates a pair of columns to take place
             in a Givens rotation. Not referenced if ICOMPQ = 0.
            </param>
             <param name="LDGCOL">
             (input) INTEGER
             leading dimension of GIVCOL, must be at least N.
            </param>
             <param name="GIVNUM">
             (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
             Each number indicates the C or S value to be used in the
             corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </param>
             <param name="LDGNUM">
             (input) INTEGER
             The leading dimension of GIVNUM and POLES, must be at least N.
            </param>
             <param name="POLES">
             (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
             On exit, POLES(1,*) is an array containing the new singular
             values obtained from solving the secular equation, and
             POLES(2,*) is an array containing the poles in the secular
             equation. Not referenced if ICOMPQ = 0.
            </param>
             <param name="DIFL">
             (output) DOUBLE PRECISION array, dimension ( N )
             On exit, DIFL(I) is the distance between I-th updated
             (undeflated) singular value and the I-th (undeflated) old
             singular value.
            </param>
             <param name="DIFR">
             (output) DOUBLE PRECISION array,
             dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
             dimension ( N ) if ICOMPQ = 0.
             On exit, DIFR(I, 1) is the distance between I-th updated
             (undeflated) singular value and the I+1-th (undeflated) old
             singular value.
             
             If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
             normalizing factors for the right singular vector matrix.
             
             See DLASD8 for details on DIFL and DIFR.
            </param>
             <param name="Z">
             (output) DOUBLE PRECISION array, dimension ( M )
             The first elements of this array contain the components
             of the deflation-adjusted updating row vector.
            </param>
             <param name="K">
             (output) INTEGER
             Contains the dimension of the non-deflated matrix,
             This is the order of the related secular equation. 1 .LE. K .LE.N.
            </param>
             <param name="C">
             (output) DOUBLE PRECISION
             C contains garbage if SQRE =0 and the C-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="S">
             (output) DOUBLE PRECISION
             S contains garbage if SQRE =0 and the S-value of a Givens
             rotation related to the right null space if SQRE = 1.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension ( 4 * M )
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension ( 3 * N )
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an singular value did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR5">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR5.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <param name="WANTT">
             (input) logical scalar
             WANTT = .true. if the quasi-triangular Schur factor
             is being computed.  WANTT is set to .false. otherwise.
            </param>
             <param name="WANTZ">
             (input) logical scalar
             WANTZ = .true. if the orthogonal Schur factor is being
             computed.  WANTZ is set to .false. otherwise.
            </param>
             <param name="KACC22">
             (input) integer with value 0, 1, or 2.
             Specifies the computation mode of far-from-diagonal
             orthogonal updates.
             = 0: DLAQR5 does not accumulate reflections and does not
             use matrix-matrix multiply to update far-from-diagonal
             matrix entries.
             = 1: DLAQR5 accumulates reflections and uses matrix-matrix
             multiply to update the far-from-diagonal matrix entries.
             = 2: DLAQR5 accumulates reflections, uses matrix-matrix
             multiply to update the far-from-diagonal matrix entries,
             and takes advantage of 2-by-2 block structure during
             matrix multiplies.
            </param>
             <param name="N">
             (input) integer scalar
             N is the order of the Hessenberg matrix H upon which this
             subroutine operates.
            </param>
             <param name="KTOP">
             (input) integer scalar
            </param>
             <param name="KBOT">
             (input) integer scalar
             These are the first and last rows and columns of an
             isolated diagonal block upon which the QR sweep is to be
             applied. It is assumed without a check that
             either KTOP = 1  or   H(KTOP,KTOP-1) = 0
             and
             either KBOT = N  or   H(KBOT+1,KBOT) = 0.
            </param>
             <param name="NSHFTS">
             (input) integer scalar
             NSHFTS gives the number of simultaneous shifts.  NSHFTS
             must be positive and even.
            </param>
             <param name="SR">
             (input) DOUBLE PRECISION array of size (NSHFTS)
            </param>
             <param name="SI">
             (input) DOUBLE PRECISION array of size (NSHFTS)
             SR contains the real parts and SI contains the imaginary
             parts of the NSHFTS shifts of origin that define the
             multi-shift QR sweep.
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array of size (LDH,N)
             On input H contains a Hessenberg matrix.  On output a
             multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
             to the isolated diagonal block in rows and columns KTOP
             through KBOT.
            </param>
             <param name="LDH">
             (input) integer scalar
             LDH is the leading dimension of H just as declared in the
             calling procedure.  LDH.GE.MAX(1,N).
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array of size (LDZ,IHI)
             If WANTZ = .TRUE., then the QR Sweep orthogonal
             similarity transformation is accumulated into
             Z(ILOZ:IHIZ,ILO:IHI) from the right.
             If WANTZ = .FALSE., then Z is unreferenced.
            </param>
             <param name="LDZ">
             (input) integer scalar
             LDA is the leading dimension of Z just as declared in
             the calling procedure. LDZ.GE.N.
            </param>
             <param name="V">
             (workspace) DOUBLE PRECISION array of size (LDV,NSHFTS/2)
            </param>
             <param name="LDV">
             (input) integer scalar
             LDV is the leading dimension of V as declared in the
             calling procedure.  LDV.GE.3.
            </param>
             <param name="U">
             (workspace) DOUBLE PRECISION array of size
             (LDU,3*NSHFTS-3)
            </param>
             <param name="LDU">
             (input) integer scalar
             LDU is the leading dimension of U just as declared in the
             in the calling subroutine.  LDU.GE.3*NSHFTS-3.
            </param>
             <param name="NV">
             (input) integer scalar
             NV is the number of rows in WV agailable for workspace.
             NV.GE.1.
            </param>
             <param name="WV">
             (workspace) DOUBLE PRECISION array of size
             (LDWV,3*NSHFTS-3)
            </param>
             <param name="LDWV">
             (input) integer scalar
             LDWV is the leading dimension of WV as declared in the
             in the calling subroutine.  LDWV.GE.NV.
             
            </param>
             <param name="NH">
             (input) integer scalar
             NH is the number of columns in array WH available for
             workspace. NH.GE.1.
            </param>
             <param name="WH">
             (workspace) DOUBLE PRECISION array of size (LDWH,NH)
            </param>
             <param name="LDWH">
             (input) integer scalar
             Leading dimension of WH just as declared in the
             calling procedure.  LDWH.GE.3*NSHFTS-3.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED3">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED3 finds the roots of the secular equation, as defined by the
             values in D, W, and RHO, between 1 and K.  It makes the
             appropriate calls to DLAED4 and then updates the eigenvectors by
             multiplying the matrix of eigenvectors of the pair of eigensystems
             being combined by the matrix of eigenvectors of the K-by-K system
             which is solved here.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED3.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED3 finds the roots of the secular equation, as defined by the
             values in D, W, and RHO, between 1 and K.  It makes the
             appropriate calls to DLAED4 and then updates the eigenvectors by
             multiplying the matrix of eigenvectors of the pair of eigensystems
             being combined by the matrix of eigenvectors of the K-by-K system
             which is solved here.
             
             This code makes very mild assumptions about floating point
             arithmetic. It will work on machines with a guard digit in
             add/subtract, or on those binary machines without guard digits
             which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
             It could conceivably fail on hexadecimal or decimal machines
             without guard digits, but we know of none.
             
            </summary>
             <param name="K">
             (input) INTEGER
             The number of terms in the rational function to be solved by
             DLAED4.  K .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of rows and columns in the Q matrix.
             N .GE. K (deflation may result in N.GT.K).
            </param>
             <param name="N1">
             (input) INTEGER
             The location of the last eigenvalue in the leading submatrix.
             min(1,N) .LE. N1 .LE. N/2.
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (N)
             D(I) contains the updated eigenvalues for
             1 .LE. I .LE. K.
            </param>
             <param name="Q">
             (output) DOUBLE PRECISION array, dimension (LDQ,N)
             Initially the first K columns are used as workspace.
             On output the columns 1 to K contain
             the updated eigenvectors.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The value of the parameter in the rank one update equation.
             RHO .GE. 0 required.
            </param>
             <param name="DLAMDA">
             (input/output) DOUBLE PRECISION array, dimension (K)
             The first K elements of this array contain the old roots
             of the deflated updating problem.  These are the poles
             of the secular equation. May be changed on output by
             having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
             Cray-2, or Cray C-90, as described above.
            </param>
             <param name="Q2">
             (input) DOUBLE PRECISION array, dimension (LDQ2, N)
             The first K columns of this matrix contain the non-deflated
             eigenvectors for the split problem.
            </param>
             <param name="INDX">
             (input) INTEGER array, dimension (N)
             The permutation used to arrange the columns of the deflated
             Q matrix into three groups (see DLAED2).
             The rows of the eigenvectors found by DLAED4 must be likewise
             permuted before the matrix multiply can take place.
            </param>
             <param name="CTOT">
             (input) INTEGER array, dimension (4)
             A count of the total number of the various types of columns
             in Q, as described in INDX.  The fourth column type is any
             column which has been deflated.
            </param>
             <param name="W">
             (input/output) DOUBLE PRECISION array, dimension (K)
             The first K elements of this array contain the components
             of the deflation-adjusted updating vector. Destroyed on
             output.
            </param>
             <param name="S">
             (workspace) DOUBLE PRECISION array, dimension (N1 + 1)*K
             Will contain the eigenvectors of the repaired matrix which
             will be multiplied by the previously accumulated eigenvectors
             to update the system.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an eigenvalue did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGLSE">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGLSE solves the linear equality-constrained least squares (LSE)
             problem:
             
             minimize || c - A*x ||_2   subject to   B*x = d
             
             where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
             M-vector, and d is a given P-vector. It is assumed that
             P .LE. N .LE. M+P, and
             
             rank(B) = P and  rank( (A) ) = N.
             ( (B) )
             
             These conditions ensure that the LSE problem has a unique solution,
             which is obtained using a generalized RQ factorization of the
             matrices (B, A) given by
             
             B = (0 R)*Q,   A = Z*T*Q.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGLSE.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGLSE solves the linear equality-constrained least squares (LSE)
             problem:
             
             minimize || c - A*x ||_2   subject to   B*x = d
             
             where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
             M-vector, and d is a given P-vector. It is assumed that
             P .LE. N .LE. M+P, and
             
             rank(B) = P and  rank( (A) ) = N.
             ( (B) )
             
             These conditions ensure that the LSE problem has a unique solution,
             which is obtained using a generalized RQ factorization of the
             matrices (B, A) given by
             
             B = (0 R)*Q,   A = Z*T*Q.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrices A and B. N .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of rows of the matrix B. 0 .LE. P .LE. N .LE. M+P.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix T.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="B">
             = (0 R)*Q,   A = Z*T*Q.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,P).
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (M)
             On entry, C contains the right hand side vector for the
             least squares part of the LSE problem.
             On exit, the residual sum of squares for the solution
             is given by the sum of squares of elements N-P+1 to M of
             vector C.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (P)
             On entry, D contains the right hand side vector for the
             constrained equation.
             On exit, D is destroyed.
            </param>
             <param name="X">
             (output) DOUBLE PRECISION array, dimension (N)
             On exit, X is the solution of the LSE problem.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,M+N+P).
             For optimum performance LWORK .GE. P+min(M,N)+max(M,N)*NB,
             where NB is an upper bound for the optimal blocksizes for
             DGEQRF, SGERQF, DORMQR and SORMRQ.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             = 1:  the upper triangular factor R associated with B in the
             generalized RQ factorization of the pair (B, A) is
             singular, so that rank(B) .LT. P; the least squares
             solution could not be computed.
             = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor
             T associated with A in the generalized RQ factorization
             of the pair (B, A) is singular, so that
             rank( (A) ) .LT. N; the least squares solution could not
             ( (B) )
             be computed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEMM">
             <summary>
             Purpose
             =======
             
             DGEMM  performs one of the matrix-matrix operations
             
             C := alpha*op( A )*op( B ) + beta*C,
             
             where  op( X ) is one of
             
             op( X ) = X   or   op( X ) = X',
             
             alpha and beta are scalars, and A, B and C are matrices, with op( A )
             an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEMM.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DGEMM  performs one of the matrix-matrix operations
             
             C := alpha*op( A )*op( B ) + beta*C,
             
             where  op( X ) is one of
             
             op( X ) = X   or   op( X ) = X',
             
             alpha and beta are scalars, and A, B and C are matrices, with op( A )
             an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
             
            </summary>
             <param name="TRANSA">
             - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
             
             TRANSA = 'N' or 'n',  op( A ) = A.
             
             TRANSA = 'T' or 't',  op( A ) = A'.
             
             TRANSA = 'C' or 'c',  op( A ) = A'.
             
             Unchanged on exit.
            </param>
             <param name="TRANSB">
             - CHARACTER*1.
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
             
             TRANSB = 'N' or 'n',  op( B ) = B.
             
             TRANSB = 'T' or 't',  op( B ) = B'.
             
             TRANSB = 'C' or 'c',  op( B ) = B'.
             
             Unchanged on exit.
            </param>
             <param name="M">
             - INTEGER.
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
             Unchanged on exit.
            </param>
             <param name="K">
             - INTEGER.
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             and beta are scalars, and A, B and C are matrices, with op( A )
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
             Unchanged on exit.
            </param>
             <param name="B">
             - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.
            </param>
             <param name="LDB">
             - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="BETA">
             - DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
             Unchanged on exit.
            </param>
             <param name="C">
             := alpha*op( A )*op( B ) + beta*C,
            </param>
             <param name="LDC">
             - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEEV">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEEV computes for an N-by-N real nonsymmetric matrix A, the
             eigenvalues and, optionally, the left and/or right eigenvectors.
             
             The right eigenvector v(j) of A satisfies
             A * v(j) = lambda(j) * v(j)
             where lambda(j) is its eigenvalue.
             The left eigenvector u(j) of A satisfies
             u(j)**H * A = lambda(j) * u(j)**H
             where u(j)**H denotes the conjugate transpose of u(j).
             
             The computed eigenvectors are normalized to have Euclidean norm
             equal to 1 and largest component real.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEEV.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEEV computes for an N-by-N real nonsymmetric matrix A, the
             eigenvalues and, optionally, the left and/or right eigenvectors.
             
             The right eigenvector v(j) of A satisfies
             A * v(j) = lambda(j) * v(j)
             where lambda(j) is its eigenvalue.
             The left eigenvector u(j) of A satisfies
             u(j)**H * A = lambda(j) * u(j)**H
             where u(j)**H denotes the conjugate transpose of u(j).
             
             The computed eigenvectors are normalized to have Euclidean norm
             equal to 1 and largest component real.
             
            </summary>
             <param name="JOBVL">
             (input) CHARACTER*1
             = 'N': left eigenvectors of A are not computed;
             = 'V': left eigenvectors of A are computed.
            </param>
             <param name="JOBVR">
             (input) CHARACTER*1
             = 'N': right eigenvectors of A are not computed;
             = 'V': right eigenvectors of A are computed.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A. N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the N-by-N matrix A.
             On exit, A has been overwritten.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="WR">
             (output) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="WI">
             (output) DOUBLE PRECISION array, dimension (N)
             WR and WI contain the real and imaginary parts,
             respectively, of the computed eigenvalues.  Complex
             conjugate pairs of eigenvalues appear consecutively
             with the eigenvalue having the positive imaginary part
             first.
            </param>
             <param name="VL">
             (output) DOUBLE PRECISION array, dimension (LDVL,N)
             If JOBVL = 'V', the left eigenvectors u(j) are stored one
             after another in the columns of VL, in the same order
             as their eigenvalues.
             If JOBVL = 'N', VL is not referenced.
             If the j-th eigenvalue is real, then u(j) = VL(:,j),
             the j-th column of VL.
             If the j-th and (j+1)-st eigenvalues form a complex
             conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
             u(j+1) = VL(:,j) - i*VL(:,j+1).
            </param>
             <param name="LDVL">
             (input) INTEGER
             The leading dimension of the array VL.  LDVL .GE. 1; if
             JOBVL = 'V', LDVL .GE. N.
            </param>
             <param name="VR">
             (output) DOUBLE PRECISION array, dimension (LDVR,N)
             If JOBVR = 'V', the right eigenvectors v(j) are stored one
             after another in the columns of VR, in the same order
             as their eigenvalues.
             If JOBVR = 'N', VR is not referenced.
             If the j-th eigenvalue is real, then v(j) = VR(:,j),
             the j-th column of VR.
             If the j-th and (j+1)-st eigenvalues form a complex
             conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
             v(j+1) = VR(:,j) - i*VR(:,j+1).
            </param>
             <param name="LDVR">
             (input) INTEGER
             The leading dimension of the array VR.  LDVR .GE. 1; if
             JOBVR = 'V', LDVR .GE. N.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,3*N), and
             if JOBVL = 'V' or JOBVR = 'V', LWORK .GE. 4*N.  For good
             performance, LWORK must generally be larger.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = i, the QR algorithm failed to compute all the
             eigenvalues, and no eigenvectors have been computed;
             elements i+1:N of WR and WI contain eigenvalues which
             have converged.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGBSV">
             <summary>
             -- LAPACK driver routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGBSV computes the solution to a real system of linear equations
             A * X = B, where A is a band matrix of order N with KL subdiagonals
             and KU superdiagonals, and X and B are N-by-NRHS matrices.
             
             The LU decomposition with partial pivoting and row interchanges is
             used to factor A as A = L * U, where L is a product of permutation
             and unit lower triangular matrices with KL subdiagonals, and U is
             upper triangular with KL+KU superdiagonals.  The factored form of A
             is then used to solve the system of equations A * X = B.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGBSV.Run(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGBSV computes the solution to a real system of linear equations
             A * X = B, where A is a band matrix of order N with KL subdiagonals
             and KU superdiagonals, and X and B are N-by-NRHS matrices.
             
             The LU decomposition with partial pivoting and row interchanges is
             used to factor A as A = L * U, where L is a product of permutation
             and unit lower triangular matrices with KL subdiagonals, and U is
             upper triangular with KL+KU superdiagonals.  The factored form of A
             is then used to solve the system of equations A * X = B.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of linear equations, i.e., the order of the
             matrix A.  N .GE. 0.
            </param>
             <param name="KL">
             (input) INTEGER
             The number of subdiagonals within the band of A.  KL .GE. 0.
            </param>
             <param name="KU">
             (input) INTEGER
             The number of superdiagonals within the band of A.  KU .GE. 0.
            </param>
             <param name="NRHS">
             (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS .GE. 0.
            </param>
             <param name="AB">
             (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
             On entry, the matrix A in band storage, in rows KL+1 to
             2*KL+KU+1; rows 1 to KL of the array need not be set.
             The j-th column of A is stored in the j-th column of the
             array AB as follows:
             AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU).LE.i.LE.min(N,j+KL)
             On exit, details of the factorization: U is stored as an
             upper triangular band matrix with KL+KU superdiagonals in
             rows 1 to KL+KU+1, and the multipliers used during the
             factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
             See below for further details.
            </param>
             <param name="LDAB">
             (input) INTEGER
             The leading dimension of the array AB.  LDAB .GE. 2*KL+KU+1.
            </param>
             <param name="IPIV">
             (output) INTEGER array, dimension (N)
             The pivot indices that define the permutation matrix P;
             row i of the matrix was interchanged with row IPIV(i).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the N-by-NRHS right hand side matrix B.
             On exit, if INFO = 0, the N-by-NRHS solution matrix X.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B.  LDB .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
             has been completed, but the factor U is exactly
             singular, and the solution has not been computed.
            </param>
        </member>
        <member name="T:DotNumerics.Optimization.Simplex">
            <summary>
            Class used to minimizes a function of several variables by using the Nelder-Mead (Simplex) method. This class can be used for unconstrained and bounded constrained minimization.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.#ctor">
            <summary>
            Initializes a new instance of the Simplex class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,System.Double[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="initialGuess">Array of size N containing the initial guess. N is the number of variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,System.Double[],System.Double)">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="initialGuess">Array of size N containing the initial guess. N is the number of variables.</param>
            <param name="initialStep">The initial change of the variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptSimplexVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptSimplexVariable[],System.Single)">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <param name="initialStep">The initial change of the variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the initial guess. N is the number of variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptVariable[],System.Double)">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the initial guess. N is the number of variables.</param>
            <param name="initialStep">The initial change of the variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptSimplexBoundVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptSimplexBoundVariable[],System.Single)">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <param name="initialStep">The initial change of the variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptBoundVariable[])">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="M:DotNumerics.Optimization.Simplex.ComputeMin(DotNumerics.Optimization.OptMultivariateFunction,DotNumerics.Optimization.OptBoundVariable[],System.Single)">
            <summary>
            Computes the minimum point of a function of several variables.
            </summary>
            <param name="function">The function to minimize.</param>
            <param name="variables">Array of size N containing the varaibles.</param>
            <param name="initialStep">The initial change of the variables.</param>
            <returns>Array containing the solution.</returns>
        </member>
        <member name="T:DotNumerics.Optimization.OptSimplexVariable">
            <summary>
            Represents a varaible that can be used in a simplex optimization classe.
            </summary>
        </member>
        <member name="F:DotNumerics.Optimization.OptSimplexVariable._ScaleFactor">
            <summary>
            The scale factor controls the internal variable size. Variable=IntVar*ScaleFactor where IntVar is the internal variable. 
            Try to set the ScaleFactor of the same order that the variable, with this value the internal size will be near to 1 . 
            The default value is 1. This value modifies the changes and accuracy of this variable. 
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.String,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.Double,System.Boolean,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="M:DotNumerics.Optimization.OptSimplexVariable.#ctor(System.String,System.Double,System.Boolean,System.Double)">
            <summary>
            Initializes a new instance of the OptSimplexVariable class.
            </summary>
            <param name="name">The variable name.</param>
            <param name="initialGuess">The initial guess.</param>
            <param name="isFixed">Value that indicates if the variable is fixed.</param>
            <param name="scaleFactor">A scale factor used to control the changes and accuracy of this variable.</param>
        </member>
        <member name="P:DotNumerics.Optimization.OptSimplexVariable.ScaleFactor">
            <summary>
            The scale factor controls the internal variable size. Variable=IntVar*ScaleFactor where IntVar is the internal variable. 
            Try to set the ScaleFactor of the same order that the variable, with this value the internal size will be near to 1 . 
            The default value is 1. This value modifies the changes and accuracy of this variable. 
            </summary>
        </member>
        <member name="M:DotNumerics.Optimization.LBFGSB.FORMK.Run(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Boolean,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double,System.Int32,System.Int32,System.Int32@)">
             <param name="N">
             is an integer variable.
             On entry n is the dimension of the problem.
             On exit n is unchanged.
            </param>
             <param name="NSUB">
             is an integer variable
             On entry nsub is the number of subspace variables in free set.
             On exit nsub is not changed.
            </param>
             <param name="IND">
             is an integer array of dimension nsub.
             On entry ind specifies the indices of subspace variables.
             On exit ind is unchanged. 
            </param>
             <param name="NENTER">
             is an integer variable.
             On entry nenter is the number of variables entering the 
             free set.
             On exit nenter is unchanged. 
            </param>
             <param name="ILEAVE">
             is an integer variable.
             On entry indx2(ileave),...,indx2(n) are the variables leaving
             the free set.
             On exit ileave is unchanged. 
            </param>
             <param name="INDX2">
             is an integer array of dimension n.
             On entry indx2(1),...,indx2(nenter) are the variables entering
             the free set, while indx2(ileave),...,indx2(n) are the
             variables leaving the free set.
             On exit indx2 is unchanged. 
            </param>
             <param name="IUPDAT">
             is an integer variable.
             On entry iupdat is the total number of BFGS updates made so far.
             On exit iupdat is unchanged. 
            </param>
             <param name="UPDATD">
             is a logical variable.
             On entry 'updatd' is true if the L-BFGS matrix is updatd.
             On exit 'updatd' is unchanged. 
            </param>
             <param name="WN">
             is a double precision array of dimension 2m x 2m.
             On entry wn is unspecified.
             On exit the upper triangle of wn stores the LEL^T factorization
             of the 2*col x 2*col indefinite matrix
             [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
             [L_a -R_z           theta*S'AA'S ]
            </param>
             <param name="WN1">
             is a double precision array of dimension 2m x 2m.
             On entry wn1 stores the lower triangular part of 
             [Y' ZZ'Y   L_a'+R_z']
             [L_a+R_z   S'AA'S   ]
             in the previous iteration.
             On exit wn1 stores the corresponding updated matrices.
             The purpose of wn1 is just to store these inner products
             so they can be easily updated and inserted into wn.
            </param>
             <param name="M">
             is an integer variable.
             On entry m is the maximum number of variable metric corrections
             used to define the limited memory matrix.
             On exit m is unchanged.
            </param>
             <param name="THETA">
             is a double precision variable;
            </param>
             <param name="COL">
             is an integer variable;
            </param>
             <param name="HEAD">
             is an integer variable.
             On entry they store the information defining the
             limited memory BFGS matrix:
             ws(n,m) stores S, a set of s-vectors;
             wy(n,m) stores Y, a set of y-vectors;
             sy(m,m) stores S'Y;
             wtyy(m,m) stores the Cholesky factorization
             of (theta*S'S+LD^(-1)L')
             theta is the scaling factor specifying B_0 = theta I;
             col is the number of variable metric corrections stored;
             head is the location of the 1st s- (or y-) vector in S (or Y).
             On exit they are unchanged.
            </param>
             <param name="INFO">
             is an integer variable.
             On entry info is unspecified.
             On exit info =  0 for normal return;
             = -1 when the 1st Cholesky factorization failed;
             = -2 when the 2st Cholesky factorization failed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.MatrixDebuggerDisplay">
            <summary>
            Esta clase manda la informacion de cada elemento de la matriz para ser visualizada
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.MatrixComplexDebuggerDisplay">
            <summary>
            Esta clase manda la informacion de cada elemento de la matriz para ser visualizada
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.VectorDebuggerDisplay">
            <summary>
            Esta clase manda la informacion de cada elemento del vector para ser visualizada
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.VectorComplexDebuggerDisplay">
            <summary>
            Esta clase manda la informacion de cada elemento del vector para ser visualizada
            </summary>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.XERBLA">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             XERBLA  is an error handler for the LAPACK routines.
             It is called by an LAPACK routine if an input parameter has an
             invalid value.  A message is printed and execution stops.
             
             Installers may consider modifying the STOP statement in order to
             call system-specific exception-handling facilities.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.XERBLA.Run(System.String,System.Int32)">
             <summary>
             Purpose
             =======
             
             XERBLA  is an error handler for the LAPACK routines.
             It is called by an LAPACK routine if an input parameter has an
             invalid value.  A message is printed and execution stops.
             
             Installers may consider modifying the STOP statement in order to
             call system-specific exception-handling facilities.
             
            </summary>
             <param name="SRNAME">
             (input) CHARACTER*6
             The name of the routine which called XERBLA.
            </param>
             <param name="INFO">
             (input) INTEGER
             The position of the invalid parameter in the parameter list
             of the calling routine.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.LSAME">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             LSAME returns .TRUE. if CA is the same letter as CB regardless of
             case.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.LSAME.Run(System.String,System.String)">
             <summary>
             Purpose
             =======
             
             LSAME returns .TRUE. if CA is the same letter as CB regardless of
             case.
             
            </summary>
             <param name="CA">
             (input) CHARACTER*1
            </param>
             <param name="CB">
             (input) CHARACTER*1
             CA and CB specify the single characters to be compared.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRTI2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DTRTI2 computes the inverse of a real upper or lower triangular
             matrix.
             
             This is the Level 2 BLAS version of the algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRTI2.Run(System.String,System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DTRTI2 computes the inverse of a real upper or lower triangular
             matrix.
             
             This is the Level 2 BLAS version of the algorithm.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the matrix A is upper or lower triangular.
             = 'U':  Upper triangular
             = 'L':  Lower triangular
            </param>
             <param name="DIAG">
             (input) CHARACTER*1
             Specifies whether or not the matrix A is unit triangular.
             = 'N':  Non-unit triangular
             = 'U':  Unit triangular
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the triangular matrix A.  If UPLO = 'U', the
             leading n by n upper triangular part of the array A contains
             the upper triangular matrix, and the strictly lower
             triangular part of A is not referenced.  If UPLO = 'L', the
             leading n by n lower triangular part of the array A contains
             the lower triangular matrix, and the strictly upper
             triangular part of A is not referenced.  If DIAG = 'U', the
             diagonal elements of A are also not referenced and are
             assumed to be 1.
             
             On exit, the (triangular) inverse of the original matrix, in
             the same storage format.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -k, the k-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSYR2">
             <summary>
             Purpose
             =======
             
             DSYR2  performs the symmetric rank 2 operation
             
             A := alpha*x*y' + alpha*y*x' + A,
             
             where alpha is a scalar, x and y are n element vectors and A is an n
             by n symmetric matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSYR2.Run(System.String,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DSYR2  performs the symmetric rank 2 operation
             
             A := alpha*x*y' + alpha*y*x' + A,
             
             where alpha is a scalar, x and y are n element vectors and A is an n
             by n symmetric matrix.
             
            </summary>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
             
             UPLO = 'U' or 'u'   Only the upper triangular part of A
             is to be referenced.
             
             UPLO = 'L' or 'l'   Only the lower triangular part of A
             is to be referenced.
             
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.
            </param>
             <param name="X">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.
            </param>
             <param name="INCX">
             - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.
            </param>
             <param name="Y">
             - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.
            </param>
             <param name="INCY">
             - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.
            </param>
             <param name="A">
             := alpha*x*y' + alpha*y*x' + A,
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DRSCL">
             <summary>
             -- LAPACK auxiliary routine (version 3.0) --
             Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
             Courant Institute, Argonne National Lab, and Rice University
             September 30, 1994
             Purpose
             =======
             
             DRSCL multiplies an n-element real vector x by the real scalar 1/a.
             This is done without overflow or underflow as long as
             the final result x/a does not overflow or underflow.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DRSCL.Run(System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DRSCL multiplies an n-element real vector x by the real scalar 1/a.
             This is done without overflow or underflow as long as
             the final result x/a does not overflow or underflow.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of components of the vector x.
            </param>
             <param name="SA">
             (input) DOUBLE PRECISION
             The scalar a which is used to divide each component of x.
             SA must be .GE. 0, or the subroutine will divide by zero.
            </param>
             <param name="SX">
             (input/output) DOUBLE PRECISION array, dimension
             (1+(N-1)*abs(INCX))
             The n-element vector x.
            </param>
             <param name="INCX">
             (input) INTEGER
             The increment between successive values of the vector SX.
             .GT. 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1.LT. i.LE. n
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORGQL">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORGQL generates an M-by-N real matrix Q with orthonormal columns,
             which is defined as the last N columns of a product of K elementary
             reflectors of order M
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGEQLF.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORGQL.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORGQL generates an M-by-N real matrix Q with orthonormal columns,
             which is defined as the last N columns of a product of K elementary
             reflectors of order M
             
             Q  =  H(k) . . . H(2) H(1)
             
             as returned by DGEQLF.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix Q. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix Q. M .GE. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines the
             matrix Q. N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the (n-k+i)-th column must contain the vector which
             defines the elementary reflector H(i), for i = 1,2,...,k, as
             returned by DGEQLF in the last k columns of its array
             argument A.
             On exit, the M-by-N matrix Q.
            </param>
             <param name="LDA">
             (input) INTEGER
             The first dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGEQLF.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK. LWORK .GE. max(1,N).
             For optimum performance LWORK .GE. N*NB, where NB is the
             optimal blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument has an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLATRD">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLATRD reduces NB rows and columns of a real symmetric matrix A to
             symmetric tridiagonal form by an orthogonal similarity
             transformation Q' * A * Q, and returns the matrices V and W which are
             needed to apply the transformation to the unreduced part of A.
             
             If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
             matrix, of which the upper triangle is supplied;
             if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
             matrix, of which the lower triangle is supplied.
             
             This is an auxiliary routine called by DSYTRD.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLATRD.Run(System.String,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLATRD reduces NB rows and columns of a real symmetric matrix A to
             symmetric tridiagonal form by an orthogonal similarity
             transformation Q' * A * Q, and returns the matrices V and W which are
             needed to apply the transformation to the unreduced part of A.
             
             If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
             matrix, of which the upper triangle is supplied;
             if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
             matrix, of which the lower triangle is supplied.
             
             This is an auxiliary routine called by DSYTRD.
             
            </summary>
             <param name="UPLO">
             (input) CHARACTER*1
             Specifies whether the upper or lower triangular part of the
             symmetric matrix A is stored:
             = 'U': Upper triangular
             = 'L': Lower triangular
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.
            </param>
             <param name="NB">
             (input) INTEGER
             The number of rows and columns to be reduced.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the symmetric matrix A.  If UPLO = 'U', the leading
             n-by-n upper triangular part of A contains the upper
             triangular part of the matrix A, and the strictly lower
             triangular part of A is not referenced.  If UPLO = 'L', the
             leading n-by-n lower triangular part of A contains the lower
             triangular part of the matrix A, and the strictly upper
             triangular part of A is not referenced.
             On exit:
             if UPLO = 'U', the last NB columns have been reduced to
             tridiagonal form, with the diagonal elements overwriting
             the diagonal elements of A; the elements above the diagonal
             with the array TAU, represent the orthogonal matrix Q as a
             product of elementary reflectors;
             if UPLO = 'L', the first NB columns have been reduced to
             tridiagonal form, with the diagonal elements overwriting
             the diagonal elements of A; the elements below the diagonal
             with the array TAU, represent the  orthogonal matrix Q as a
             product of elementary reflectors.
             See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. (1,N).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (N-1)
             If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
             elements of the last NB columns of the reduced matrix;
             if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
             the first NB columns of the reduced matrix.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (N-1)
             The scalar factors of the elementary reflectors, stored in
             TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
             See Further Details.
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (LDW,NB)
             The n-by-nb matrix W required to update the unreduced part
             of A.
            </param>
             <param name="LDW">
             (input) INTEGER
             The leading dimension of the array W. LDW .GE. max(1,N).
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASQ1">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLASQ1 computes the singular values of a real N-by-N bidiagonal
             matrix with diagonal D and off-diagonal E. The singular values
             are computed to high relative accuracy, in the absence of
             denormalization, underflow and overflow. The algorithm was first
             presented in
             
             "Accurate singular values and differential qd algorithms" by K. V.
             Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
             1994,
             
             and the present implementation is described in "An implementation of
             the dqds Algorithm (Positive Case)", LAPACK Working Note.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASQ1.Run(System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLASQ1 computes the singular values of a real N-by-N bidiagonal
             matrix with diagonal D and off-diagonal E. The singular values
             are computed to high relative accuracy, in the absence of
             denormalization, underflow and overflow. The algorithm was first
             presented in
             
             "Accurate singular values and differential qd algorithms" by K. V.
             Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
             1994,
             
             and the present implementation is described in "An implementation of
             the dqds Algorithm (Positive Case)", LAPACK Working Note.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The number of rows and columns in the matrix. N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, D contains the diagonal elements of the
             bidiagonal matrix whose SVD is desired. On normal exit,
             D contains the singular values in decreasing order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, elements E(1:N-1) contain the off-diagonal elements
             of the bidiagonal matrix whose SVD is desired.
             On exit, E is overwritten.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (4*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
             .GT. 0: the algorithm failed
             = 1, a split was marked by a positive value in E
             = 2, current block of Z not diagonalized after 30*N
             iterations (in inner while loop)
             = 3, termination criterion of outer while loop not met 
             (program created more than N unreduced blocks)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD5">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This subroutine computes the square root of the I-th eigenvalue
             of a positive symmetric rank-one modification of a 2-by-2 diagonal
             matrix
             
             diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .
             
             The diagonal entries in the array D are assumed to satisfy
             
             0 .LE. D(i) .LT. D(j)  for  i .LT. j .
             
             We also assume RHO .GT. 0 and that the Euclidean norm of the vector
             Z is one.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD5.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double,System.Double@,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             This subroutine computes the square root of the I-th eigenvalue
             of a positive symmetric rank-one modification of a 2-by-2 diagonal
             matrix
             
             diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .
             
             The diagonal entries in the array D are assumed to satisfy
             
             0 .LE. D(i) .LT. D(j)  for  i .LT. j .
             
             We also assume RHO .GT. 0 and that the Euclidean norm of the vector
             Z is one.
             
            </summary>
             <param name="I">
             (input) INTEGER
             The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension ( 2 )
             The original eigenvalues.  We assume 0 .LE. D(1) .LT. D(2).
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( 2 )
             The components of the updating vector.
            </param>
             <param name="DELTA">
             (output) DOUBLE PRECISION array, dimension ( 2 )
             Contains (D(j) - sigma_I) in its  j-th component.
             The vector DELTA contains the information necessary
             to construct the eigenvectors.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The scalar in the symmetric updating formula.
            </param>
             <param name="DSIGMA">
             (output) DOUBLE PRECISION
             The computed sigma_I, the I-th updated eigenvalue.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension ( 2 )
             WORK contains (D(j) + sigma_I) in its  j-th component.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR4">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAQR4 computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR4.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAQR4 computes the eigenvalues of a Hessenberg matrix H
             and, optionally, the matrices T and Z from the Schur decomposition
             H = Z T Z**T, where T is an upper quasi-triangular matrix (the
             Schur form), and Z is the orthogonal matrix of Schur vectors.
             
             Optionally Z may be postmultiplied into an input orthogonal
             matrix Q so that this routine can give the Schur factorization
             of a matrix A which has been reduced to the Hessenberg form H
             by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
             
            </summary>
             <param name="WANTT">
             (input) LOGICAL
             = .TRUE. : the full Schur form T is required;
             = .FALSE.: only eigenvalues are required.
            </param>
             <param name="WANTZ">
             (input) LOGICAL
             = .TRUE. : the matrix of Schur vectors Z is required;
             = .FALSE.: Schur vectors are not required.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to DGEBAL, and then passed to DGEHRD when the
             matrix output by DGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </param>
             <param name="LDH">
             (input) INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </param>
             <param name="WR">
             (output) DOUBLE PRECISION array, dimension (IHI)
            </param>
             <param name="WI">
             (output) DOUBLE PRECISION array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </param>
             <param name="LDZ">
             (input) INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             
             If LWORK = -1, then DLAQR4 does a workspace query.
             In this case, DLAQR4 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
             
            </param>
             <param name="INFO">
             (output) INTEGER
             =  0:  successful exit
             .GT. 0:  if INFO = i, DLAQR4 failed to compute all of
             the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
             and WI contain those eigenvalues which have been
             successfully computed.  (Failures are rare.)
             
             If INFO .GT. 0 and WANT is .FALSE., then on exit,
             the remaining unconverged eigenvalues are the eigen-
             values of the upper Hessenberg matrix rows and
             columns ILO through INFO of the final, output
             value of H.
             
             If INFO .GT. 0 and WANTT is .TRUE., then on exit
             
             (*)  (initial value of H)*U  = U*(final value of H)
             
             where U is an orthogonal matrix.  The final
             value of H is upper Hessenberg and quasi-triangular
             in rows and columns INFO+1 through IHI.
             
             If INFO .GT. 0 and WANTZ is .TRUE., then on exit
             
             (final value of Z(ILO:IHI,ILOZ:IHIZ)
             =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
             
             where U is the orthogonal matrix in (*) (regard-
             less of the value of WANTT.)
             
             If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
             accessed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQP2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAQP2 computes a QR factorization with column pivoting of
             the block A(OFFSET+1:M,1:N).
             The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQP2.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAQP2 computes a QR factorization with column pivoting of
             the block A(OFFSET+1:M,1:N).
             The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix A. N .GE. 0.
            </param>
             <param name="OFFSET">
             (input) INTEGER
             The number of rows of the matrix A that must be pivoted
             but no factorized. OFFSET .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the upper triangle of block A(OFFSET+1:M,1:N) is 
             the triangular factor obtained; the elements in block
             A(OFFSET+1:M,1:N) below the diagonal, together with the
             array TAU, represent the orthogonal matrix Q as a product of
             elementary reflectors. Block A(1:OFFSET,1:N) has been
             accordingly pivoted, but no factorized.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="JPVT">
             (input/output) INTEGER array, dimension (N)
             On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
             to the front of A*P (a leading column); if JPVT(i) = 0,
             the i-th column of A is a free column.
             On exit, if JPVT(i) = k, then the i-th column of A*P
             was the k-th column of A.
            </param>
             <param name="TAU">
             (output) DOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors.
            </param>
             <param name="VN1">
             (input/output) DOUBLE PRECISION array, dimension (N)
             The vector with the partial column norms.
            </param>
             <param name="VN2">
             (input/output) DOUBLE PRECISION array, dimension (N)
             The vector with the exact column norms.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAPMT">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAPMT rearranges the columns of the M by N matrix X as specified
             by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
             If FORWRD = .TRUE.,  forward permutation:
             
             X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
             
             If FORWRD = .FALSE., backward permutation:
             
             X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAPMT.Run(System.Boolean,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLAPMT rearranges the columns of the M by N matrix X as specified
             by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
             If FORWRD = .TRUE.,  forward permutation:
             
             X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
             
             If FORWRD = .FALSE., backward permutation:
             
             X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
             
            </summary>
             <param name="FORWRD">
             (input) LOGICAL
             = .TRUE., forward permutation
             = .FALSE., backward permutation
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix X. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix X. N .GE. 0.
            </param>
             <param name="X">
             (input/output) DOUBLE PRECISION array, dimension (LDX,N)
             On entry, the M by N matrix X.
             On exit, X contains the permuted matrix X.
            </param>
             <param name="LDX">
             (input) INTEGER
             The leading dimension of the array X, LDX .GE. MAX(1,M).
            </param>
             <param name="K">
             (input/output) INTEGER array, dimension (N)
             On entry, K contains the permutation vector. K is used as
             internal workspace, but reset to its original value on
             output.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED2">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED2 merges the two sets of eigenvalues together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             eigenvalues are close together or if there is a tiny entry in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED2.Run(System.Int32@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED2 merges the two sets of eigenvalues together into a single
             sorted set.  Then it tries to deflate the size of the problem.
             There are two ways in which deflation can occur:  when two or more
             eigenvalues are close together or if there is a tiny entry in the
             Z vector.  For each such occurrence the order of the related secular
             equation problem is reduced by one.
             
            </summary>
             <param name="K">
             (output) INTEGER
             The number of non-deflated eigenvalues, and the order of the
             related secular equation. 0 .LE. K .LE.N.
            </param>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="N1">
             (input) INTEGER
             The location of the last eigenvalue in the leading sub-matrix.
             min(1,N) .LE. N1 .LE. N/2.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, D contains the eigenvalues of the two submatrices to
             be combined.
             On exit, D contains the trailing (N-K) updated eigenvalues
             (those which were deflated) sorted into increasing order.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
             On entry, Q contains the eigenvectors of two submatrices in
             the two square blocks with corners at (1,1), (N1,N1)
             and (N1+1, N1+1), (N,N).
             On exit, Q contains the trailing (N-K) updated eigenvectors
             (those which were deflated) in its last N-K columns.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="INDXQ">
             (input/output) INTEGER array, dimension (N)
             The permutation which separately sorts the two sub-problems
             in D into ascending order.  Note that elements in the second
             half of this permutation must first have N1 added to their
             values. Destroyed on exit.
            </param>
             <param name="RHO">
             (input/output) DOUBLE PRECISION
             On entry, the off-diagonal element associated with the rank-1
             cut which originally split the two submatrices which are now
             being recombined.
             On exit, RHO has been modified to the value required by
             DLAED3.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension (N)
             On entry, Z contains the updating vector (the last
             row of the first sub-eigenvector matrix and the first row of
             the second sub-eigenvector matrix).
             On exit, the contents of Z have been destroyed by the updating
             process.
            </param>
             <param name="DLAMDA">
             (output) DOUBLE PRECISION array, dimension (N)
             A copy of the first K eigenvalues which will be used by
             DLAED3 to form the secular equation.
            </param>
             <param name="W">
             (output) DOUBLE PRECISION array, dimension (N)
             The first k values of the final deflation-altered z-vector
             which will be passed to DLAED3.
            </param>
             <param name="Q2">
             (output) DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
             A copy of the first K eigenvectors which will be used by
             DLAED3 in a matrix multiply (DGEMM) to solve for the new
             eigenvectors.
            </param>
             <param name="INDX">
             (workspace) INTEGER array, dimension (N)
             The permutation used to sort the contents of DLAMDA into
             ascending order.
            </param>
             <param name="INDXC">
             (output) INTEGER array, dimension (N)
             The permutation used to arrange the columns of the deflated
             Q matrix into three groups:  the first group contains non-zero
             elements only at and above N1, the second contains
             non-zero elements only below N1, and the third is dense.
            </param>
             <param name="INDXP">
             (workspace) INTEGER array, dimension (N)
             The permutation used to place deflated values of D at the end
             of the array.  INDXP(1:K) points to the nondeflated D-values
             and INDXP(K+1:N) points to the deflated eigenvalues.
            </param>
             <param name="COLTYP">
             (workspace/output) INTEGER array, dimension (N)
             During execution, a label which will indicate which of the
             following types a column in the Q2 matrix is:
             1 : non-zero in the upper half only;
             2 : dense;
             3 : non-zero in the lower half only;
             4 : deflated.
             On exit, COLTYP(i) is the number of columns of type i,
             for i=1 to 4 only.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEBAL">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEBAL balances a general real matrix A.  This involves, first,
             permuting A by a similarity transformation to isolate eigenvalues
             in the first 1 to ILO-1 and last IHI+1 to N elements on the
             diagonal; and second, applying a diagonal similarity transformation
             to rows and columns ILO to IHI to make the rows and columns as
             close in norm as possible.  Both steps are optional.
             
             Balancing may reduce the 1-norm of the matrix, and improve the
             accuracy of the computed eigenvalues and/or eigenvectors.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEBAL.Run(System.String,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEBAL balances a general real matrix A.  This involves, first,
             permuting A by a similarity transformation to isolate eigenvalues
             in the first 1 to ILO-1 and last IHI+1 to N elements on the
             diagonal; and second, applying a diagonal similarity transformation
             to rows and columns ILO to IHI to make the rows and columns as
             close in norm as possible.  Both steps are optional.
             
             Balancing may reduce the 1-norm of the matrix, and improve the
             accuracy of the computed eigenvalues and/or eigenvectors.
             
            </summary>
             <param name="JOB">
             (input) CHARACTER*1
             Specifies the operations to be performed on A:
             = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
             for i = 1,...,N;
             = 'P':  permute only;
             = 'S':  scale only;
             = 'B':  both permute and scale.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the input matrix A.
             On exit,  A is overwritten by the balanced matrix.
             If JOB = 'N', A is not referenced.
             See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="ILO">
             (output) INTEGER
            </param>
             <param name="IHI">
             (output) INTEGER
             ILO and IHI are set to integers such that on exit
             A(i,j) = 0 if i .GT. j and j = 1,...,ILO-1 or I = IHI+1,...,N.
             If JOB = 'N' or 'S', ILO = 1 and IHI = N.
            </param>
             <param name="SCALE">
             (output) DOUBLE PRECISION array, dimension (N)
             Details of the permutations and scaling factors applied to
             A.  If P(j) is the index of the row and column interchanged
             with row and column j and D(j) is the scaling factor
             applied to row and column j, then
             SCALE(j) = P(j)    for j = 1,...,ILO-1
             = D(j)    for j = ILO,...,IHI
             = P(j)    for j = IHI+1,...,N.
             The order in which the interchanges are made is N to IHI+1,
             then 1 to ILO-1.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DTRSM">
             <summary>
             Purpose
             =======
             
             DTRSM  solves one of the matrix equations
             
             op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
             
             where alpha is a scalar, X and B are m by n matrices, A is a unit, or
             non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
             
             op( A ) = A   or   op( A ) = A'.
             
             The matrix X is overwritten on B.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DTRSM.Run(System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DTRSM  solves one of the matrix equations
             
             op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
             
             where alpha is a scalar, X and B are m by n matrices, A is a unit, or
             non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
             
             op( A ) = A   or   op( A ) = A'.
             
             The matrix X is overwritten on B.
             
            </summary>
             <param name="SIDE">
             - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
             
             SIDE = 'L' or 'l'   op( A )*X = alpha*B.
             
             SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
             
             Unchanged on exit.
            </param>
             <param name="UPLO">
             - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
             
             UPLO = 'U' or 'u'   A is an upper triangular matrix.
             
             UPLO = 'L' or 'l'   A is a lower triangular matrix.
             
             Unchanged on exit.
            </param>
             <param name="TRANSA">
             - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
             
             TRANSA = 'N' or 'n'   op( A ) = A.
             
             TRANSA = 'T' or 't'   op( A ) = A'.
             
             TRANSA = 'C' or 'c'   op( A ) = A'.
             
             Unchanged on exit.
            </param>
             <param name="DIAG">
             - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
             
             DIAG = 'U' or 'u'   A is assumed to be unit triangular.
             
             DIAG = 'N' or 'n'   A is not assumed to be unit
             triangular.
             
             Unchanged on exit.
            </param>
             <param name="M">
             - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.
            </param>
             <param name="N">
             - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.
            </param>
             <param name="ALPHA">
             - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.
            </param>
             <param name="A">
             - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.
            </param>
             <param name="LDA">
             - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.
            </param>
             <param name="B">
             - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </param>
             <param name="LDB">
             - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DSTERF">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
             using the Pal-Walker-Kahan variant of the QL or QR algorithm.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DSTERF.Run(System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
             using the Pal-Walker-Kahan variant of the QL or QR algorithm.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the n diagonal elements of the tridiagonal matrix.
             On exit, if INFO = 0, the eigenvalues in ascending order.
            </param>
             <param name="E">
             (input/output) DOUBLE PRECISION array, dimension (N-1)
             On entry, the (n-1) subdiagonal elements of the tridiagonal
             matrix.
             On exit, E has been destroyed.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  the algorithm failed to find all of the eigenvalues in
             a total of 30*N iterations; if INFO = i, then i
             elements of E have not converged to zero.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMR3">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMR3 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMR3.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMR3 overwrites the general real m by n matrix C with
             
             Q * C  if SIDE = 'L' and TRANS = 'N', or
             
             Q'* C  if SIDE = 'L' and TRANS = 'T', or
             
             C * Q  if SIDE = 'R' and TRANS = 'N', or
             
             C * Q' if SIDE = 'R' and TRANS = 'T',
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(1) H(2) . . . H(k)
             
             as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': apply Q or Q' from the Left
             = 'R': apply Q or Q' from the Right
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N': apply Q  (No transpose)
             = 'T': apply Q' (Transpose)
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="L">
             (input) INTEGER
             The number of columns of the matrix A containing
             the meaningful part of the Householder reflectors.
             If SIDE = 'L', M .GE. L .GE. 0, if SIDE = 'R', N .GE. L .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DTZRZF in the last k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DTZRZF.
            </param>
             <param name="C">
             * Q  if SIDE = 'R' and TRANS = 'N', or
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L',
             (M) if SIDE = 'R'
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0: successful exit
             .LT. 0: if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DORMLQ">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DORMLQ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DORMLQ.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DORMLQ overwrites the general real M-by-N matrix C with
             
             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T
             
             where Q is a real orthogonal matrix defined as the product of k
             elementary reflectors
             
             Q = H(k) . . . H(2) H(1)
             
             as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
             if SIDE = 'R'.
             
            </summary>
             <param name="SIDE">
             = 'L'     SIDE = 'R'
            </param>
             <param name="TRANS">
             (input) CHARACTER*1
             = 'N':  No transpose, apply Q;
             = 'T':  Transpose, apply Q**T.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C. M .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C. N .GE. 0.
            </param>
             <param name="K">
             (input) INTEGER
             The number of elementary reflectors whose product defines
             the matrix Q.
             If SIDE = 'L', M .GE. K .GE. 0;
             if SIDE = 'R', N .GE. K .GE. 0.
            </param>
             <param name="A">
             (input) DOUBLE PRECISION array, dimension
             (LDA,M) if SIDE = 'L',
             (LDA,N) if SIDE = 'R'
             The i-th row must contain the vector which defines the
             elementary reflector H(i), for i = 1,2,...,k, as returned by
             DGELQF in the first k rows of its array argument A.
             A is modified by the routine but restored on exit.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,K).
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION array, dimension (K)
             TAU(i) must contain the scalar factor of the elementary
             reflector H(i), as returned by DGELQF.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the M-by-N matrix C.
             On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.
             If SIDE = 'L', LWORK .GE. max(1,N);
             if SIDE = 'R', LWORK .GE. max(1,M).
             For optimum performance LWORK .GE. N*NB if SIDE = 'L', and
             LWORK .GE. M*NB if SIDE = 'R', where NB is the optimal
             blocksize.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLASD4">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             This subroutine computes the square root of the I-th updated
             eigenvalue of a positive symmetric rank-one modification to
             a positive diagonal matrix whose entries are given as the squares
             of the corresponding entries in the array d, and that
             
             0 .LE. D(i) .LT. D(j)  for  i .LT. j
             
             and that RHO .GT. 0. This is arranged by the calling routine, and is
             no loss in generality.  The rank-one modified system is thus
             
             diag( D ) * diag( D ) +  RHO *  Z * Z_transpose.
             
             where we assume the Euclidean norm of Z is 1.
             
             The method consists of approximating the rational functions in the
             secular equation by simpler interpolating rational functions.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLASD4.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double,System.Double@,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             This subroutine computes the square root of the I-th updated
             eigenvalue of a positive symmetric rank-one modification to
             a positive diagonal matrix whose entries are given as the squares
             of the corresponding entries in the array d, and that
             
             0 .LE. D(i) .LT. D(j)  for  i .LT. j
             
             and that RHO .GT. 0. This is arranged by the calling routine, and is
             no loss in generality.  The rank-one modified system is thus
             
             diag( D ) * diag( D ) +  RHO *  Z * Z_transpose.
             
             where we assume the Euclidean norm of Z is 1.
             
             The method consists of approximating the rational functions in the
             secular equation by simpler interpolating rational functions.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The length of all arrays.
            </param>
             <param name="I">
             (input) INTEGER
             The index of the eigenvalue to be computed.  1 .LE. I .LE. N.
            </param>
             <param name="D">
             (input) DOUBLE PRECISION array, dimension ( N )
             The original eigenvalues.  It is assumed that they are in
             order, 0 .LE. D(I) .LT. D(J)  for I .LT. J.
            </param>
             <param name="Z">
             (input) DOUBLE PRECISION array, dimension ( N )
             The components of the updating vector.
            </param>
             <param name="DELTA">
             (output) DOUBLE PRECISION array, dimension ( N )
             If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
             component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
             contains the information necessary to construct the
             (singular) eigenvectors.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The scalar in the symmetric updating formula.
            </param>
             <param name="SIGMA">
             (output) DOUBLE PRECISION
             The computed sigma_I, the I-th updated eigenvalue.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension ( N )
             If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
             component.  If N = 1, then WORK( 1 ) = 1.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .GT. 0:  if INFO = 1, the updating process failed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARTG">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARTG generate a plane rotation so that
             
             [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
             [ -SN  CS  ]     [ G ]     [ 0 ]
             
             This is a slower, more accurate version of the BLAS1 routine DROTG,
             with the following other differences:
             F and G are unchanged on return.
             If G=0, then CS=1 and SN=0.
             If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
             floating point operations (saves work in DBDSQR when
             there are zeros on the diagonal).
             
             If F exceeds G in magnitude, CS will be positive.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARTG.Run(System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLARTG generate a plane rotation so that
             
             [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
             [ -SN  CS  ]     [ G ]     [ 0 ]
             
             This is a slower, more accurate version of the BLAS1 routine DROTG,
             with the following other differences:
             F and G are unchanged on return.
             If G=0, then CS=1 and SN=0.
             If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
             floating point operations (saves work in DBDSQR when
             there are zeros on the diagonal).
             
             If F exceeds G in magnitude, CS will be positive.
             
            </summary>
             <param name="F">
             (input) DOUBLE PRECISION
             The first component of vector to be rotated.
            </param>
             <param name="G">
             (input) DOUBLE PRECISION
             The second component of vector to be rotated.
            </param>
             <param name="CS">
             (output) DOUBLE PRECISION
             The cosine of the rotation.
            </param>
             <param name="SN">
             (output) DOUBLE PRECISION
             The sine of the rotation.
            </param>
             <param name="R">
             (output) DOUBLE PRECISION
             The nonzero component of the rotated vector.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLARF">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLARF applies a real elementary reflector H to a real m by n matrix
             C, from either the left or the right. H is represented in the form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLARF.Run(System.String,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLARF applies a real elementary reflector H to a real m by n matrix
             C, from either the left or the right. H is represented in the form
             
             H = I - tau * v * v'
             
             where tau is a real scalar and v is a real vector.
             
             If tau = 0, then H is taken to be the unit matrix.
             
            </summary>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'L': form  H * C
             = 'R': form  C * H
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix C.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrix C.
            </param>
             <param name="V">
             (input) DOUBLE PRECISION array, dimension
             (1 + (M-1)*abs(INCV)) if SIDE = 'L'
             or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
             The vector v in the representation of H. V is not used if
             TAU = 0.
            </param>
             <param name="INCV">
             (input) INTEGER
             The increment between elements of v. INCV .LT..GT. 0.
            </param>
             <param name="TAU">
             (input) DOUBLE PRECISION
             The value tau in the representation of H.
            </param>
             <param name="C">
             (input/output) DOUBLE PRECISION array, dimension (LDC,N)
             On entry, the m by n matrix C.
             On exit, C is overwritten by the matrix H * C if SIDE = 'L',
             or C * H if SIDE = 'R'.
            </param>
             <param name="LDC">
             (input) INTEGER
             The leading dimension of the array C. LDC .GE. max(1,M).
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension
             (N) if SIDE = 'L'
             or (M) if SIDE = 'R'
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAQR3">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAQR3.Run(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <param name="WANTT">
             (input) LOGICAL
             If .TRUE., then the Hessenberg matrix H is fully updated
             so that the quasi-triangular Schur factor may be
             computed (in cooperation with the calling subroutine).
             If .FALSE., then only enough of H is updated to preserve
             the eigenvalues.
            </param>
             <param name="WANTZ">
             (input) LOGICAL
             If .TRUE., then the orthogonal matrix Z is updated so
             so that the orthogonal Schur factor may be computed
             (in cooperation with the calling subroutine).
             If .FALSE., then Z is not referenced.
            </param>
             <param name="N">
             (input) INTEGER
             The order of the matrix H and (if WANTZ is .TRUE.) the
             order of the orthogonal matrix Z.
            </param>
             <param name="KTOP">
             (input) INTEGER
             It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
             KBOT and KTOP together determine an isolated block
             along the diagonal of the Hessenberg matrix.
            </param>
             <param name="KBOT">
             (input) INTEGER
             It is assumed without a check that either
             KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
             determine an isolated block along the diagonal of the
             Hessenberg matrix.
            </param>
             <param name="NW">
             (input) INTEGER
             Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </param>
             <param name="H">
             (input/output) DOUBLE PRECISION array, dimension (LDH,N)
             On input the initial N-by-N section of H stores the
             Hessenberg matrix undergoing aggressive early deflation.
             On output H has been transformed by an orthogonal
             similarity transformation, perturbed, and the returned
             to Hessenberg form that (it is to be hoped) has some
             zero subdiagonal entries.
            </param>
             <param name="LDH">
             (input) integer
             Leading dimension of H just as declared in the calling
             subroutine.  N .LE. LDH
            </param>
             <param name="ILOZ">
             (input) INTEGER
            </param>
             <param name="IHIZ">
             (input) INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </param>
             <param name="Z">
             (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
             IF WANTZ is .TRUE., then on output, the orthogonal
             similarity transformation mentioned above has been
             accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
             If WANTZ is .FALSE., then Z is unreferenced.
            </param>
             <param name="LDZ">
             (input) integer
             The leading dimension of Z just as declared in the
             calling subroutine.  1 .LE. LDZ.
            </param>
             <param name="NS">
             (output) integer
             The number of unconverged (ie approximate) eigenvalues
             returned in SR and SI that may be used as shifts by the
             calling subroutine.
            </param>
             <param name="ND">
             (output) integer
             The number of converged eigenvalues uncovered by this
             subroutine.
            </param>
             <param name="SR">
             (output) DOUBLE PRECISION array, dimension KBOT
            </param>
             <param name="SI">
             (output) DOUBLE PRECISION array, dimension KBOT
             On output, the real and imaginary parts of approximate
             eigenvalues that may be used for shifts are stored in
             SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
             SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
             The real and imaginary parts of converged eigenvalues
             are stored in SR(KBOT-ND+1) through SR(KBOT) and
             SI(KBOT-ND+1) through SI(KBOT), respectively.
            </param>
             <param name="V">
             (workspace) DOUBLE PRECISION array, dimension (LDV,NW)
             An NW-by-NW work array.
            </param>
             <param name="LDV">
             (input) integer scalar
             The leading dimension of V just as declared in the
             calling subroutine.  NW .LE. LDV
            </param>
             <param name="NH">
             (input) integer scalar
             The number of columns of T.  NH.GE.NW.
            </param>
             <param name="T">
             (workspace) DOUBLE PRECISION array, dimension (LDT,NW)
            </param>
             <param name="LDT">
             (input) integer
             The leading dimension of T just as declared in the
             calling subroutine.  NW .LE. LDT
            </param>
             <param name="NV">
             (input) integer
             The number of rows of work array WV available for
             workspace.  NV.GE.NW.
            </param>
             <param name="WV">
             (workspace) DOUBLE PRECISION array, dimension (LDWV,NW)
            </param>
             <param name="LDWV">
             (input) integer
             The leading dimension of W just as declared in the
             calling subroutine.  NW .LE. LDV
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension LWORK.
             On exit, WORK(1) is set to an estimate of the optimal value
             of LWORK for the given values of N, NW, KTOP and KBOT.
            </param>
             <param name="LWORK">
             (input) integer
             The dimension of the work array WORK.  LWORK = 2*NW
             suffices, but greater efficiency may result from larger
             values of LWORK.
             
             If LWORK = -1, then a workspace query is assumed; DLAQR3
             only estimates the optimal workspace size for the given
             values of N, NW, KTOP and KBOT.  The estimate is returned
             in WORK(1).  No error message related to LWORK is issued
             by XERBLA.  Neither H nor Z are accessed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAEV2">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
             [  A   B  ]
             [  B   C  ].
             On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
             eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
             eigenvector for RT1, giving the decomposition
             
             [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
             [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAEV2.Run(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
             [  A   B  ]
             [  B   C  ].
             On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
             eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
             eigenvector for RT1, giving the decomposition
             
             [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
             [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
             
            </summary>
             <param name="A">
             (input) DOUBLE PRECISION
             The (1,1) element of the 2-by-2 matrix.
            </param>
             <param name="B">
             (input) DOUBLE PRECISION
             The (1,2) element and the conjugate of the (2,1) element of
             the 2-by-2 matrix.
            </param>
             <param name="C">
             (input) DOUBLE PRECISION
             The (2,2) element of the 2-by-2 matrix.
            </param>
             <param name="RT1">
             (output) DOUBLE PRECISION
             The eigenvalue of larger absolute value.
            </param>
             <param name="RT2">
             (output) DOUBLE PRECISION
             The eigenvalue of smaller absolute value.
            </param>
             <param name="CS1">
             (output) DOUBLE PRECISION
            </param>
             <param name="SN1">
             (output) DOUBLE PRECISION
             The vector (CS1, SN1) is a unit right eigenvector for RT1.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLAED1">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLAED1 computes the updated eigensystem of a diagonal
             matrix after modification by a rank-one symmetric matrix.  This
             routine is used only for the eigenproblem which requires all
             eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
             the case in which eigenvalues only or eigenvalues and eigenvectors
             of a full symmetric matrix (which was reduced to tridiagonal form)
             are desired.
             
             T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
             
             where Z = Q'u, u is a vector of length N with ones in the
             CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
             
             The eigenvectors of the original matrix are stored in Q, and the
             eigenvalues are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple eigenvalues or if there is a zero in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLAED2.
             
             The second stage consists of calculating the updated
             eigenvalues. This is done by finding the roots of the secular
             equation via the routine DLAED4 (as called by DLAED3).
             This routine also calculates the eigenvectors of the current
             problem.
             
             The final stage consists of computing the updated eigenvectors
             directly using the updated eigenvalues.  The eigenvectors for
             the current problem are multiplied with the eigenvectors from
             the overall problem.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLAED1.Run(System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DLAED1 computes the updated eigensystem of a diagonal
             matrix after modification by a rank-one symmetric matrix.  This
             routine is used only for the eigenproblem which requires all
             eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
             the case in which eigenvalues only or eigenvalues and eigenvectors
             of a full symmetric matrix (which was reduced to tridiagonal form)
             are desired.
             
             T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
             
             where Z = Q'u, u is a vector of length N with ones in the
             CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
             
             The eigenvectors of the original matrix are stored in Q, and the
             eigenvalues are in D.  The algorithm consists of three stages:
             
             The first stage consists of deflating the size of the problem
             when there are multiple eigenvalues or if there is a zero in
             the Z vector.  For each such occurence the dimension of the
             secular equation problem is reduced by one.  This stage is
             performed by the routine DLAED2.
             
             The second stage consists of calculating the updated
             eigenvalues. This is done by finding the roots of the secular
             equation via the routine DLAED4 (as called by DLAED3).
             This routine also calculates the eigenvectors of the current
             problem.
             
             The final stage consists of computing the updated eigenvectors
             directly using the updated eigenvalues.  The eigenvectors for
             the current problem are multiplied with the eigenvectors from
             the overall problem.
             
            </summary>
             <param name="N">
             (input) INTEGER
             The dimension of the symmetric tridiagonal matrix.  N .GE. 0.
            </param>
             <param name="D">
             (input/output) DOUBLE PRECISION array, dimension (N)
             On entry, the eigenvalues of the rank-1-perturbed matrix.
             On exit, the eigenvalues of the repaired matrix.
            </param>
             <param name="Q">
             (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
             On entry, the eigenvectors of the rank-1-perturbed matrix.
             On exit, the eigenvectors of the repaired tridiagonal matrix.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q.  LDQ .GE. max(1,N).
            </param>
             <param name="INDXQ">
             (input/output) INTEGER array, dimension (N)
             On entry, the permutation which separately sorts the two
             subproblems in D into ascending order.
             On exit, the permutation which will reintegrate the
             subproblems back into sorted order,
             i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
            </param>
             <param name="RHO">
             (input) DOUBLE PRECISION
             The subdiagonal entry used to create the rank-1 modification.
            </param>
             <param name="CUTPNT">
             (input) INTEGER
             The location of the last eigenvalue in the leading sub-matrix.
             min(1,N) .LE. CUTPNT .LE. N/2.
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (4*N + N**2)
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (4*N)
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit.
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             .GT. 0:  if INFO = 1, an eigenvalue did not converge
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLABRD">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLABRD reduces the first NB rows and columns of a real general
             m by n matrix A to upper or lower bidiagonal form by an orthogonal
             transformation Q' * A * P, and returns the matrices X and Y which
             are needed to apply the transformation to the unreduced part of A.
             
             If m .GE. n, A is reduced to upper bidiagonal form; if m .LT. n, to lower
             bidiagonal form.
             
             This is an auxiliary routine called by DGEBRD
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLABRD.Run(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             Purpose
             =======
             
             DLABRD reduces the first NB rows and columns of a real general
             m by n matrix A to upper or lower bidiagonal form by an orthogonal
             transformation Q' * A * P, and returns the matrices X and Y which
             are needed to apply the transformation to the unreduced part of A.
             
             If m .GE. n, A is reduced to upper bidiagonal form; if m .LT. n, to lower
             bidiagonal form.
             
             This is an auxiliary routine called by DGEBRD
             
            </summary>
             <param name="M">
             (input) INTEGER
             The number of rows in the matrix A.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns in the matrix A.
            </param>
             <param name="NB">
             (input) INTEGER
             The number of leading rows and columns of A to be reduced.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the m by n general matrix to be reduced.
             On exit, the first NB rows and columns of the matrix are
             overwritten; the rest of the array is unchanged.
             If m .GE. n, elements on and below the diagonal in the first NB
             columns, with the array TAUQ, represent the orthogonal
             matrix Q as a product of elementary reflectors; and
             elements above the diagonal in the first NB rows, with the
             array TAUP, represent the orthogonal matrix P as a product
             of elementary reflectors.
             If m .LT. n, elements below the diagonal in the first NB
             columns, with the array TAUQ, represent the orthogonal
             matrix Q as a product of elementary reflectors, and
             elements on and above the diagonal in the first NB rows,
             with the array TAUP, represent the orthogonal matrix P as
             a product of elementary reflectors.
             See Further Details.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,M).
            </param>
             <param name="D">
             (output) DOUBLE PRECISION array, dimension (NB)
             The diagonal elements of the first NB rows and columns of
             the reduced matrix.  D(i) = A(i,i).
            </param>
             <param name="E">
             (output) DOUBLE PRECISION array, dimension (NB)
             The off-diagonal elements of the first NB rows and columns of
             the reduced matrix.
            </param>
             <param name="TAUQ">
             (output) DOUBLE PRECISION array dimension (NB)
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix Q. See Further Details.
            </param>
             <param name="TAUP">
             (output) DOUBLE PRECISION array, dimension (NB)
             The scalar factors of the elementary reflectors which
             represent the orthogonal matrix P. See Further Details.
            </param>
             <param name="X">
             (output) DOUBLE PRECISION array, dimension (LDX,NB)
             The m-by-nb matrix X required to update the unreduced part
             of A.
            </param>
             <param name="LDX">
             (input) INTEGER
             The leading dimension of the array X. LDX .GE. M.
            </param>
             <param name="Y">
             (output) DOUBLE PRECISION array, dimension (LDY,NB)
             The n-by-nb matrix Y required to update the unreduced part
             of A.
            </param>
             <param name="LDY">
             (input) INTEGER
             The leading dimension of the array Y. LDY .GE. N.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DLABAD">
             <summary>
             -- LAPACK auxiliary routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DLABAD takes as input the values computed by DLAMCH for underflow and
             overflow, and returns the square root of each of these values if the
             log of LARGE is sufficiently large.  This subroutine is intended to
             identify machines with a large exponent range, such as the Crays, and
             redefine the underflow and overflow limits to be the square roots of
             the values computed by DLAMCH.  This subroutine is needed because
             DLAMCH does not compensate for poor arithmetic in the upper half of
             the exponent range, as is found on a Cray.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DLABAD.Run(System.Double@,System.Double@)">
             <summary>
             Purpose
             =======
             
             DLABAD takes as input the values computed by DLAMCH for underflow and
             overflow, and returns the square root of each of these values if the
             log of LARGE is sufficiently large.  This subroutine is intended to
             identify machines with a large exponent range, such as the Crays, and
             redefine the underflow and overflow limits to be the square roots of
             the values computed by DLAMCH.  This subroutine is needed because
             DLAMCH does not compensate for poor arithmetic in the upper half of
             the exponent range, as is found on a Cray.
             
            </summary>
             <param name="SMALL">
             (input/output) DOUBLE PRECISION
             On entry, the underflow threshold as computed by DLAMCH.
             On exit, if LOG10(LARGE) is sufficiently large, the square
             root of SMALL, otherwise unchanged.
            </param>
             <param name="LARGE">
             (input/output) DOUBLE PRECISION
             On entry, the overflow threshold as computed by DLAMCH.
             On exit, if LOG10(LARGE) is sufficiently large, the square
             root of LARGE, otherwise unchanged.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGGSVP">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGGSVP computes orthogonal matrices U, V and Q such that
             
             N-K-L  K    L
             U'*A*Q =     K ( 0    A12  A13 )  if M-K-L .GE. 0;
             L ( 0     0   A23 )
             M-K-L ( 0     0    0  )
             
             N-K-L  K    L
             =     K ( 0    A12  A13 )  if M-K-L .LT. 0;
             M-K ( 0     0   A23 )
             
             N-K-L  K    L
             V'*B*Q =   L ( 0     0   B13 )
             P-L ( 0     0    0  )
             
             where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
             upper triangular; A23 is L-by-L upper triangular if M-K-L .GE. 0,
             otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
             numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
             transpose of Z.
             
             This decomposition is the preprocessing step for computing the
             Generalized Singular Value Decomposition (GSVD), see subroutine
             DGGSVD.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGGSVP.Run(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double,System.Double,System.Int32@,System.Int32@,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGGSVP computes orthogonal matrices U, V and Q such that
             
             N-K-L  K    L
             U'*A*Q =     K ( 0    A12  A13 )  if M-K-L .GE. 0;
             L ( 0     0   A23 )
             M-K-L ( 0     0    0  )
             
             N-K-L  K    L
             =     K ( 0    A12  A13 )  if M-K-L .LT. 0;
             M-K ( 0     0   A23 )
             
             N-K-L  K    L
             V'*B*Q =   L ( 0     0   B13 )
             P-L ( 0     0    0  )
             
             where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
             upper triangular; A23 is L-by-L upper triangular if M-K-L .GE. 0,
             otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
             numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
             transpose of Z.
             
             This decomposition is the preprocessing step for computing the
             Generalized Singular Value Decomposition (GSVD), see subroutine
             DGGSVD.
             
            </summary>
             <param name="JOBU">
             (input) CHARACTER*1
             = 'U':  Orthogonal matrix U is computed;
             = 'N':  U is not computed.
            </param>
             <param name="JOBV">
             (input) CHARACTER*1
             = 'V':  Orthogonal matrix V is computed;
             = 'N':  V is not computed.
            </param>
             <param name="JOBQ">
             (input) CHARACTER*1
             = 'Q':  Orthogonal matrix Q is computed;
             = 'N':  Q is not computed.
            </param>
             <param name="M">
             (input) INTEGER
             The number of rows of the matrix A.  M .GE. 0.
            </param>
             <param name="P">
             (input) INTEGER
             The number of rows of the matrix B.  P .GE. 0.
            </param>
             <param name="N">
             (input) INTEGER
             The number of columns of the matrices A and B.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, A contains the triangular (or trapezoidal) matrix
             described in the Purpose section.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A. LDA .GE. max(1,M).
            </param>
             <param name="B">
             (input/output) DOUBLE PRECISION array, dimension (LDB,N)
             On entry, the P-by-N matrix B.
             On exit, B contains the triangular matrix described in
             the Purpose section.
            </param>
             <param name="LDB">
             (input) INTEGER
             The leading dimension of the array B. LDB .GE. max(1,P).
            </param>
             <param name="TOLA">
             (input) DOUBLE PRECISION
            </param>
             <param name="TOLB">
             (input) DOUBLE PRECISION
             TOLA and TOLB are the thresholds to determine the effective
             numerical rank of matrix B and a subblock of A. Generally,
             they are set to
             TOLA = MAX(M,N)*norm(A)*MAZHEPS,
             TOLB = MAX(P,N)*norm(B)*MAZHEPS.
             The size of TOLA and TOLB may affect the size of backward
             errors of the decomposition.
            </param>
             <param name="K">
             (output) INTEGER
            </param>
             <param name="L">
             ( 0     0   A23 )
            </param>
             <param name="U">
             (output) DOUBLE PRECISION array, dimension (LDU,M)
             If JOBU = 'U', U contains the orthogonal matrix U.
             If JOBU = 'N', U is not referenced.
            </param>
             <param name="LDU">
             (input) INTEGER
             The leading dimension of the array U. LDU .GE. max(1,M) if
             JOBU = 'U'; LDU .GE. 1 otherwise.
            </param>
             <param name="V">
             (output) DOUBLE PRECISION array, dimension (LDV,M)
             If JOBV = 'V', V contains the orthogonal matrix V.
             If JOBV = 'N', V is not referenced.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V. LDV .GE. max(1,P) if
             JOBV = 'V'; LDV .GE. 1 otherwise.
            </param>
             <param name="Q">
             (output) DOUBLE PRECISION array, dimension (LDQ,N)
             If JOBQ = 'Q', Q contains the orthogonal matrix Q.
             If JOBQ = 'N', Q is not referenced.
            </param>
             <param name="LDQ">
             (input) INTEGER
             The leading dimension of the array Q. LDQ .GE. max(1,N) if
             JOBQ = 'Q'; LDQ .GE. 1 otherwise.
            </param>
             <param name="IWORK">
             (workspace) INTEGER array, dimension (N)
            </param>
             <param name="TAU">
             (workspace) DOUBLE PRECISION array, dimension (N)
            </param>
             <param name="WORK">
             (workspace) DOUBLE PRECISION array, dimension (max(3*N,M,P))
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
             
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGETRI">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGETRI computes the inverse of a matrix using the LU factorization
             computed by DGETRF.
             
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGETRI.Run(System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGETRI computes the inverse of a matrix using the LU factorization
             computed by DGETRF.
             
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
             
            </summary>
             <param name="N">
             (input) INTEGER
             The order of the matrix A.  N .GE. 0.
            </param>
             <param name="A">
             (input/output) DOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the factorization
             A = P*L*U as computed by DGETRF.
             On exit, if INFO = 0, the inverse of the original matrix A.
            </param>
             <param name="LDA">
             (input) INTEGER
             The leading dimension of the array A.  LDA .GE. max(1,N).
            </param>
             <param name="IPIV">
             (input) INTEGER array, dimension (N)
             The pivot indices from DGETRF; for 1.LE.i.LE.N, row i of the
             matrix was interchanged with row IPIV(i).
            </param>
             <param name="WORK">
             (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
             On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
            </param>
             <param name="LWORK">
             (input) INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N).
             For optimal performance LWORK .GE. N*NB, where NB is
             the optimal blocksize returned by ILAENV.
             
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value
             .GT. 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </param>
        </member>
        <member name="T:DotNumerics.LinearAlgebra.CSLapack.DGEBAK">
             <summary>
             -- LAPACK routine (version 3.1) --
             Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
             November 2006
             Purpose
             =======
             
             DGEBAK forms the right or left eigenvectors of a real general matrix
             by backward transformation on the computed eigenvectors of the
             balanced matrix output by DGEBAL.
             
            </summary>
        </member>
        <member name="M:DotNumerics.LinearAlgebra.CSLapack.DGEBAK.Run(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32@)">
             <summary>
             Purpose
             =======
             
             DGEBAK forms the right or left eigenvectors of a real general matrix
             by backward transformation on the computed eigenvectors of the
             balanced matrix output by DGEBAL.
             
            </summary>
             <param name="JOB">
             (input) CHARACTER*1
             Specifies the type of backward transformation required:
             = 'N', do nothing, return immediately;
             = 'P', do backward transformation for permutation only;
             = 'S', do backward transformation for scaling only;
             = 'B', do backward transformations for both permutation and
             scaling.
             JOB must be the same as the argument JOB supplied to DGEBAL.
            </param>
             <param name="SIDE">
             (input) CHARACTER*1
             = 'R':  V contains right eigenvectors;
             = 'L':  V contains left eigenvectors.
            </param>
             <param name="N">
             (input) INTEGER
             The number of rows of the matrix V.  N .GE. 0.
            </param>
             <param name="ILO">
             (input) INTEGER
            </param>
             <param name="IHI">
             (input) INTEGER
             The integers ILO and IHI determined by DGEBAL.
             1 .LE. ILO .LE. IHI .LE. N, if N .GT. 0; ILO=1 and IHI=0, if N=0.
            </param>
             <param name="SCALE">
             (input) DOUBLE PRECISION array, dimension (N)
             Details of the permutation and scaling factors, as returned
             by DGEBAL.
            </param>
             <param name="M">
             (input) INTEGER
             The number of columns of the matrix V.  M .GE. 0.
            </param>
             <param name="V">
             (input/output) DOUBLE PRECISION array, dimension (LDV,M)
             On entry, the matrix of right or left eigenvectors to be
             transformed, as returned by DHSEIN or DTREVC.
             On exit, V is overwritten by the transformed eigenvectors.
            </param>
             <param name="LDV">
             (input) INTEGER
             The leading dimension of the array V. LDV .GE. max(1,N).
            </param>
             <param name="INFO">
             (output) INTEGER
             = 0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal value.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.RKSolOut">
            <summary>
            NAME (EXTERNAL) OF SUBROUTINE PROVIDING THE
            NUMERICAL SOLUTION DURING INTEGRATION. 
            IF IOUT.GE.1, IT IS CALLED AFTER EVERY SUCCESSFUL STEP.
            SUPPLY A DUMMY SUBROUTINE IF IOUT=0. 
            IT MUST HAVE THE FORM
            SUBROUTINE SOLOUTR (NR,XOLD,X,Y,N,CON,ICOMP,ND,
            RPAR,IPAR,IRTRN)
            DIMENSION Y(N),CON(5*ND),ICOMP(ND)
            ....  
            SOLOUTR FURNISHES THE SOLUTION "Y" AT THE NR-TH
            GRID-POINT "X" (THEREBY THE INITIAL VALUE IS
            THE FIRST GRID-POINT).
            "XOLD" IS THE PRECEEDING GRID-POINT.
            "IRTRN" SERVES TO INTERRUPT THE INTEGRATION. IF IRTRN
            IS SET .LT.0, DOPRI5 WILL RETURN TO THE CALLING PROGRAM.
            IF THE NUMERICAL SOLUTION IS ALTERED IN SOLOUTR,
            SET  IRTRN = 2
            
            -----  CONTINUOUS OUTPUT: -----
            DURING CALLS TO "SOLOUTR", A CONTINUOUS SOLUTION
            FOR THE INTERVAL [XOLD,X] IS AVAILABLE THROUGH
            THE FUNCTION
            .GT..GT..GT.   CONTD5(I,S,CON,ICOMP,ND)   .LT..LT..LT.
            WHICH PROVIDES AN APPROXIMATION TO THE I-TH
            COMPONENT OF THE SOLUTION AT THE POINT S. THE VALUE
            S SHOULD LIE IN THE INTERVAL [XOLD,X].
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._NEquations">
            <summary>
            Number of equations
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._Y0">
            <summary>
            Valores iniciales.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._IsTimeArrayUsed">
            <summary>
            Indica si se usa un array para definir los puntos de inegracion.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._T0">
            <summary>
            El tiempo inicial de integracion
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._TF">
            <summary>
            El tiempo final de inegracion
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._TSpan">
            <summary>
            El array que contiene los tiempos de integracion
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._MaxIndex">
            <summary>
            El valor indice maximo para el cual la soluciones calculada. 
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._SolutionArray">
            <summary>
            El array que contiene el tiempo y los valores de la solucion
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._SolutionOut">
            <summary>
            El delegado que se llama cuando se calcula un punto en la inegracion (si es requerido).
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._SolutionOutType">
            <summary>
            Especifica como se regresara la solucion
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._TemporalSolution">
            <summary>
            Un areglo que array que almacena la solucion para cada punto
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._isDeltaPositive">
            <summary>
            Indica si la integracion va en incrementos positivos del tiempo.
            </summary>
        </member>
        <member name="F:DotNumerics.ODE.RKSolOut._T">
            <summary>
            El valor que se esta calculando.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.RKSolOut.GetTime(System.Int32)">
            <summary>
            Calcula el valor temporal de la integracion para un idice dado.
            </summary>
            <param name="index">El indice corresponiente al tiempo deseado.</param>
            <returns>El tiempo de integracio.</returns>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVODE.Run(DotNumerics.ODE.DVode.IFEX,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Double,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32,System.Int32@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32,DotNumerics.ODE.DVode.IJEX,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32)">
             <param name="F">
             = The name of the user-supplied subroutine defining the
             ODE system.  The system must be put in the first-order
             form dy/dt = f(t,y), where f is a vector-valued function
             of the scalar t and the vector y.  Subroutine F is to
             compute the function f.  It is to have the form
             SUBROUTINE F (NEQ, T, Y, YDOT, RPAR, IPAR)
             DOUBLE PRECISION T, Y(NEQ), YDOT(NEQ), RPAR
             where NEQ, T, and Y are input, and the array YDOT = f(t,y)
             is output.  Y and YDOT are arrays of length NEQ.
             Subroutine F should not alter Y(1),...,Y(NEQ).
             F must be declared EXTERNAL in the calling program.
             
             Subroutine F may access user-defined real and integer
             work arrays RPAR and IPAR, which are to be dimensioned
             in the main program.
             
             If quantities computed in the F routine are needed
             externally to DVODE, an extra call to F should be made
             for this purpose, for consistent and accurate results.
             If only the derivative dy/dt is needed, use DVINDY instead.
            </param>
             <param name="NEQ">
             = The size of the ODE system (number of first order
             ordinary differential equations).  Used only for input.
             NEQ may not be increased during the problem, but
             can be decreased (with ISTATE = 3 in the input).
            </param>
             <param name="Y">
             = A real array for the vector of dependent variables, of
             length NEQ or more.  Used for both input and output on the
             first call (ISTATE = 1), and only for output on other calls.
             On the first call, Y must contain the vector of initial
             values.  In the output, Y contains the computed solution
             evaluated at T.  If desired, the Y array may be used
             for other purposes between calls to the solver.
             
             This array is passed as the Y argument in all calls to
             F and JAC.
            </param>
             <param name="T">
             = The independent variable.  In the input, T is used only on
             the first call, as the initial point of the integration.
             In the output, after each call, T is the value at which a
             computed solution Y is evaluated (usually the same as TOUT).
             On an error return, T is the farthest point reached.
            </param>
             <param name="TOUT">
             = The next value of t at which a computed solution is desired.
             Used only for input.
             
             When starting the problem (ISTATE = 1), TOUT may be equal
             to T for one call, then should .ne. T for the next call.
             For the initial T, an input value of TOUT .ne. T is used
             in order to determine the direction of the integration
             (i.e. the algebraic sign of the step sizes) and the rough
             scale of the problem.  Integration in either direction
             (forward or backward in t) is permitted.
             
             If ITASK = 2 or 5 (one-step modes), TOUT is ignored after
             the first call (i.e. the first call with TOUT .ne. T).
             Otherwise, TOUT is required on every call.
             
             If ITASK = 1, 3, or 4, the values of TOUT need not be
             monotone, but a value of TOUT which backs up is limited
             to the current internal t interval, whose endpoints are
             TCUR - HU and TCUR.  (See optional output, below, for
             TCUR and HU.)
            </param>
             <param name="ITOL">
             = An indicator for the type of error control.  See
             description below under ATOL.  Used only for input.
            </param>
             <param name="RTOL">
             = A relative error tolerance parameter, either a scalar or
             an array of length NEQ.  See description below under ATOL.
             Input only.
            </param>
             <param name="ATOL">
             = An absolute error tolerance parameter, either a scalar or
             an array of length NEQ.  Input only.
             
             The input parameters ITOL, RTOL, and ATOL determine
             the error control performed by the solver.  The solver will
             control the vector e = (e(i)) of estimated local errors
             in Y, according to an inequality of the form
             rms-norm of ( e(i)/EWT(i) )   .le.   1,
             where       EWT(i) = RTOL(i)*abs(Y(i)) + ATOL(i),
             and the rms-norm (root-mean-square norm) here is
             rms-norm(v) = sqrt(sum v(i)**2 / NEQ).  Here EWT = (EWT(i))
             is a vector of weights which must always be positive, and
             the values of RTOL and ATOL should all be non-negative.
             The following table gives the types (scalar/array) of
             RTOL and ATOL, and the corresponding form of EWT(i).
             
             ITOL    RTOL       ATOL          EWT(i)
             1     scalar     scalar     RTOL*ABS(Y(i)) + ATOL
             2     scalar     array      RTOL*ABS(Y(i)) + ATOL(i)
             3     array      scalar     RTOL(i)*ABS(Y(i)) + ATOL
             4     array      array      RTOL(i)*ABS(Y(i)) + ATOL(i)
             
             When either of these parameters is a scalar, it need not
             be dimensioned in the user's calling program.
             
             If none of the above choices (with ITOL, RTOL, and ATOL
             fixed throughout the problem) is suitable, more general
             error controls can be obtained by substituting
             user-supplied routines for the setting of EWT and/or for
             the norm calculation.  See Part iv below.
             
             If global errors are to be estimated by making a repeated
             run on the same problem with smaller tolerances, then all
             components of RTOL and ATOL (i.e. of EWT) should be scaled
             down uniformly.
            </param>
             <param name="ITASK">
             = An index specifying the task to be performed.
             Input only.  ITASK has the following values and meanings.
             1  means normal computation of output values of y(t) at
             t = TOUT (by overshooting and interpolating).
             2  means take one step only and return.
             3  means stop at the first internal mesh point at or
             beyond t = TOUT and return.
             4  means normal computation of output values of y(t) at
             t = TOUT but without overshooting t = TCRIT.
             TCRIT must be input as RWORK(1).  TCRIT may be equal to
             or beyond TOUT, but not behind it in the direction of
             integration.  This option is useful if the problem
             has a singularity at or beyond t = TCRIT.
             5  means take one step, without passing TCRIT, and return.
             TCRIT must be input as RWORK(1).
             
             Note:  If ITASK = 4 or 5 and the solver reaches TCRIT
             (within roundoff), it will return T = TCRIT (exactly) to
             indicate this (unless ITASK = 4 and TOUT comes before TCRIT,
             in which case answers at T = TOUT are returned first).
            </param>
             <param name="ISTATE">
             = an index used for input and output to specify the
             the state of the calculation.
             
             In the input, the values of ISTATE are as follows.
             1  means this is the first call for the problem
             (initializations will be done).  See note below.
             2  means this is not the first call, and the calculation
             is to continue normally, with no change in any input
             parameters except possibly TOUT and ITASK.
             (If ITOL, RTOL, and/or ATOL are changed between calls
             with ISTATE = 2, the new values will be used but not
             tested for legality.)
             3  means this is not the first call, and the
             calculation is to continue normally, but with
             a change in input parameters other than
             TOUT and ITASK.  Changes are allowed in
             NEQ, ITOL, RTOL, ATOL, IOPT, LRW, LIW, MF, ML, MU,
             and any of the optional input except H0.
             (See IWORK description for ML and MU.)
             Note:  A preliminary call with TOUT = T is not counted
             as a first call here, as no initialization or checking of
             input is done.  (Such a call is sometimes useful to include
             the initial conditions in the output.)
             Thus the first call for which TOUT .ne. T requires
             ISTATE = 1 in the input.
             
             In the output, ISTATE has the following values and meanings.
             1  means nothing was done, as TOUT was equal to T with
             ISTATE = 1 in the input.
             2  means the integration was performed successfully.
             -1  means an excessive amount of work (more than MXSTEP
             steps) was done on this call, before completing the
             requested task, but the integration was otherwise
             successful as far as T.  (MXSTEP is an optional input
             and is normally 500.)  To continue, the user may
             simply reset ISTATE to a value .gt. 1 and call again.
             (The excess work step counter will be reset to 0.)
             In addition, the user may increase MXSTEP to avoid
             this error return.  (See optional input below.)
             -2  means too much accuracy was requested for the precision
             of the machine being used.  This was detected before
             completing the requested task, but the integration
             was successful as far as T.  To continue, the tolerance
             parameters must be reset, and ISTATE must be set
             to 3.  The optional output TOLSF may be used for this
             purpose.  (Note: If this condition is detected before
             taking any steps, then an illegal input return
             (ISTATE = -3) occurs instead.)
             -3  means illegal input was detected, before taking any
             integration steps.  See written message for details.
             Note:  If the solver detects an infinite loop of calls
             to the solver with illegal input, it will cause
             the run to stop.
             -4  means there were repeated error test failures on
             one attempted step, before completing the requested
             task, but the integration was successful as far as T.
             The problem may have a singularity, or the input
             may be inappropriate.
             -5  means there were repeated convergence test failures on
             one attempted step, before completing the requested
             task, but the integration was successful as far as T.
             This may be caused by an inaccurate Jacobian matrix,
             if one is being used.
             -6  means EWT(i) became zero for some i during the
             integration.  Pure relative error control (ATOL(i)=0.0)
             was requested on a variable which has now vanished.
             The integration was successful as far as T.
             
             Note:  Since the normal output value of ISTATE is 2,
             it does not need to be reset for normal continuation.
             Also, since a negative input value of ISTATE will be
             regarded as illegal, a negative output value requires the
             user to change it, and possibly other input, before
             calling the solver again.
            </param>
             <param name="IOPT">
             = An integer flag to specify whether or not any optional
             input is being used on this call.  Input only.
             The optional input is listed separately below.
             IOPT = 0 means no optional input is being used.
             Default values will be used in all cases.
             IOPT = 1 means optional input is being used.
            </param>
             <param name="RWORK">
             = A real working array (double precision).
             The length of RWORK must be at least
             20 + NYH*(MAXORD + 1) + 3*NEQ + LWM    where
             NYH    = the initial value of NEQ,
             MAXORD = 12 (if METH = 1) or 5 (if METH = 2) (unless a
             smaller value is given as an optional input),
             LWM = length of work space for matrix-related data:
             LWM = 0             if MITER = 0,
             LWM = 2*NEQ**2 + 2  if MITER = 1 or 2, and MF.gt.0,
             LWM = NEQ**2 + 2    if MITER = 1 or 2, and MF.lt.0,
             LWM = NEQ + 2       if MITER = 3,
             LWM = (3*ML+2*MU+2)*NEQ + 2 if MITER = 4 or 5, and MF.gt.0,
             LWM = (2*ML+MU+1)*NEQ + 2   if MITER = 4 or 5, and MF.lt.0.
             (See the MF description for METH and MITER.)
             Thus if MAXORD has its default value and NEQ is constant,
             this length is:
             20 + 16*NEQ                    for MF = 10,
             22 + 16*NEQ + 2*NEQ**2         for MF = 11 or 12,
             22 + 16*NEQ + NEQ**2           for MF = -11 or -12,
             22 + 17*NEQ                    for MF = 13,
             22 + 18*NEQ + (3*ML+2*MU)*NEQ  for MF = 14 or 15,
             22 + 17*NEQ + (2*ML+MU)*NEQ    for MF = -14 or -15,
             20 +  9*NEQ                    for MF = 20,
             22 +  9*NEQ + 2*NEQ**2         for MF = 21 or 22,
             22 +  9*NEQ + NEQ**2           for MF = -21 or -22,
             22 + 10*NEQ                    for MF = 23,
             22 + 11*NEQ + (3*ML+2*MU)*NEQ  for MF = 24 or 25.
             22 + 10*NEQ + (2*ML+MU)*NEQ    for MF = -24 or -25.
             The first 20 words of RWORK are reserved for conditional
             and optional input and optional output.
             
             The following word in RWORK is a conditional input:
             RWORK(1) = TCRIT = critical value of t which the solver
             is not to overshoot.  Required if ITASK is
             4 or 5, and ignored otherwise.  (See ITASK.)
            </param>
             <param name="LRW">
             = The length of the array RWORK, as declared by the user.
             (This will be checked by the solver.)
            </param>
             <param name="IWORK">
             = An integer work array.  The length of IWORK must be at least
             30        if MITER = 0 or 3 (MF = 10, 13, 20, 23), or
             30 + NEQ  otherwise (abs(MF) = 11,12,14,15,21,22,24,25).
             The first 30 words of IWORK are reserved for conditional and
             optional input and optional output.
             
             The following 2 words in IWORK are conditional input:
             IWORK(1) = ML     These are the lower and upper
             IWORK(2) = MU     half-bandwidths, respectively, of the
             banded Jacobian, excluding the main diagonal.
             The band is defined by the matrix locations
             (i,j) with i-ML .le. j .le. i+MU.  ML and MU
             must satisfy  0 .le.  ML,MU  .le. NEQ-1.
             These are required if MITER is 4 or 5, and
             ignored otherwise.  ML and MU may in fact be
             the band parameters for a matrix to which
             df/dy is only approximately equal.
            </param>
             <param name="LIW">
             = the length of the array IWORK, as declared by the user.
             (This will be checked by the solver.)
            </param>
             <param name="JAC">
             = The name of the user-supplied routine (MITER = 1 or 4) to
             compute the Jacobian matrix, df/dy, as a function of
             the scalar t and the vector y.  It is to have the form
             SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD,
             RPAR, IPAR)
             DOUBLE PRECISION T, Y(NEQ), PD(NROWPD,NEQ), RPAR
             where NEQ, T, Y, ML, MU, and NROWPD are input and the array
             PD is to be loaded with partial derivatives (elements of the
             Jacobian matrix) in the output.  PD must be given a first
             dimension of NROWPD.  T and Y have the same meaning as in
             Subroutine F.
             In the full matrix case (MITER = 1), ML and MU are
             ignored, and the Jacobian is to be loaded into PD in
             columnwise manner, with df(i)/dy(j) loaded into PD(i,j).
             In the band matrix case (MITER = 4), the elements
             within the band are to be loaded into PD in columnwise
             manner, with diagonal lines of df/dy loaded into the rows
             of PD. Thus df(i)/dy(j) is to be loaded into PD(i-j+MU+1,j).
             ML and MU are the half-bandwidth parameters. (See IWORK).
             The locations in PD in the two triangular areas which
             correspond to nonexistent matrix elements can be ignored
             or loaded arbitrarily, as they are overwritten by DVODE.
             JAC need not provide df/dy exactly.  A crude
             approximation (possibly with a smaller bandwidth) will do.
             In either case, PD is preset to zero by the solver,
             so that only the nonzero elements need be loaded by JAC.
             Each call to JAC is preceded by a call to F with the same
             arguments NEQ, T, and Y.  Thus to gain some efficiency,
             intermediate quantities shared by both calculations may be
             saved in a user COMMON block by F and not recomputed by JAC,
             if desired.  Also, JAC may alter the Y array, if desired.
             JAC must be declared external in the calling program.
             Subroutine JAC may access user-defined real and integer
             work arrays, RPAR and IPAR, whose dimensions are set by the
             user in the main program.
            </param>
             <param name="MF">
             = The method flag.  Used only for input.  The legal values of
             MF are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25,
             -11, -12, -14, -15, -21, -22, -24, -25.
             MF is a signed two-digit integer, MF = JSV*(10*METH + MITER).
             JSV = SIGN(MF) indicates the Jacobian-saving strategy:
             JSV =  1 means a copy of the Jacobian is saved for reuse
             in the corrector iteration algorithm.
             JSV = -1 means a copy of the Jacobian is not saved
             (valid only for MITER = 1, 2, 4, or 5).
             METH indicates the basic linear multistep method:
             METH = 1 means the implicit Adams method.
             METH = 2 means the method based on backward
             differentiation formulas (BDF-s).
             MITER indicates the corrector iteration method:
             MITER = 0 means functional iteration (no Jacobian matrix
             is involved).
             MITER = 1 means chord iteration with a user-supplied
             full (NEQ by NEQ) Jacobian.
             MITER = 2 means chord iteration with an internally
             generated (difference quotient) full Jacobian
             (using NEQ extra calls to F per df/dy value).
             MITER = 3 means chord iteration with an internally
             generated diagonal Jacobian approximation
             (using 1 extra call to F per df/dy evaluation).
             MITER = 4 means chord iteration with a user-supplied
             banded Jacobian.
             MITER = 5 means chord iteration with an internally
             generated banded Jacobian (using ML+MU+1 extra
             calls to F per df/dy evaluation).
             If MITER = 1 or 4, the user must supply a subroutine JAC
             (the name is arbitrary) as described above under JAC.
             For other values of MITER, a dummy argument can be used.
            </param>
             <param name="RPAR">
             User-specified array used to communicate real parameters
             to user-supplied subroutines.  If RPAR is a vector, then
             it must be dimensioned in the user's main program.  If it
             is unused or it is a scalar, then it need not be
             dimensioned.
            </param>
             <param name="IPAR">
             User-specified array used to communicate integer parameter
             to user-supplied subroutines.  The comments on dimensioning
             RPAR apply to IPAR.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVHIN.Run(System.Int32,System.Double,System.Double[],System.Int32,System.Double[],System.Int32,DotNumerics.ODE.DVode.IFEX,System.Double[],System.Int32,System.Int32[],System.Int32,System.Double,System.Double,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Double@,System.Int32@,System.Int32@)">
             <param name="N">
             = Size of ODE system, input.
            </param>
             <param name="T0">
             = Initial value of independent variable, input.
            </param>
             <param name="Y0">
             = Vector of initial conditions, input.
            </param>
             <param name="YDOT">
             = Vector of initial first derivatives, input.
            </param>
             <param name="F">
             = Name of subroutine for right-hand side f(t,y), input.
            </param>
             <param name="TOUT">
             = First output value of independent variable
            </param>
             <param name="UROUND">
             = Machine unit roundoff
            </param>
             <param name="H0">
             = Step size to be attempted, output.
            </param>
             <param name="NITER">
             = Number of iterations (and of f evaluations) to compute H0,
             output.
            </param>
             <param name="IER">
             = The error flag, returned with the value
             IER = 0  if no trouble occurred, or
             IER = -1 if TOUT and T0 are considered too close to proceed.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVINDY.Run(System.Double,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="IFLAG">
             is returned negative if either K or T is out of bounds.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVSTEP.Run(System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,DotNumerics.ODE.DVode.IFEX,DotNumerics.ODE.DVode.IJEX,DotNumerics.ODE.DVode.IFEX,DotNumerics.ODE.DVode.IDVNLSD,System.Double[],System.Int32,System.Int32[],System.Int32)">
             <param name="Y">
             = An array of length N used for the dependent variable vector.
            </param>
             <param name="YH">
             = An LDYH by LMAX array containing the dependent variables
             and their approximate scaled derivatives, where
             LMAX = MAXORD + 1.  YH(i,j+1) contains the approximate
             j-th derivative of y(i), scaled by H**j/factorial(j)
             (j = 0,1,...,NQ).  On entry for the first step, the first
             two columns of YH must be set from the initial values.
            </param>
             <param name="LDYH">
             = A constant integer .ge. N, the first dimension of YH.
             N is the number of ODEs in the system.
            </param>
             <param name="YH1">
             = A one-dimensional array occupying the same space as YH.
            </param>
             <param name="EWT">
             = An array of length N containing multiplicative weights
             for local error measurements.  Local errors in y(i) are
             compared to 1.0/EWT(i) in various error tests.
            </param>
             <param name="SAVF">
             = An array of working storage, of length N.
             also used for input of YH(*,MAXORD+2) when JSTART = -1
             and MAXORD .lt. the current order NQ.
            </param>
             <param name="VSAV">
             = A work array of length N passed to subroutine VNLS.
            </param>
             <param name="ACOR">
             = A work array of length N, used for the accumulated
             corrections.  On a successful return, ACOR(i) contains
             the estimated one-step local error in y(i).
            </param>
             <param name="F">
             = Dummy name for the user supplied subroutine for f.
            </param>
             <param name="JAC">
             = Dummy name for the user supplied Jacobian subroutine.
            </param>
             <param name="PSOL">
             = Dummy name for the subroutine passed to VNLS, for
             possible use there.
            </param>
             <param name="VNLS">
             = Dummy name for the nonlinear system solving subroutine,
             whose real name is dependent on the method used.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVJUST.Run(System.Double[]@,System.Int32,System.Int32,System.Int32)">
             <param name="IORD">
             = An integer flag used when METH = 2 to indicate an order
             increase (IORD = +1) or an order decrease (IORD = -1).
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVNLSD.Run(System.Double[]@,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Double[]@,System.Int32,DotNumerics.ODE.DVode.IFEX,DotNumerics.ODE.DVode.IJEX,DotNumerics.ODE.DVode.IFEX,System.Int32@,System.Double[],System.Int32,System.Int32[],System.Int32)">
             <param name="Y">
             = The dependent variable, a vector of length N, input.
            </param>
             <param name="YH">
             = The Nordsieck (Taylor) array, LDYH by LMAX, input
             and output.  On input, it contains predicted values.
            </param>
             <param name="LDYH">
             = A constant .ge. N, the first dimension of YH, input.
            </param>
             <param name="VSAV">
             = Unused work array.
            </param>
             <param name="SAVF">
             = A work array of length N.
            </param>
             <param name="EWT">
             = An error weight vector of length N, input.
            </param>
             <param name="ACOR">
             = A work array of length N, used for the accumulated
             corrections to the predicted y vector.
            </param>
             <param name="F">
             = Dummy name for user supplied routine for f.
            </param>
             <param name="JAC">
             = Dummy name for user supplied Jacobian routine.
            </param>
             <param name="PDUM">
             = Unused dummy subroutine name.  Included for uniformity
             over collection of integrators.
            </param>
             <param name="NFLAG">
             = Input/output flag, with values and meanings as follows:
             INPUT
             0 first call for this time step.
             -1 convergence failure in previous call to DVNLSD.
             -2 error test failure in DVSTEP.
             OUTPUT
             0 successful completion of nonlinear solver.
             -1 convergence failure or singular matrix.
             -2 unrecoverable error in matrix preprocessing
             (cannot occur here).
             -3 unrecoverable error in solution (cannot occur
             here).
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVJAC.Run(System.Double[]@,System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32,System.Int32[]@,System.Int32,DotNumerics.ODE.DVode.IFEX,DotNumerics.ODE.DVode.IJEX,System.Int32@,System.Double[],System.Int32,System.Int32[],System.Int32)">
             <param name="Y">
             = Vector containing predicted values on entry.
            </param>
             <param name="YH">
             = The Nordsieck array, an LDYH by LMAX array, input.
            </param>
             <param name="LDYH">
             = A constant .ge. N, the first dimension of YH, input.
            </param>
             <param name="EWT">
             = An error weight vector of length N.
            </param>
             <param name="SAVF">
             = Array containing f evaluated at predicted y, input.
            </param>
             <param name="WM">
             = Real work space for matrices.  In the output, it containS
             the inverse diagonal matrix if MITER = 3 and the LU
             decomposition of P if MITER is 1, 2 , 4, or 5.
             Storage of matrix elements starts at WM(3).
             Storage of the saved Jacobian starts at WM(LOCJS).
             WM also contains the following matrix-related data:
             WM(1) = SQRT(UROUND), used in numerical Jacobian step.
             WM(2) = H*RL1, saved for later use if MITER = 3.
            </param>
             <param name="IWM">
             = Integer work space containing pivot information,
             starting at IWM(31), if MITER is 1, 2, 4, or 5.
             IWM also contains band parameters ML = IWM(1) and
             MU = IWM(2) if MITER is 4 or 5.
            </param>
             <param name="F">
             = Dummy name for the user supplied subroutine for f.
            </param>
             <param name="JAC">
             = Dummy name for the user supplied Jacobian subroutine.
            </param>
             <param name="IERPJ">
             = Output error flag,  = 0 if no trouble, 1 if the P
             matrix is found to be singular.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVSOL.Run(System.Double[]@,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32@)">
             <param name="WM">
             = Real work space containing the inverse diagonal matrix if
             MITER = 3 and the LU decomposition of the matrix otherwise.
             Storage of matrix elements starts at WM(3).
             WM also contains the following matrix-related data:
             WM(1) = SQRT(UROUND) (not used here),
             WM(2) = HRL1, the previous value of H*RL1, used if MITER = 3.
            </param>
             <param name="IWM">
             = Integer work space containing pivot information, starting at
             IWM(31), if MITER is 1, 2, 4, or 5.  IWM also contains band
             parameters ML = IWM(1) and MU = IWM(2) if MITER is 4 or 5.
            </param>
             <param name="X">
             = The right-hand side vector on input, and the solution vector
             on output, of length N.
            </param>
             <param name="IERSL">
             = Output flag.  IERSL = 0 if no trouble occurred.
             IERSL = 1 if a singular matrix arose with MITER = 3.
            </param>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVSRCO.Run(System.Double[]@,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
             <param name="RSAV">
             = real array of length 49 or more.
            </param>
             <param name="ISAV">
             = integer array of length 41 or more.
            </param>
             <param name="JOB">
             = flag indicating to save or restore the COMMON blocks:
             JOB  = 1 if COMMON is to be saved (written to RSAV/ISAV).
             JOB  = 2 if COMMON is to be restored (read from RSAV/ISAV).
             A call with JOB = 2 presumes a prior call with JOB = 1.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DEWSET">
             <summary>
             ***PURPOSE  Set error weight vector.
             ***TYPE      DOUBLE PRECISION (SEWSET-S, DEWSET-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             This subroutine sets the error weight vector EWT according to
             EWT(i) = RTOL(i)*ABS(YCUR(i)) + ATOL(i),  i = 1,...,N,
             with the subscript on RTOL and/or ATOL possibly replaced by 1 above,
             depending on the value of ITOL.
             
             ***SEE ALSO  DLSODE
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791129  DATE WRITTEN
             890501  Modified prologue to SLATEC/LDOC format.  (FNF)
             890503  Minor cosmetic changes.  (FNF)
             930809  Renamed to allow single/double precision versions. (ACH)
             ***END PROLOGUE  DEWSET
             **End
             
             ***FIRST EXECUTABLE STATEMENT  DEWSET
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DEWSET.Run(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double[]@,System.Int32)">
             <summary>
             ***PURPOSE  Set error weight vector.
             ***TYPE      DOUBLE PRECISION (SEWSET-S, DEWSET-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             This subroutine sets the error weight vector EWT according to
             EWT(i) = RTOL(i)*ABS(YCUR(i)) + ATOL(i),  i = 1,...,N,
             with the subscript on RTOL and/or ATOL possibly replaced by 1 above,
             depending on the value of ITOL.
             
             ***SEE ALSO  DLSODE
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791129  DATE WRITTEN
             890501  Modified prologue to SLATEC/LDOC format.  (FNF)
             890503  Minor cosmetic changes.  (FNF)
             930809  Renamed to allow single/double precision versions. (ACH)
             ***END PROLOGUE  DEWSET
             **End
             
             ***FIRST EXECUTABLE STATEMENT  DEWSET
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DVNORM">
             <summary>
             ***PURPOSE  Weighted root-mean-square vector norm.
             ***TYPE      DOUBLE PRECISION (SVNORM-S, DVNORM-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             This function routine computes the weighted root-mean-square norm
             of the vector of length N contained in the array V, with weights
             contained in the array W of length N:
             DVNORM = SQRT( (1/N) * SUM( V(i)*W(i) )**2 )
             
             ***SEE ALSO  DLSODE
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791129  DATE WRITTEN
             890501  Modified prologue to SLATEC/LDOC format.  (FNF)
             890503  Minor cosmetic changes.  (FNF)
             930809  Renamed to allow single/double precision versions. (ACH)
             ***END PROLOGUE  DVNORM
             **End
             
             ***FIRST EXECUTABLE STATEMENT  DVNORM
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DVNORM.Run(System.Int32,System.Double[],System.Int32,System.Double[],System.Int32)">
             <summary>
             ***PURPOSE  Weighted root-mean-square vector norm.
             ***TYPE      DOUBLE PRECISION (SVNORM-S, DVNORM-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             This function routine computes the weighted root-mean-square norm
             of the vector of length N contained in the array V, with weights
             contained in the array W of length N:
             DVNORM = SQRT( (1/N) * SUM( V(i)*W(i) )**2 )
             
             ***SEE ALSO  DLSODE
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791129  DATE WRITTEN
             890501  Modified prologue to SLATEC/LDOC format.  (FNF)
             890503  Minor cosmetic changes.  (FNF)
             930809  Renamed to allow single/double precision versions. (ACH)
             ***END PROLOGUE  DVNORM
             **End
             
             ***FIRST EXECUTABLE STATEMENT  DVNORM
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.XERRWD">
             <summary>
             ***PURPOSE  Write error message with values.
             ***CATEGORY  R3C
             ***TYPE      DOUBLE PRECISION (XERRWV-S, XERRWD-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             Subroutines XERRWD, XSETF, XSETUN, and the function routine IXSAV,
             as given here, constitute a simplified version of the SLATEC error
             handling package.
             
             All arguments are input arguments.
             
             MSG    = The message (character array).
             NMES   = The length of MSG (number of characters).
             NERR   = The error number (not used).
             LEVEL  = The error level..
             0 or 1 means recoverable (control returns to caller).
             2 means fatal (run is aborted--see note below).
             NI     = Number of integers (0, 1, or 2) to be printed with message.
             I1,I2  = Integers to be printed, depending on NI.
             NR     = Number of reals (0, 1, or 2) to be printed with message.
             R1,R2  = Reals to be printed, depending on NR.
             
             Note..  this routine is machine-dependent and specialized for use
             in limited context, in the following ways..
             1. The argument MSG is assumed to be of type CHARACTER, and
             the message is printed with a format of (1X,A).
             2. The message is assumed to take only one line.
             Multi-line messages are generated by repeated calls.
             3. If LEVEL = 2, control passes to the statement   STOP
             to abort the run.  This statement may be machine-dependent.
             4. R1 and R2 are assumed to be in double precision and are printed
             in D21.13 format.
             
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             920831  DATE WRITTEN
             921118  Replaced MFLGSV/LUNSAV by IXSAV. (ACH)
             930329  Modified prologue to SLATEC format. (FNF)
             930407  Changed MSG from CHARACTER*1 array to variable. (FNF)
             930922  Minor cosmetic change. (FNF)
             ***END PROLOGUE  XERRWD
             
             *Internal Notes:
             
             For a different default logical unit number, IXSAV (or a subsidiary
             routine that it calls) will need to be modified.
             For a different run-abort command, change the statement following
             statement 100 at the end.
             -----------------------------------------------------------------------
             Subroutines called by XERRWD.. None
             Function routine called by XERRWD.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             Declare arguments.
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.XERRWD.Run(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
             <summary>
             ***PURPOSE  Write error message with values.
             ***CATEGORY  R3C
             ***TYPE      DOUBLE PRECISION (XERRWV-S, XERRWD-D)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             Subroutines XERRWD, XSETF, XSETUN, and the function routine IXSAV,
             as given here, constitute a simplified version of the SLATEC error
             handling package.
             
             All arguments are input arguments.
             
             MSG    = The message (character array).
             NMES   = The length of MSG (number of characters).
             NERR   = The error number (not used).
             LEVEL  = The error level..
             0 or 1 means recoverable (control returns to caller).
             2 means fatal (run is aborted--see note below).
             NI     = Number of integers (0, 1, or 2) to be printed with message.
             I1,I2  = Integers to be printed, depending on NI.
             NR     = Number of reals (0, 1, or 2) to be printed with message.
             R1,R2  = Reals to be printed, depending on NR.
             
             Note..  this routine is machine-dependent and specialized for use
             in limited context, in the following ways..
             1. The argument MSG is assumed to be of type CHARACTER, and
             the message is printed with a format of (1X,A).
             2. The message is assumed to take only one line.
             Multi-line messages are generated by repeated calls.
             3. If LEVEL = 2, control passes to the statement   STOP
             to abort the run.  This statement may be machine-dependent.
             4. R1 and R2 are assumed to be in double precision and are printed
             in D21.13 format.
             
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             920831  DATE WRITTEN
             921118  Replaced MFLGSV/LUNSAV by IXSAV. (ACH)
             930329  Modified prologue to SLATEC format. (FNF)
             930407  Changed MSG from CHARACTER*1 array to variable. (FNF)
             930922  Minor cosmetic change. (FNF)
             ***END PROLOGUE  XERRWD
             
             *Internal Notes:
             
             For a different default logical unit number, IXSAV (or a subsidiary
             routine that it calls) will need to be modified.
             For a different run-abort command, change the statement following
             statement 100 at the end.
             -----------------------------------------------------------------------
             Subroutines called by XERRWD.. None
             Function routine called by XERRWD.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             Declare arguments.
            </summary>
             <param name="MSG">
             = The message (character array).
            </param>
             <param name="NMES">
             = The length of MSG (number of characters).
            </param>
             <param name="NERR">
             = The error number (not used).
            </param>
             <param name="LEVEL">
             = The error level..
             0 or 1 means recoverable (control returns to caller).
             2 means fatal (run is aborted--see note below).
            </param>
             <param name="NI">
             = Number of integers (0, 1, or 2) to be printed with message.
            </param>
             <param name="NR">
             = Number of reals (0, 1, or 2) to be printed with message.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.XSETF">
             <summary>
             ***PURPOSE  Reset the error print control flag.
             ***CATEGORY  R3A
             ***TYPE      ALL (XSETF-A)
             ***KEYWORDS  ERROR CONTROL
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             XSETF sets the error print control flag to MFLAG:
             MFLAG=1 means print all messages (the default).
             MFLAG=0 means no printing.
             
             ***SEE ALSO  XERRWD, XERRWV
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Added SLATEC format prologue. (FNF)
             930407  Corrected SEE ALSO section. (FNF)
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  XSETF
             
             Subroutines called by XSETF.. None
             Function routine called by XSETF.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             ***FIRST EXECUTABLE STATEMENT  XSETF
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.XSETF.Run(System.Int32)">
             <summary>
             ***PURPOSE  Reset the error print control flag.
             ***CATEGORY  R3A
             ***TYPE      ALL (XSETF-A)
             ***KEYWORDS  ERROR CONTROL
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             XSETF sets the error print control flag to MFLAG:
             MFLAG=1 means print all messages (the default).
             MFLAG=0 means no printing.
             
             ***SEE ALSO  XERRWD, XERRWV
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Added SLATEC format prologue. (FNF)
             930407  Corrected SEE ALSO section. (FNF)
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  XSETF
             
             Subroutines called by XSETF.. None
             Function routine called by XSETF.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             ***FIRST EXECUTABLE STATEMENT  XSETF
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.XSETUN">
             <summary>
             ***PURPOSE  Reset the logical unit number for error messages.
             ***CATEGORY  R3B
             ***TYPE      ALL (XSETUN-A)
             ***KEYWORDS  ERROR CONTROL
             ***DESCRIPTION
             
             XSETUN sets the logical unit number for error messages to LUN.
             
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***SEE ALSO  XERRWD, XERRWV
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Added SLATEC format prologue. (FNF)
             930407  Corrected SEE ALSO section. (FNF)
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  XSETUN
             
             Subroutines called by XSETUN.. None
             Function routine called by XSETUN.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             ***FIRST EXECUTABLE STATEMENT  XSETUN
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.XSETUN.Run(System.Int32)">
             <summary>
             ***PURPOSE  Reset the logical unit number for error messages.
             ***CATEGORY  R3B
             ***TYPE      ALL (XSETUN-A)
             ***KEYWORDS  ERROR CONTROL
             ***DESCRIPTION
             
             XSETUN sets the logical unit number for error messages to LUN.
             
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***SEE ALSO  XERRWD, XERRWV
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  IXSAV
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Added SLATEC format prologue. (FNF)
             930407  Corrected SEE ALSO section. (FNF)
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  XSETUN
             
             Subroutines called by XSETUN.. None
             Function routine called by XSETUN.. IXSAV
             -----------------------------------------------------------------------
             **End
             
             ***FIRST EXECUTABLE STATEMENT  XSETUN
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.IXSAV">
             <summary>
             ***PURPOSE  Save and recall error message control parameters.
             ***CATEGORY  R3C
             ***TYPE      ALL (IXSAV-A)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             IXSAV saves and recalls one of two error message parameters:
             LUNIT, the logical unit number to which messages are printed, and
             MESFLG, the message print flag.
             This is a modification of the SLATEC library routine J4SAVE.
             
             Saved local variables..
             LUNIT  = Logical unit number for messages.  The default is obtained
             by a call to IUMACH (may be machine-dependent).
             MESFLG = Print control flag..
             1 means print all messages (the default).
             0 means no printing.
             
             On input..
             IPAR   = Parameter indicator (1 for LUNIT, 2 for MESFLG).
             IVALUE = The value to be set for the parameter, if ISET = .TRUE.
             ISET   = Logical flag to indicate whether to read or write.
             If ISET = .TRUE., the parameter will be given
             the value IVALUE.  If ISET = .FALSE., the parameter
             will be unchanged, and IVALUE is a dummy argument.
             
             On return..
             IXSAV = The (old) value of the parameter.
             
             ***SEE ALSO  XERRWD, XERRWV
             ***ROUTINES CALLED  IUMACH
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Modified prologue to SLATEC format. (FNF)
             930915  Added IUMACH call to get default output unit.  (ACH)
             930922  Minor cosmetic changes. (FNF)
             010425  Type declaration for IUMACH added. (ACH)
             ***END PROLOGUE  IXSAV
             
             Subroutines called by IXSAV.. None
             Function routine called by IXSAV.. IUMACH
             -----------------------------------------------------------------------
             **End
             -----------------------------------------------------------------------
             -----------------------------------------------------------------------
             The following Fortran-77 declaration is to cause the values of the
             listed (local) variables to be saved between calls to this routine.
             -----------------------------------------------------------------------
             
             ***FIRST EXECUTABLE STATEMENT  IXSAV
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.IXSAV.Run(System.Int32,System.Int32,System.Boolean)">
             <summary>
             ***PURPOSE  Save and recall error message control parameters.
             ***CATEGORY  R3C
             ***TYPE      ALL (IXSAV-A)
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             
             IXSAV saves and recalls one of two error message parameters:
             LUNIT, the logical unit number to which messages are printed, and
             MESFLG, the message print flag.
             This is a modification of the SLATEC library routine J4SAVE.
             
             Saved local variables..
             LUNIT  = Logical unit number for messages.  The default is obtained
             by a call to IUMACH (may be machine-dependent).
             MESFLG = Print control flag..
             1 means print all messages (the default).
             0 means no printing.
             
             On input..
             IPAR   = Parameter indicator (1 for LUNIT, 2 for MESFLG).
             IVALUE = The value to be set for the parameter, if ISET = .TRUE.
             ISET   = Logical flag to indicate whether to read or write.
             If ISET = .TRUE., the parameter will be given
             the value IVALUE.  If ISET = .FALSE., the parameter
             will be unchanged, and IVALUE is a dummy argument.
             
             On return..
             IXSAV = The (old) value of the parameter.
             
             ***SEE ALSO  XERRWD, XERRWV
             ***ROUTINES CALLED  IUMACH
             ***REVISION HISTORY  (YYMMDD)
             921118  DATE WRITTEN
             930329  Modified prologue to SLATEC format. (FNF)
             930915  Added IUMACH call to get default output unit.  (ACH)
             930922  Minor cosmetic changes. (FNF)
             010425  Type declaration for IUMACH added. (ACH)
             ***END PROLOGUE  IXSAV
             
             Subroutines called by IXSAV.. None
             Function routine called by IXSAV.. IUMACH
             -----------------------------------------------------------------------
             **End
             -----------------------------------------------------------------------
             -----------------------------------------------------------------------
             The following Fortran-77 declaration is to cause the values of the
             listed (local) variables to be saved between calls to this routine.
             -----------------------------------------------------------------------
             
             ***FIRST EXECUTABLE STATEMENT  IXSAV
            </summary>
             <param name="IPAR">
             = Parameter indicator (1 for LUNIT, 2 for MESFLG).
            </param>
             <param name="IVALUE">
             = The value to be set for the parameter, if ISET = .TRUE.
            </param>
             <param name="ISET">
             = Logical flag to indicate whether to read or write.
             If ISET = .TRUE., the parameter will be given
             the value IVALUE.  If ISET = .FALSE., the parameter
             will be unchanged, and IVALUE is a dummy argument.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.IUMACH">
             <summary>
             ***PURPOSE  Provide standard output unit number.
             ***CATEGORY  R1
             ***TYPE      INTEGER (IUMACH-I)
             ***KEYWORDS  MACHINE CONSTANTS
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             *Usage:
             INTEGER  LOUT, IUMACH
             LOUT = IUMACH()
             
             *Function Return Values:
             LOUT : the standard logical unit for Fortran output.
             
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             930915  DATE WRITTEN
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  IUMACH
             
             *Internal Notes:
             The built-in value of 6 is standard on a wide range of Fortran
             systems.  This may be machine-dependent.
             **End
             ***FIRST EXECUTABLE STATEMENT  IUMACH
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.IUMACH.Run">
             <summary>
             ***PURPOSE  Provide standard output unit number.
             ***CATEGORY  R1
             ***TYPE      INTEGER (IUMACH-I)
             ***KEYWORDS  MACHINE CONSTANTS
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             *Usage:
             INTEGER  LOUT, IUMACH
             LOUT = IUMACH()
             
             *Function Return Values:
             LOUT : the standard logical unit for Fortran output.
             
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             930915  DATE WRITTEN
             930922  Made user-callable, and other cosmetic changes. (FNF)
             ***END PROLOGUE  IUMACH
             
             *Internal Notes:
             The built-in value of 6 is standard on a wide range of Fortran
             systems.  This may be machine-dependent.
             **End
             ***FIRST EXECUTABLE STATEMENT  IUMACH
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DUMACH">
             <summary>
             ***PURPOSE  Compute the unit roundoff of the machine.
             ***CATEGORY  R1
             ***TYPE      DOUBLE PRECISION (RUMACH-S, DUMACH-D)
             ***KEYWORDS  MACHINE CONSTANTS
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             *Usage:
             DOUBLE PRECISION  A, DUMACH
             A = DUMACH()
             
             *Function Return Values:
             A : the unit roundoff of the machine.
             
             *Description:
             The unit roundoff is defined as the smallest positive machine
             number u such that  1.0 + u .ne. 1.0.  This is computed by DUMACH
             in a machine-independent manner.
             
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  DUMSUM
             ***REVISION HISTORY  (YYYYMMDD)
             19930216  DATE WRITTEN
             19930818  Added SLATEC-format prologue.  (FNF)
             20030707  Added DUMSUM to force normal storage of COMP.  (ACH)
             ***END PROLOGUE  DUMACH
             
             ***FIRST EXECUTABLE STATEMENT  DUMACH
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DUMACH.Run">
             <summary>
             ***PURPOSE  Compute the unit roundoff of the machine.
             ***CATEGORY  R1
             ***TYPE      DOUBLE PRECISION (RUMACH-S, DUMACH-D)
             ***KEYWORDS  MACHINE CONSTANTS
             ***AUTHOR  Hindmarsh, Alan C., (LLNL)
             ***DESCRIPTION
             *Usage:
             DOUBLE PRECISION  A, DUMACH
             A = DUMACH()
             
             *Function Return Values:
             A : the unit roundoff of the machine.
             
             *Description:
             The unit roundoff is defined as the smallest positive machine
             number u such that  1.0 + u .ne. 1.0.  This is computed by DUMACH
             in a machine-independent manner.
             
             ***REFERENCES  (NONE)
             ***ROUTINES CALLED  DUMSUM
             ***REVISION HISTORY  (YYYYMMDD)
             19930216  DATE WRITTEN
             19930818  Added SLATEC-format prologue.  (FNF)
             20030707  Added DUMSUM to force normal storage of COMP.  (ACH)
             ***END PROLOGUE  DUMACH
             
             ***FIRST EXECUTABLE STATEMENT  DUMACH
            </summary>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DGEFA">
             <summary>
             ***PURPOSE  Factor a matrix using Gaussian elimination.
             ***CATEGORY  D2A1
             ***TYPE      DOUBLE PRECISION (SGEFA-S, DGEFA-D, CGEFA-C)
             ***KEYWORDS  GENERAL MATRIX, LINEAR ALGEBRA, LINPACK,
             MATRIX FACTORIZATION
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGEFA factors a double precision matrix by Gaussian elimination.
             
             DGEFA is usually called by DGECO, but it can be called
             directly with a saving in time if  RCOND  is not needed.
             (Time for DGECO) = (1 + 9/N)*(Time for DGEFA) .
             
             On Entry
             
             A       DOUBLE PRECISION(LDA, N)
             the matrix to be factored.
             
             LDA     INTEGER
             the leading dimension of the array  A .
             
             N       INTEGER
             the order of the matrix  A .
             
             On Return
             
             A       an upper triangular matrix and the multipliers
             which were used to obtain it.
             The factorization can be written  A = L*U  where
             L  is a product of permutation and unit lower
             triangular matrices and  U  is upper triangular.
             
             IPVT    INTEGER(N)
             an integer vector of pivot indices.
             
             INFO    INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGESL or DGEDI will divide by zero
             if called.  Use  RCOND  in DGECO for a reliable
             indication of singularity.
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGEFA
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DGEFA.Run(System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             ***PURPOSE  Factor a matrix using Gaussian elimination.
             ***CATEGORY  D2A1
             ***TYPE      DOUBLE PRECISION (SGEFA-S, DGEFA-D, CGEFA-C)
             ***KEYWORDS  GENERAL MATRIX, LINEAR ALGEBRA, LINPACK,
             MATRIX FACTORIZATION
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGEFA factors a double precision matrix by Gaussian elimination.
             
             DGEFA is usually called by DGECO, but it can be called
             directly with a saving in time if  RCOND  is not needed.
             (Time for DGECO) = (1 + 9/N)*(Time for DGEFA) .
             
             On Entry
             
             A       DOUBLE PRECISION(LDA, N)
             the matrix to be factored.
             
             LDA     INTEGER
             the leading dimension of the array  A .
             
             N       INTEGER
             the order of the matrix  A .
             
             On Return
             
             A       an upper triangular matrix and the multipliers
             which were used to obtain it.
             The factorization can be written  A = L*U  where
             L  is a product of permutation and unit lower
             triangular matrices and  U  is upper triangular.
             
             IPVT    INTEGER(N)
             an integer vector of pivot indices.
             
             INFO    INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGESL or DGEDI will divide by zero
             if called.  Use  RCOND  in DGECO for a reliable
             indication of singularity.
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGEFA
            </summary>
             <param name="A">
             DOUBLE PRECISION(LDA, N)
             the matrix to be factored.
            </param>
             <param name="LDA">
             INTEGER
             the leading dimension of the array  A .
            </param>
             <param name="N">
             INTEGER
             the order of the matrix  A .
            </param>
             <param name="IPVT">
             INTEGER(N)
             an integer vector of pivot indices.
            </param>
             <param name="INFO">
             INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGESL or DGEDI will divide by zero
             if called.  Use  RCOND  in DGECO for a reliable
             indication of singularity.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DGESL">
             <summary>
             ***PURPOSE  Solve the real system A*X=B or TRANS(A)*X=B using the
             factors computed by DGECO or DGEFA.
             ***CATEGORY  D2A1
             ***TYPE      DOUBLE PRECISION (SGESL-S, DGESL-D, CGESL-C)
             ***KEYWORDS  LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGESL solves the double precision system
             A * X = B  or  TRANS(A) * X = B
             using the factors computed by DGECO or DGEFA.
             
             On Entry
             
             A       DOUBLE PRECISION(LDA, N)
             the output from DGECO or DGEFA.
             
             LDA     INTEGER
             the leading dimension of the array  A .
             
             N       INTEGER
             the order of the matrix  A .
             
             IPVT    INTEGER(N)
             the pivot vector from DGECO or DGEFA.
             
             B       DOUBLE PRECISION(N)
             the right hand side vector.
             
             JOB     INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B  where
             TRANS(A)  is the transpose.
             
             On Return
             
             B       the solution vector  X .
             
             Error Condition
             
             A division by zero will occur if the input factor contains a
             zero on the diagonal.  Technically this indicates singularity
             but it is often caused by improper arguments or improper
             setting of LDA .  It will not occur if the subroutines are
             called correctly and if DGECO has set RCOND .GT. 0.0
             or DGEFA has set INFO .EQ. 0 .
             
             To compute  INVERSE(A) * C  where  C  is a matrix
             with  P  columns
             CALL DGECO(A,LDA,N,IPVT,RCOND,Z)
             IF (RCOND is too small) GO TO ...
             DO 10 J = 1, P
             CALL DGESL(A,LDA,N,IPVT,C(1,J),0)
             10 CONTINUE
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DDOT
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGESL
             
             ***FIRST EXECUTABLE STATEMENT  DGESL
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DGESL.Run(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Solve the real system A*X=B or TRANS(A)*X=B using the
             factors computed by DGECO or DGEFA.
             ***CATEGORY  D2A1
             ***TYPE      DOUBLE PRECISION (SGESL-S, DGESL-D, CGESL-C)
             ***KEYWORDS  LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGESL solves the double precision system
             A * X = B  or  TRANS(A) * X = B
             using the factors computed by DGECO or DGEFA.
             
             On Entry
             
             A       DOUBLE PRECISION(LDA, N)
             the output from DGECO or DGEFA.
             
             LDA     INTEGER
             the leading dimension of the array  A .
             
             N       INTEGER
             the order of the matrix  A .
             
             IPVT    INTEGER(N)
             the pivot vector from DGECO or DGEFA.
             
             B       DOUBLE PRECISION(N)
             the right hand side vector.
             
             JOB     INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B  where
             TRANS(A)  is the transpose.
             
             On Return
             
             B       the solution vector  X .
             
             Error Condition
             
             A division by zero will occur if the input factor contains a
             zero on the diagonal.  Technically this indicates singularity
             but it is often caused by improper arguments or improper
             setting of LDA .  It will not occur if the subroutines are
             called correctly and if DGECO has set RCOND .GT. 0.0
             or DGEFA has set INFO .EQ. 0 .
             
             To compute  INVERSE(A) * C  where  C  is a matrix
             with  P  columns
             CALL DGECO(A,LDA,N,IPVT,RCOND,Z)
             IF (RCOND is too small) GO TO ...
             DO 10 J = 1, P
             CALL DGESL(A,LDA,N,IPVT,C(1,J),0)
             10 CONTINUE
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DDOT
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGESL
             
             ***FIRST EXECUTABLE STATEMENT  DGESL
            </summary>
             <param name="A">
             DOUBLE PRECISION(LDA, N)
             the output from DGECO or DGEFA.
            </param>
             <param name="LDA">
             INTEGER
             the leading dimension of the array  A .
            </param>
             <param name="N">
             INTEGER
             the order of the matrix  A .
            </param>
             <param name="IPVT">
             INTEGER(N)
             the pivot vector from DGECO or DGEFA.
            </param>
             <param name="B">
             DOUBLE PRECISION(N)
             the right hand side vector.
            </param>
             <param name="JOB">
             INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B  where
             TRANS(A)  is the transpose.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DGBFA">
             <summary>
             ***PURPOSE  Factor a band matrix using Gaussian elimination.
             ***CATEGORY  D2A2
             ***TYPE      DOUBLE PRECISION (SGBFA-S, DGBFA-D, CGBFA-C)
             ***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX FACTORIZATION
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGBFA factors a double precision band matrix by elimination.
             
             DGBFA is usually called by DGBCO, but it can be called
             directly with a saving in time if  RCOND  is not needed.
             
             On Entry
             
             ABD     DOUBLE PRECISION(LDA, N)
             contains the matrix in band storage.  The columns
             of the matrix are stored in the columns of  ABD  and
             the diagonals of the matrix are stored in rows
             ML+1 through 2*ML+MU+1 of  ABD .
             See the comments below for details.
             
             LDA     INTEGER
             the leading dimension of the array  ABD .
             LDA must be .GE. 2*ML + MU + 1 .
             
             N       INTEGER
             the order of the original matrix.
             
             ML      INTEGER
             number of diagonals below the main diagonal.
             0 .LE. ML .LT.  N .
             
             MU      INTEGER
             number of diagonals above the main diagonal.
             0 .LE. MU .LT.  N .
             More efficient if  ML .LE. MU .
             On Return
             
             ABD     an upper triangular matrix in band storage and
             the multipliers which were used to obtain it.
             The factorization can be written  A = L*U  where
             L  is a product of permutation and unit lower
             triangular matrices and  U  is upper triangular.
             
             IPVT    INTEGER(N)
             an integer vector of pivot indices.
             
             INFO    INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGBSL will divide by zero if
             called.  Use  RCOND  in DGBCO for a reliable
             indication of singularity.
             
             Band Storage
             
             If  A  is a band matrix, the following program segment
             will set up the input.
             
             ML = (band width below the diagonal)
             MU = (band width above the diagonal)
             M = ML + MU + 1
             DO 20 J = 1, N
             I1 = MAX(1, J-MU)
             I2 = MIN(N, J+ML)
             DO 10 I = I1, I2
             K = I - J + M
             ABD(K,J) = A(I,J)
             10    CONTINUE
             20 CONTINUE
             
             This uses rows  ML+1  through  2*ML+MU+1  of  ABD .
             In addition, the first  ML  rows in  ABD  are used for
             elements generated during the triangularization.
             The total number of rows needed in  ABD  is  2*ML+MU+1 .
             The  ML+MU by ML+MU  upper left triangle and the
             ML by ML  lower right triangle are not referenced.
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGBFA
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DGBFA.Run(System.Double[]@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32@)">
             <summary>
             ***PURPOSE  Factor a band matrix using Gaussian elimination.
             ***CATEGORY  D2A2
             ***TYPE      DOUBLE PRECISION (SGBFA-S, DGBFA-D, CGBFA-C)
             ***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX FACTORIZATION
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGBFA factors a double precision band matrix by elimination.
             
             DGBFA is usually called by DGBCO, but it can be called
             directly with a saving in time if  RCOND  is not needed.
             
             On Entry
             
             ABD     DOUBLE PRECISION(LDA, N)
             contains the matrix in band storage.  The columns
             of the matrix are stored in the columns of  ABD  and
             the diagonals of the matrix are stored in rows
             ML+1 through 2*ML+MU+1 of  ABD .
             See the comments below for details.
             
             LDA     INTEGER
             the leading dimension of the array  ABD .
             LDA must be .GE. 2*ML + MU + 1 .
             
             N       INTEGER
             the order of the original matrix.
             
             ML      INTEGER
             number of diagonals below the main diagonal.
             0 .LE. ML .LT.  N .
             
             MU      INTEGER
             number of diagonals above the main diagonal.
             0 .LE. MU .LT.  N .
             More efficient if  ML .LE. MU .
             On Return
             
             ABD     an upper triangular matrix in band storage and
             the multipliers which were used to obtain it.
             The factorization can be written  A = L*U  where
             L  is a product of permutation and unit lower
             triangular matrices and  U  is upper triangular.
             
             IPVT    INTEGER(N)
             an integer vector of pivot indices.
             
             INFO    INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGBSL will divide by zero if
             called.  Use  RCOND  in DGBCO for a reliable
             indication of singularity.
             
             Band Storage
             
             If  A  is a band matrix, the following program segment
             will set up the input.
             
             ML = (band width below the diagonal)
             MU = (band width above the diagonal)
             M = ML + MU + 1
             DO 20 J = 1, N
             I1 = MAX(1, J-MU)
             I2 = MIN(N, J+ML)
             DO 10 I = I1, I2
             K = I - J + M
             ABD(K,J) = A(I,J)
             10    CONTINUE
             20 CONTINUE
             
             This uses rows  ML+1  through  2*ML+MU+1  of  ABD .
             In addition, the first  ML  rows in  ABD  are used for
             elements generated during the triangularization.
             The total number of rows needed in  ABD  is  2*ML+MU+1 .
             The  ML+MU by ML+MU  upper left triangle and the
             ML by ML  lower right triangle are not referenced.
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGBFA
            </summary>
             <param name="ABD">
             DOUBLE PRECISION(LDA, N)
             contains the matrix in band storage.  The columns
             of the matrix are stored in the columns of  ABD  and
             the diagonals of the matrix are stored in rows
             ML+1 through 2*ML+MU+1 of  ABD .
             See the comments below for details.
            </param>
             <param name="LDA">
             INTEGER
             the leading dimension of the array  ABD .
             LDA must be .GE. 2*ML + MU + 1 .
            </param>
             <param name="N">
             INTEGER
             the order of the original matrix.
            </param>
             <param name="ML">
             INTEGER
             number of diagonals below the main diagonal.
             0 .LE. ML .LT.  N .
            </param>
             <param name="MU">
             INTEGER
             number of diagonals above the main diagonal.
             0 .LE. MU .LT.  N .
             More efficient if  ML .LE. MU .
            </param>
             <param name="IPVT">
             INTEGER(N)
             an integer vector of pivot indices.
            </param>
             <param name="INFO">
             INTEGER
             = 0  normal value.
             = K  if  U(K,K) .EQ. 0.0 .  This is not an error
             condition for this subroutine, but it does
             indicate that DGBSL will divide by zero if
             called.  Use  RCOND  in DGBCO for a reliable
             indication of singularity.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DGBSL">
             <summary>
             ***PURPOSE  Solve the real band system A*X=B or TRANS(A)*X=B using
             the factors computed by DGBCO or DGBFA.
             ***CATEGORY  D2A2
             ***TYPE      DOUBLE PRECISION (SGBSL-S, DGBSL-D, CGBSL-C)
             ***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGBSL solves the double precision band system
             A * X = B  or  TRANS(A) * X = B
             using the factors computed by DGBCO or DGBFA.
             
             On Entry
             
             ABD     DOUBLE PRECISION(LDA, N)
             the output from DGBCO or DGBFA.
             
             LDA     INTEGER
             the leading dimension of the array  ABD .
             
             N       INTEGER
             the order of the original matrix.
             
             ML      INTEGER
             number of diagonals below the main diagonal.
             
             MU      INTEGER
             number of diagonals above the main diagonal.
             
             IPVT    INTEGER(N)
             the pivot vector from DGBCO or DGBFA.
             
             B       DOUBLE PRECISION(N)
             the right hand side vector.
             
             JOB     INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B , where
             TRANS(A)  is the transpose.
             
             On Return
             
             B       the solution vector  X .
             
             Error Condition
             
             A division by zero will occur if the input factor contains a
             zero on the diagonal.  Technically this indicates singularity
             but it is often caused by improper arguments or improper
             setting of LDA .  It will not occur if the subroutines are
             called correctly and if DGBCO has set RCOND .GT. 0.0
             or DGBFA has set INFO .EQ. 0 .
             
             To compute  INVERSE(A) * C  where  C  is a matrix
             with  P  columns
             CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
             IF (RCOND is too small) GO TO ...
             DO 10 J = 1, P
             CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
             10 CONTINUE
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DDOT
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGBSL
             
             ***FIRST EXECUTABLE STATEMENT  DGBSL
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DGBSL.Run(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Solve the real band system A*X=B or TRANS(A)*X=B using
             the factors computed by DGBCO or DGBFA.
             ***CATEGORY  D2A2
             ***TYPE      DOUBLE PRECISION (SGBSL-S, DGBSL-D, CGBSL-C)
             ***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
             ***AUTHOR  Moler, C. B., (U. of New Mexico)
             ***DESCRIPTION
             
             DGBSL solves the double precision band system
             A * X = B  or  TRANS(A) * X = B
             using the factors computed by DGBCO or DGBFA.
             
             On Entry
             
             ABD     DOUBLE PRECISION(LDA, N)
             the output from DGBCO or DGBFA.
             
             LDA     INTEGER
             the leading dimension of the array  ABD .
             
             N       INTEGER
             the order of the original matrix.
             
             ML      INTEGER
             number of diagonals below the main diagonal.
             
             MU      INTEGER
             number of diagonals above the main diagonal.
             
             IPVT    INTEGER(N)
             the pivot vector from DGBCO or DGBFA.
             
             B       DOUBLE PRECISION(N)
             the right hand side vector.
             
             JOB     INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B , where
             TRANS(A)  is the transpose.
             
             On Return
             
             B       the solution vector  X .
             
             Error Condition
             
             A division by zero will occur if the input factor contains a
             zero on the diagonal.  Technically this indicates singularity
             but it is often caused by improper arguments or improper
             setting of LDA .  It will not occur if the subroutines are
             called correctly and if DGBCO has set RCOND .GT. 0.0
             or DGBFA has set INFO .EQ. 0 .
             
             To compute  INVERSE(A) * C  where  C  is a matrix
             with  P  columns
             CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
             IF (RCOND is too small) GO TO ...
             DO 10 J = 1, P
             CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
             10 CONTINUE
             
             ***REFERENCES  J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W.
             Stewart, LINPACK Users' Guide, SIAM, 1979.
             ***ROUTINES CALLED  DAXPY, DDOT
             ***REVISION HISTORY  (YYMMDD)
             780814  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900326  Removed duplicate information from DESCRIPTION section.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DGBSL
             
             ***FIRST EXECUTABLE STATEMENT  DGBSL
            </summary>
             <param name="ABD">
             DOUBLE PRECISION(LDA, N)
             the output from DGBCO or DGBFA.
            </param>
             <param name="LDA">
             INTEGER
             the leading dimension of the array  ABD .
            </param>
             <param name="N">
             INTEGER
             the order of the original matrix.
            </param>
             <param name="ML">
             INTEGER
             number of diagonals below the main diagonal.
            </param>
             <param name="MU">
             INTEGER
             number of diagonals above the main diagonal.
            </param>
             <param name="IPVT">
             INTEGER(N)
             the pivot vector from DGBCO or DGBFA.
            </param>
             <param name="B">
             DOUBLE PRECISION(N)
             the right hand side vector.
            </param>
             <param name="JOB">
             INTEGER
             = 0         to solve  A*X = B ,
             = nonzero   to solve  TRANS(A)*X = B , where
             TRANS(A)  is the transpose.
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DAXPY">
             <summary>
             ***PURPOSE  Compute a constant times a vector plus a vector.
             ***CATEGORY  D1A7
             ***TYPE      DOUBLE PRECISION (SAXPY-S, DAXPY-D, CAXPY-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, TRIAD, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DA  double precision scalar multiplier
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DY  double precision result (unchanged if N .LE. 0)
             
             Overwrite double precision DY with double precision DA*DX + DY.
             For I = 0 to N-1, replace  DY(LY+I*INCY) with DA*DX(LX+I*INCX) +
             DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DAXPY
             ***FIRST EXECUTABLE STATEMENT  DAXPY
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DAXPY.Run(System.Int32,System.Double,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Compute a constant times a vector plus a vector.
             ***CATEGORY  D1A7
             ***TYPE      DOUBLE PRECISION (SAXPY-S, DAXPY-D, CAXPY-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, TRIAD, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DA  double precision scalar multiplier
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DY  double precision result (unchanged if N .LE. 0)
             
             Overwrite double precision DY with double precision DA*DX + DY.
             For I = 0 to N-1, replace  DY(LY+I*INCY) with DA*DX(LX+I*INCX) +
             DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DAXPY
             ***FIRST EXECUTABLE STATEMENT  DAXPY
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DA">
             double precision scalar multiplier
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
             DY  double precision vector with N elements
            </param>
             <param name="DY">
             double precision vector with N elements
            </param>
             <param name="INCY">
             storage spacing between elements of DY
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DCOPY">
             <summary>
             ***PURPOSE  Copy a vector.
             ***CATEGORY  D1A5
             ***TYPE      DOUBLE PRECISION (SCOPY-S, DCOPY-D, CCOPY-C, ICOPY-I)
             ***KEYWORDS  BLAS, COPY, LINEAR ALGEBRA, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DY  copy of vector DX (unchanged if N .LE. 0)
             
             Copy double precision DX to double precision DY.
             For I = 0 to N-1, copy DX(LX+I*INCX) to DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DCOPY
             ***FIRST EXECUTABLE STATEMENT  DCOPY
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DCOPY.Run(System.Int32,System.Double[],System.Int32,System.Int32,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Copy a vector.
             ***CATEGORY  D1A5
             ***TYPE      DOUBLE PRECISION (SCOPY-S, DCOPY-D, CCOPY-C, ICOPY-I)
             ***KEYWORDS  BLAS, COPY, LINEAR ALGEBRA, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DY  copy of vector DX (unchanged if N .LE. 0)
             
             Copy double precision DX to double precision DY.
             For I = 0 to N-1, copy DX(LX+I*INCX) to DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DCOPY
             ***FIRST EXECUTABLE STATEMENT  DCOPY
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
             DY  double precision vector with N elements
            </param>
             <param name="DY">
             double precision vector with N elements
            </param>
             <param name="INCY">
             storage spacing between elements of DY
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DDOT">
             <summary>
             ***PURPOSE  Compute the inner product of two vectors.
             ***CATEGORY  D1A4
             ***TYPE      DOUBLE PRECISION (SDOT-S, DDOT-D, CDOTU-C)
             ***KEYWORDS  BLAS, INNER PRODUCT, LINEAR ALGEBRA, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DDOT  double precision dot product (zero if N .LE. 0)
             
             Returns the dot product of double precision DX and DY.
             DDOT = sum for I = 0 to N-1 of  DX(LX+I*INCX) * DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DDOT
             ***FIRST EXECUTABLE STATEMENT  DDOT
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DDOT.Run(System.Int32,System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Compute the inner product of two vectors.
             ***CATEGORY  D1A4
             ***TYPE      DOUBLE PRECISION (SDOT-S, DDOT-D, CDOTU-C)
             ***KEYWORDS  BLAS, INNER PRODUCT, LINEAR ALGEBRA, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             DY  double precision vector with N elements
             INCY  storage spacing between elements of DY
             
             --Output--
             DDOT  double precision dot product (zero if N .LE. 0)
             
             Returns the dot product of double precision DX and DY.
             DDOT = sum for I = 0 to N-1 of  DX(LX+I*INCX) * DY(LY+I*INCY),
             where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
             defined in a similar way using INCY.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920310  Corrected definition of LX in DESCRIPTION.  (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DDOT
             ***FIRST EXECUTABLE STATEMENT  DDOT
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
             DY  double precision vector with N elements
            </param>
             <param name="DY">
             double precision vector with N elements
            </param>
             <param name="INCY">
             storage spacing between elements of DY
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DNRM2">
             <summary>
             ***PURPOSE  Compute the Euclidean length (L2 norm) of a vector.
             ***CATEGORY  D1A3B
             ***TYPE      DOUBLE PRECISION (SNRM2-S, DNRM2-D, SCNRM2-C)
             ***KEYWORDS  BLAS, EUCLIDEAN LENGTH, EUCLIDEAN NORM, L2,
             LINEAR ALGEBRA, UNITARY, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             DNRM2  double precision result (zero if N .LE. 0)
             
             Euclidean norm of the N-vector stored in DX with storage
             increment INCX.
             If N .LE. 0, return with result = 0.
             If N .GE. 1, then INCX must be .GE. 1
             
             Four phase method using two built-in constants that are
             hopefully applicable to all machines.
             CUTLO = maximum of  SQRT(U/EPS)  over all known machines.
             CUTHI = minimum of  SQRT(V)      over all known machines.
             where
             EPS = smallest no. such that EPS + 1. .GT. 1.
             U   = smallest positive no.   (underflow limit)
             V   = largest  no.            (overflow  limit)
             
             Brief outline of algorithm.
             
             Phase 1 scans zero components.
             move to phase 2 when a component is nonzero and .LE. CUTLO
             move to phase 3 when a component is .GT. CUTLO
             move to phase 4 when a component is .GE. CUTHI/M
             where M = N for X() real and M = 2*N for complex.
             
             Values for CUTLO and CUTHI.
             From the environmental parameters listed in the IMSL converter
             document the limiting values are as follows:
             CUTLO, S.P.   U/EPS = 2**(-102) for  Honeywell.  Close seconds are
             Univac and DEC at 2**(-103)
             Thus CUTLO = 2**(-51) = 4.44089E-16
             CUTHI, S.P.   V = 2**127 for Univac, Honeywell, and DEC.
             Thus CUTHI = 2**(63.5) = 1.30438E19
             CUTLO, D.P.   U/EPS = 2**(-67) for Honeywell and DEC.
             Thus CUTLO = 2**(-33.5) = 8.23181D-11
             CUTHI, D.P.   same as S.P.  CUTHI = 1.30438D19
             DATA CUTLO, CUTHI /8.232D-11,  1.304D19/
             DATA CUTLO, CUTHI /4.441E-16,  1.304E19/
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DNRM2
             
             ***FIRST EXECUTABLE STATEMENT  DNRM2
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DNRM2.Run(System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Compute the Euclidean length (L2 norm) of a vector.
             ***CATEGORY  D1A3B
             ***TYPE      DOUBLE PRECISION (SNRM2-S, DNRM2-D, SCNRM2-C)
             ***KEYWORDS  BLAS, EUCLIDEAN LENGTH, EUCLIDEAN NORM, L2,
             LINEAR ALGEBRA, UNITARY, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             DNRM2  double precision result (zero if N .LE. 0)
             
             Euclidean norm of the N-vector stored in DX with storage
             increment INCX.
             If N .LE. 0, return with result = 0.
             If N .GE. 1, then INCX must be .GE. 1
             
             Four phase method using two built-in constants that are
             hopefully applicable to all machines.
             CUTLO = maximum of  SQRT(U/EPS)  over all known machines.
             CUTHI = minimum of  SQRT(V)      over all known machines.
             where
             EPS = smallest no. such that EPS + 1. .GT. 1.
             U   = smallest positive no.   (underflow limit)
             V   = largest  no.            (overflow  limit)
             
             Brief outline of algorithm.
             
             Phase 1 scans zero components.
             move to phase 2 when a component is nonzero and .LE. CUTLO
             move to phase 3 when a component is .GT. CUTLO
             move to phase 4 when a component is .GE. CUTHI/M
             where M = N for X() real and M = 2*N for complex.
             
             Values for CUTLO and CUTHI.
             From the environmental parameters listed in the IMSL converter
             document the limiting values are as follows:
             CUTLO, S.P.   U/EPS = 2**(-102) for  Honeywell.  Close seconds are
             Univac and DEC at 2**(-103)
             Thus CUTLO = 2**(-51) = 4.44089E-16
             CUTHI, S.P.   V = 2**127 for Univac, Honeywell, and DEC.
             Thus CUTHI = 2**(63.5) = 1.30438E19
             CUTLO, D.P.   U/EPS = 2**(-67) for Honeywell and DEC.
             Thus CUTLO = 2**(-33.5) = 8.23181D-11
             CUTHI, D.P.   same as S.P.  CUTHI = 1.30438D19
             DATA CUTLO, CUTHI /8.232D-11,  1.304D19/
             DATA CUTLO, CUTHI /4.441E-16,  1.304E19/
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DNRM2
             
             ***FIRST EXECUTABLE STATEMENT  DNRM2
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.DSCAL">
             <summary>
             ***PURPOSE  Multiply a vector by a constant.
             ***CATEGORY  D1A6
             ***TYPE      DOUBLE PRECISION (SSCAL-S, DSCAL-D, CSCAL-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, SCALE, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DA  double precision scale factor
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             DX  double precision result (unchanged if N.LE.0)
             
             Replace double precision DX by double precision DA*DX.
             For I = 0 to N-1, replace DX(IX+I*INCX) with  DA * DX(IX+I*INCX),
             where IX = 1 if INCX .GE. 0, else IX = 1+(1-N)*INCX.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900821  Modified to correct problem with a negative increment.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DSCAL
             ***FIRST EXECUTABLE STATEMENT  DSCAL
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.DSCAL.Run(System.Int32,System.Double,System.Double[]@,System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Multiply a vector by a constant.
             ***CATEGORY  D1A6
             ***TYPE      DOUBLE PRECISION (SSCAL-S, DSCAL-D, CSCAL-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, SCALE, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DA  double precision scale factor
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             DX  double precision result (unchanged if N.LE.0)
             
             Replace double precision DX by double precision DA*DX.
             For I = 0 to N-1, replace DX(IX+I*INCX) with  DA * DX(IX+I*INCX),
             where IX = 1 if INCX .GE. 0, else IX = 1+(1-N)*INCX.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890831  Modified array declarations.  (WRB)
             890831  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900821  Modified to correct problem with a negative increment.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  DSCAL
             ***FIRST EXECUTABLE STATEMENT  DSCAL
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DA">
             double precision scale factor
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
            </param>
        </member>
        <member name="T:DotNumerics.ODE.DVode.IDAMAX">
             <summary>
             ***PURPOSE  Find the smallest index of that component of a vector
             having the maximum magnitude.
             ***CATEGORY  D1A2
             ***TYPE      DOUBLE PRECISION (ISAMAX-S, IDAMAX-D, ICAMAX-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, MAXIMUM COMPONENT, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             IDAMAX  smallest index (zero if N .LE. 0)
             
             Find smallest index of maximum magnitude of double precision DX.
             IDAMAX = first I, I = 1 to N, to maximize ABS(DX(IX+(I-1)*INCX)),
             where IX = 1 if INCX .GE. 0, else IX = 1+(1-N)*INCX.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890531  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900821  Modified to correct problem with a negative increment.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  IDAMAX
             ***FIRST EXECUTABLE STATEMENT  IDAMAX
            </summary>
        </member>
        <member name="M:DotNumerics.ODE.DVode.IDAMAX.Run(System.Int32,System.Double[],System.Int32,System.Int32)">
             <summary>
             ***PURPOSE  Find the smallest index of that component of a vector
             having the maximum magnitude.
             ***CATEGORY  D1A2
             ***TYPE      DOUBLE PRECISION (ISAMAX-S, IDAMAX-D, ICAMAX-C)
             ***KEYWORDS  BLAS, LINEAR ALGEBRA, MAXIMUM COMPONENT, VECTOR
             ***AUTHOR  Lawson, C. L., (JPL)
             Hanson, R. J., (SNLA)
             Kincaid, D. R., (U. of Texas)
             Krogh, F. T., (JPL)
             ***DESCRIPTION
             
             B L A S  Subprogram
             Description of Parameters
             
             --Input--
             N  number of elements in input vector(s)
             DX  double precision vector with N elements
             INCX  storage spacing between elements of DX
             
             --Output--
             IDAMAX  smallest index (zero if N .LE. 0)
             
             Find smallest index of maximum magnitude of double precision DX.
             IDAMAX = first I, I = 1 to N, to maximize ABS(DX(IX+(I-1)*INCX)),
             where IX = 1 if INCX .GE. 0, else IX = 1+(1-N)*INCX.
             
             ***REFERENCES  C. L. Lawson, R. J. Hanson, D. R. Kincaid and F. T.
             Krogh, Basic linear algebra subprograms for Fortran
             usage, Algorithm No. 539, Transactions on Mathematical
             Software 5, 3 (September 1979), pp. 308-323.
             ***ROUTINES CALLED  (NONE)
             ***REVISION HISTORY  (YYMMDD)
             791001  DATE WRITTEN
             890531  Changed all specific intrinsics to generic.  (WRB)
             890531  REVISION DATE from Version 3.2
             891214  Prologue converted to Version 4.0 format.  (BAB)
             900821  Modified to correct problem with a negative increment.
             (WRB)
             920501  Reformatted the REFERENCES section.  (WRB)
             ***END PROLOGUE  IDAMAX
             ***FIRST EXECUTABLE STATEMENT  IDAMAX
            </summary>
             <param name="N">
             number of elements in input vector(s)
            </param>
             <param name="DX">
             double precision vector with N elements
            </param>
             <param name="INCX">
             storage spacing between elements of DX
            </param>
        </member>
    </members>
</doc>
